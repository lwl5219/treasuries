<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>

    <title>Chapter 10 Exceptions</title>
    <meta content="urn:uuid:232c2138-be82-42d4-8a6b-b460372314a4" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../../4bgup-l038f.html">Effective Java, Third Edition
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    Joshua Bloch

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="ch9.xhtml" class="calibreAPrev">previous page
</a>
        

        
          <a href="ch11.xhtml" class="calibreANext">next page
</a>
        
      </div>
    

    
      
      <h2 class="h1" id="ch10"><span epub:type="pagebreak" id="page_293" class="calibre15"></span>Chapter 10. Exceptions
      </h2>
      
      <p class="noindent"><strong class="calibre11">W</strong><small class="calibre13">HEN</small> used to best advantage, exceptions can improve a program’s readability, reliability,
         and maintainability. When used improperly, they can have the opposite effect. This
         chapter provides guidelines for using exceptions effectively.
      </p>
      
      <h3 class="h2"><a id="lev69" class="calibre4"></a><strong class="calibre10">Item 69: Use exceptions only for exceptional conditions</strong></h3>
      
      <p class="noindent">Someday, if you are unlucky, you may stumble across a piece of code that looks something
         like this:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex1a" id="pch10ex1" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Horrible abuse of exceptions. Don't ever do this!</strong><br class="calibre7"/>
         try {<br class="calibre7"/>
             int i = 0;<br class="calibre7"/>
             while(true)<br class="calibre7"/>
                 range[i++].climb();<br class="calibre7"/>
         } catch (ArrayIndexOutOfBoundsException e) {<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">What does this code do? It’s not at all obvious from inspection, and that’s reason
         enough not to use it (<a href="ch9.xhtml#lev67" class="calibre8">Item 67</a>). It turns out to be a horribly ill-conceived idiom for looping through the elements
         of an array. The infinite loop terminates by throwing, catching, and ignoring an <code class="calibre12">ArrayIndexOutOfBoundsException</code> when it attempts to access the first array element outside the bounds of the array.
         It’s supposed to be equivalent to the standard idiom for looping through an array,
         which is instantly recognizable to any Java programmer:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex2a" id="pch10ex2" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">for (Mountain m : range)<br class="calibre7"/>
             m.climb();
      </p>
      
      <p class="indentb">So why would anyone use the exception-based loop in preference to the tried and true?
         It’s a misguided attempt to improve performance based on the faulty <span epub:type="pagebreak" id="page_294"></span>reasoning that, since the VM checks the bounds of all array accesses, the normal loop
         termination test—hidden by the compiler but still present in the for-each loop—is
         redundant and should be avoided. There are three things wrong with this reasoning:
      </p>
      
      <p class="bullb">• Because exceptions are designed for exceptional circumstances, there is little incentive
         for JVM implementors to make them as fast as explicit tests.
      </p>
      
      <p class="bullb">• Placing code inside a <code class="calibre12">try-catch</code> block inhibits certain optimizations that JVM implementations might otherwise perform.
      </p>
      
      <p class="bullb">• The standard idiom for looping through an array doesn’t necessarily result in redundant
         checks. Many JVM implementations optimize them away.
      </p>
      
      <p class="indent">In fact, the exception-based idiom is far slower than the standard one. On my machine,
         the exception-based idiom is about twice as slow as the standard one for arrays of
         one hundred elements.
      </p>
      
      <p class="indent">Not only does the exception-based loop obfuscate the purpose of the code and reduce
         its performance, but it’s not guaranteed to work. If there is a bug in the loop, the
         use of exceptions for flow control can mask the bug, greatly complicating the debugging
         process. Suppose the computation in the body of the loop invokes a method that performs
         an out-of-bounds access to some unrelated array. If a reasonable loop idiom were used,
         the bug would generate an uncaught exception, resulting in immediate thread termination
         with a full stack trace. If the misguided exception-based loop were used, the bug-related
         exception would be caught and misinterpreted as a normal loop termination.
      </p>
      
      <p class="indent">The moral of this story is simple: <strong class="calibre11">Exceptions are, as their name implies, to be used only for exceptional conditions;
            they should never be used for ordinary control flow.</strong> More generally, use standard, easily recognizable idioms in preference to overly
         clever techniques that purport to offer better performance. Even if the performance
         advantage is real, it may not remain in the face of steadily improving platform implementations.
         The subtle bugs and maintenance headaches that come from overly clever techniques,
         however, are sure to remain.
      </p>
      
      <p class="indent">This principle also has implications for API design. <strong class="calibre11">A well-designed API must not force its clients to use exceptions for ordinary control
            flow.</strong> A class with a “state-dependent” method that can be invoked only under certain unpredictable
         conditions should generally have a separate “state-testing” method indicating whether
         it is appropriate to invoke the state-dependent method. For example, the <code class="calibre12">Iterator</code> interface has the state-dependent method <code class="calibre12">next</code> and the <span epub:type="pagebreak" id="page_295"></span>corresponding state-testing method <code class="calibre12">hasNext</code>. This enables the standard idiom for iterating over a collection with a traditional
         <code class="calibre12">for</code> loop (as well as the for-each loop, where the <code class="calibre12">hasNext</code> method is used internally):
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex3a" id="pch10ex3" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">for (Iterator&lt;Foo&gt; i = collection.iterator(); i.hasNext(); ) {<br class="calibre7"/>
             Foo foo = i.next();<br class="calibre7"/>
             ...<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">If <code class="calibre12">Iterator</code> lacked the <code class="calibre12">hasNext</code> method, clients would be forced to do this instead:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex4a" id="pch10ex4" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Do not use this hideous code for iteration over a collection!</strong><br class="calibre7"/>
         try {<br class="calibre7"/>
             Iterator&lt;Foo&gt; i = collection.iterator();<br class="calibre7"/>
             while(true) {<br class="calibre7"/>
                 Foo foo = i.next();<br class="calibre7"/>
                 ...<br class="calibre7"/>
             }<br class="calibre7"/>
         } catch (NoSuchElementException e) {<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">This should look very familiar after the array iteration example that began this item.
         In addition to being wordy and misleading, the exception-based loop is likely to perform
         poorly and can mask bugs in unrelated parts of the system.
      </p>
      
      <p class="indent">An alternative to providing a separate state-testing method is to have the state-dependent
         method return an empty optional (<a href="ch8.xhtml#lev55" class="calibre8">Item 55</a>) or a distinguished value such as <code class="calibre12">null</code> if it cannot perform the desired computation.
      </p>
      
      <p class="indent">Here are some guidelines to help you choose between a state-testing method and an
         optional or distinguished return value. If an object is to be accessed concurrently
         without external synchronization or is subject to externally induced state transitions,
         you must use an optional or distinguished return value, as the object’s state could
         change in the interval between the invocation of a state-testing method and its state-dependent
         method. Performance concerns may dictate that an optional or distinguished return
         value be used if a separate state-testing method would duplicate the work of the state-dependent
         method. All other things being equal, a state-testing method is mildly preferable
         to a distinguished return value. It offers slightly better readability, and incorrect
         use may be easier to detect: if you forget to call a state-testing method, the state-dependent
         method will throw an exception, making the bug obvious; if you forget to check for
         a distinguished return value, the bug may be subtle. This is not an issue for optional
         return values.
      </p>
      
      <p class="indent">In summary, exceptions are designed for exceptional conditions. Don’t use them for
         ordinary control flow, and don’t write APIs that force others to do so.
      </p>
      
      <h3 class="h2"><a id="lev70" class="calibre4"></a><span epub:type="pagebreak" id="page_296" class="calibre15"></span><strong class="calibre10">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions
            for programming errors</strong></h3>
      
      <p class="noindent">Java provides three kinds of throwables: <em class="calibre9">checked exceptions</em>, <em class="calibre9">runtime exceptions</em>, and <em class="calibre9">errors</em>. There is some confusion among programmers as to when it is appropriate to use each
         kind of throwable. While the decision is not always clear-cut, there are some general
         rules that provide strong guidance.
      </p>
      
      <p class="indent">The cardinal rule in deciding whether to use a checked or an unchecked exception is
         this: <strong class="calibre11">use checked exceptions for conditions from which the caller can reasonably be expected
            to recover.</strong> By throwing a checked exception, you force the caller to handle the exception in
         a <code class="calibre12">catch</code> clause or to propagate it outward. Each checked exception that a method is declared
         to throw is therefore a potent indication to the API user that the associated condition
         is a possible outcome of invoking the method.
      </p>
      
      <p class="indent">By confronting the user with a checked exception, the API designer presents a mandate
         to recover from the condition. The user can disregard the mandate by catching the
         exception and ignoring it, but this is usually a bad idea (<a href="ch10.xhtml#lev77" class="calibre8">Item 77</a>).
      </p>
      
      <p class="indent">There are two kinds of unchecked throwables: runtime exceptions and errors. They are
         identical in their behavior: both are throwables that needn’t, and generally shouldn’t,
         be caught. If a program throws an unchecked exception or an error, it is generally
         the case that recovery is impossible and continued execution would do more harm than
         good. If a program does not catch such a throwable, it will cause the current thread
         to halt with an appropriate error message.
      </p>
      
      <p class="indent"><strong class="calibre11">Use runtime exceptions to indicate programming errors.</strong> The great majority of runtime exceptions indicate <em class="calibre9">precondition violations</em>. A precondition violation is simply a failure by the client of an API to adhere to
         the contract established by the API specification. For example, the contract for array
         access specifies that the array index must be between zero and the array length minus
         one, inclusive. <code class="calibre12">ArrayIndexOutOfBoundsException</code> indicates that this precondition was violated.
      </p>
      
      <p class="indent">One problem with this advice is that it is not always clear whether you’re dealing
         with a recoverable conditions or a programming error. For example, consider the case
         of resource exhaustion, which can be caused by a programming error such as allocating
         an unreasonably large array, or by a genuine shortage of resources. If resource exhaustion
         is caused by a temporary shortage or by temporarily heightened demand, the condition
         may well be recoverable. It is a matter of judgment on the part of the API designer
         whether a given instance of resource exhaustion is likely to allow for recovery. If
         you believe a condition is likely to allow for recovery, use a checked exception;
         if not, use a runtime <span epub:type="pagebreak" id="page_297"></span>exception. If it isn’t clear whether recovery is possible, you’re probably better
         off using an unchecked exception, for reasons discussed in <a href="ch10.xhtml#lev71" class="calibre8">Item 71</a>.
      </p>
      
      <p class="indent">While the Java Language Specification does not require it, there is a strong convention
         that <em class="calibre9">errors</em> are reserved for use by the JVM to indicate resource deficiencies, invariant failures,
         or other conditions that make it impossible to continue execution. Given the almost
         universal acceptance of this convention, it’s best not to implement any new <code class="calibre12">Error</code> subclasses. Therefore, <strong class="calibre11">all of the unchecked throwables you implement should subclass</strong> <code class="calibre12"><strong class="calibre11">RuntimeException</strong></code> (directly or indirectly). Not only shouldn’t you define <code class="calibre12">Error</code> subclasses, but with the exception of <code class="calibre12">AssertionError</code>, you shouldn’t throw them either.
      </p>
      
      <p class="indent">It is possible to define a throwable that is not a subclass of <code class="calibre12">Exception</code>, <code class="calibre12">RuntimeException</code>, or <code class="calibre12">Error</code>. The JLS doesn’t address such throwables directly but specifies implicitly that they
         behave as ordinary checked exceptions (which are subclasses of <code class="calibre12">Exception</code> but not <code class="calibre12">RuntimeException</code>). So when should you use such a beast? In a word, never. They have no benefits over
         ordinary checked exceptions and would serve merely to confuse the user of your API.
      </p>
      
      <p class="indent">API designers often forget that exceptions are full-fledged objects on which arbitrary
         methods can be defined. The primary use of such methods is to provide code that catches
         the exception with additional information concerning the condition that caused the
         exception to be thrown. In the absence of such methods, programmers have been known
         to parse the string representation of an exception to ferret out additional information.
         This is extremely bad practice (<a href="ch3.xhtml#lev12" class="calibre8">Item 12</a>). Throwable classes seldom specify the details of their string representations, so
         string representations can differ from implementation to implementation and release
         to release. Therefore, code that parses the string representation of an exception
         is likely to be nonportable and fragile.
      </p>
      
      <p class="indent">Because checked exceptions generally indicate recoverable conditions, it’s especially
         important for them to provide methods that furnish information to help the caller
         recover from the exceptional condition. For example, suppose a checked exception is
         thrown when an attempt to make a purchase with a gift card fails due to insufficient
         funds. The exception should provide an accessor method to query the amount of the
         shortfall. This will enable the caller to relay the amount to the shopper. See <a href="ch10.xhtml#lev75" class="calibre8">Item 75</a> for more on this topic.
      </p>
      
      <p class="indent">To summarize, throw checked exceptions for recoverable conditions and unchecked exceptions
         for programming errors. When in doubt, throw unchecked exceptions. Don’t define any
         throwables that are neither checked exceptions nor runtime exceptions. Provide methods
         on your checked exceptions to aid in recovery.
      </p>
      
      <h3 class="h2"><a id="lev71" class="calibre4"></a><span epub:type="pagebreak" id="page_298" class="calibre15"></span><strong class="calibre10">Item 71: Avoid unnecessary use of checked exceptions</strong></h3>
      
      <p class="noindent">Many Java programmers dislike checked exceptions, but used properly, they can improve
         APIs and programs. Unlike return codes and unchecked exceptions, they <em class="calibre9">force</em> programmers to deal with problems, enhancing reliability. That said, overuse of checked
         exceptions in APIs can make them far less pleasant to use. If a method throws checked
         exceptions, the code that invokes it must handle them in one or more <code class="calibre12">catch</code> blocks, or declare that it throws them and let them propagate outward. Either way,
         it places a burden on the user of the API. The burden increased in Java 8, as methods
         throwing checked exceptions can’t be used directly in streams (<a href="ch7.xhtml#lev45" class="calibre8">Items 45</a>–<a href="ch7.xhtml#lev48" class="calibre8">48</a>).
      </p>
      
      <p class="indent">This burden may be justified if the exceptional condition cannot be prevented by proper
         use of the API <em class="calibre9">and</em> the programmer using the API can take some useful action once confronted with the
         exception. Unless both of these conditions are met, an unchecked exception is appropriate.
         As a litmus test, ask yourself how the programmer will handle the exception. Is this
         the best that can be done?
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex5a" id="pch10ex5" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">} catch (TheCheckedException e) {<br class="calibre7"/>
             throw new AssertionError(); // Can't happen!<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Or this?</p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex6a" id="pch10ex6" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">} catch (TheCheckedException e) {<br class="calibre7"/>
             e.printStackTrace();        // Oh well, we lose.<br class="calibre7"/>
             System.exit(1);<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">If the programmer can do no better, an unchecked exception is called for.</p>
      
      <p class="indent">The additional burden on the programmer caused by a checked exception is substantially
         higher if it is the <em class="calibre9">sole</em> checked exception thrown by a method. If there are others, the method must already
         appear in a <code class="calibre12">try</code> block, and this exception requires, at most, another <code class="calibre12">catch</code> block. If a method throws a single checked exception, this exception is the sole
         reason the method must appear in a <code class="calibre12">try</code> block and can’t be used directly in streams. Under these circumstances, it pays to
         ask yourself if there is a way to avoid the checked exception.
      </p>
      
      <p class="indent">The easiest way to eliminate a checked exception is to return an <em class="calibre9">optional</em> of the desired result type (<a href="ch8.xhtml#lev55" class="calibre8">Item 55</a>). Instead of throwing a checked exception, the method simply returns an empty optional.
         The disadvantage of this technique is that the method can’t return any additional
         information detailing its inability to perform the desired computation. Exceptions,
         by contrast, have descriptive types, and can export methods to provide additional
         information (<a href="ch10.xhtml#lev70" class="calibre8">Item 70</a>).
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_299"></span>You can also turn a checked exception into an unchecked exception by breaking the
         method that throws the exception into two methods, the first of which returns a <code class="calibre12">boolean</code> indicating whether the exception would be thrown. This API refactoring transforms
         the calling sequence from this:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex7a" id="pch10ex7" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Invocation with checked exception</strong><br class="calibre7"/>
         try {<br class="calibre7"/>
             obj.action(args);<br class="calibre7"/>
         } catch (TheCheckedException e) {<br class="calibre7"/>
             ... // Handle exceptional condition<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">into this:</p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex8a" id="pch10ex8" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Invocation with state-testing method and unchecked exception</strong><br class="calibre7"/>
         if (obj.actionPermitted(args)) {<br class="calibre7"/>
             obj.action(args);<br class="calibre7"/>
         } else {<br class="calibre7"/>
             ... // Handle exceptional condition<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">This refactoring is not always appropriate, but where it is, it can make an API more
         pleasant to use. While the latter calling sequence is no prettier than the former,
         the refactored API is more flexible. If the programmer knows the call will succeed,
         or is content to let the thread terminate if it fails, the refactoring also allows
         this trivial calling sequence:
      </p>
      
      <p class="codep1">obj.action(args);</p>
      
      <p class="indent">If you suspect that the trivial calling sequence will be the norm, then the API refactoring
         may be appropriate. The resulting API is essentially the state-testing method API
         in <a href="ch10.xhtml#lev69" class="calibre8">Item 69</a> and the same caveats apply: if an object is to be accessed concurrently without external
         synchronization or it is subject to externally induced state transitions, this refactoring
         is inappropriate because the object’s state may change between the calls to <code class="calibre12">actionPermitted</code> and <code class="calibre12">action</code>. If a separate <code class="calibre12">actionPermitted</code> method would duplicate the work of the <code class="calibre12">action</code> method, the refactoring may be ruled out on performance grounds.
      </p>
      
      <p class="indent">In summary, when used sparingly, checked exceptions can increase the reliability of
         programs; when overused, they make APIs painful to use. If callers won’t be able to
         recover from failures, throw unchecked exceptions. If recovery may be possible and
         you want to <em class="calibre9">force</em> callers to handle exceptional conditions, first consider returning an optional. Only
         if this would provide insufficient information in the case of failure should you throw
         a checked exception.
      </p>
      
      <h3 class="h2"><a id="lev72" class="calibre4"></a><span epub:type="pagebreak" id="page_300" class="calibre15"></span><strong class="calibre10">Item 72: Favor the use of standard exceptions</strong></h3>
      
      <p class="noindent">An attribute that distinguishes expert programmers from less experienced ones is that
         experts strive for and usually achieve a high degree of code reuse. Exceptions are
         no exception to the rule that code reuse is a good thing. The Java libraries provide
         a set of exceptions that covers most of the exception-throwing needs of most APIs.
      </p>
      
      <p class="indent">Reusing standard exceptions has several benefits. Chief among them is that it makes
         your API easier to learn and use because it matches the established conventions that
         programmers are already familiar with. A close second is that programs using your
         API are easier to read because they aren’t cluttered with unfamiliar exceptions. Last
         (and least), fewer exception classes means a smaller memory footprint and less time
         spent loading classes.
      </p>
      
      <p class="indent">The most commonly reused exception type is <code class="calibre12">IllegalArgumentException</code> (<a href="ch8.xhtml#lev49" class="calibre8">Item 49</a>). This is generally the exception to throw when the caller passes in an argument
         whose value is inappropriate. For example, this would be the exception to throw if
         the caller passed a negative number in a parameter representing the number of times
         some action was to be repeated.
      </p>
      
      <p class="indent">Another commonly reused exception is <code class="calibre12">IllegalStateException</code>. This is generally the exception to throw if the invocation is illegal because of
         the state of the receiving object. For example, this would be the exception to throw
         if the caller attempted to use some object before it had been properly initialized.
      </p>
      
      <p class="indent">Arguably, every erroneous method invocation boils down to an illegal argument or state,
         but other exceptions are standardly used for certain kinds of illegal arguments and
         states. If a caller passes <code class="calibre12">null</code> in some parameter for which null values are prohibited, convention dictates that
         <code class="calibre12">NullPointerException</code> be thrown rather than <code class="calibre12">IllegalArgumentException</code>. Similarly, if a caller passes an out-of-range value in a parameter representing
         an index into a sequence, <code class="calibre12">IndexOutOfBoundsException</code> should be thrown rather than <code class="calibre12">IllegalArgumentException</code>.
      </p>
      
      <p class="indent">Another reusable exception is <code class="calibre12">ConcurrentModificationException</code>. It should be thrown if an object that was designed for use by a single thread (or
         with external synchronization) detects that it is being modified concurrently. This
         exception is at best a hint because it is impossible to reliably detect concurrent
         modification.
      </p>
      
      <p class="indent">A last standard exception of note is <code class="calibre12">UnsupportedOperationException</code>. This is the exception to throw if an object does not support an attempted operation.
         Its use is rare because most objects support all of their methods. This exception
         is used by classes that fail to implement one or more <em class="calibre9">optional operations</em> defined by an interface they implement. For example, an append-only <code class="calibre12">List</code> implementation would throw this exception if someone tried to delete an element from
         the list.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_301"></span><strong class="calibre11">Do</strong> <em class="calibre9"><strong class="calibre11">not</strong></em> <strong class="calibre11">reuse</strong> <code class="calibre12"><strong class="calibre11">Exception</strong></code><strong class="calibre11">,</strong> <code class="calibre12"><strong class="calibre11">RuntimeException</strong></code><strong class="calibre11">,</strong> <code class="calibre12"><strong class="calibre11">Throwable</strong></code><strong class="calibre11">, or</strong> <code class="calibre12"><strong class="calibre11">Error</strong></code> <strong class="calibre11">directly.</strong> Treat these classes as if they were abstract. You can't reliably test for these exceptions
         because they are superclasses of other exceptions that a method may throw.
      </p>
      
      <p class="indentb">This table summarizes the most commonly reused exceptions:</p>
      
      <table class="tablewidth">
         
         <tbody class="calibre16">
            
            <tr class="calibre17">
               
               <td class="table">
                  <p class="noindent-t"><strong class="calibre11">Exception</strong></p>
               </td>
               
               <td class="table">
                  <p class="noindent-t"><strong class="calibre11">Occasion for Use</strong></p>
               </td>
               
            </tr>
            
            <tr class="calibre17">
               
               <td class="calibre18">
                  <p class="noindent1"><code class="calibre12">IllegalArgumentException</code></p>
               </td>
               
               <td class="calibre18">
                  <p class="noindent1">Non-null parameter value is inappropriate</p>
               </td>
               
            </tr>
            
            <tr class="calibre17">
               
               <td class="calibre18">
                  <p class="noindent1"><code class="calibre12">IllegalStateException</code></p>
               </td>
               
               <td class="calibre18">
                  <p class="noindent1">Object state is inappropriate for method invocation</p>
               </td>
               
            </tr>
            
            <tr class="calibre17">
               
               <td class="calibre18">
                  <p class="noindent1"><code class="calibre12">NullPointerException</code></p>
               </td>
               
               <td class="calibre18">
                  <p class="noindent1">Parameter value is null where prohibited</p>
               </td>
               
            </tr>
            
            <tr class="calibre17">
               
               <td class="calibre18">
                  <p class="noindent1"><code class="calibre12">IndexOutOfBoundsException</code></p>
               </td>
               
               <td class="calibre18">
                  <p class="noindent1">Index parameter value is out of range</p>
               </td>
               
            </tr>
            
            <tr class="calibre17">
               
               <td class="calibre18">
                  <p class="noindent1"><code class="calibre12">ConcurrentModificationException</code></p>
               </td>
               
               <td class="calibre18">
                  <p class="noindent1">Concurrent modification of an object has been detected where it is prohibited</p>
               </td>
               
            </tr>
            
            <tr class="calibre17">
               
               <td class="table1">
                  <p class="noindent1"><code class="calibre12">UnsupportedOperationException</code></p>
               </td>
               
               <td class="table1">
                  <p class="noindent1">Object does not support method</p>
               </td>
               
            </tr>
            
         </tbody>
         
      </table>
      
      <p class="indentt">While these are by far the most commonly reused exceptions, others may be reused where
         circumstances warrant. For example, it would be appropriate to reuse <code class="calibre12">ArithmeticException</code> and <code class="calibre12">NumberFormatException</code> if you were implementing arithmetic objects such as complex numbers or rational numbers.
         If an exception fits your needs, go ahead and use it, but only if the conditions under
         which you would throw it are consistent with the exception’s documentation: reuse
         must be based on documented semantics, not just on name. Also, feel free to subclass
         a standard exception if you want to add more detail (<a href="ch10.xhtml#lev75" class="calibre8">Item 75</a>), but remember that exceptions are serializable (<a href="ch12.xhtml#ch12" class="calibre8">Chapter 12</a>). That alone is reason not to write your own exception class without good reason.
      </p>
      
      <p class="indent">Choosing which exception to reuse can be tricky because the “occasions for use” in
         the table above do not appear to be mutually exclusive. Consider the case of an object
         representing a deck of cards, and suppose there were a method to deal a hand from
         the deck that took as an argument the size of the hand. If the caller passed a value
         larger than the number of cards remaining in the deck, it could be construed as an
         <code class="calibre12">IllegalArgumentException</code> (the <code class="calibre12">handSize</code> parameter value is too high) or an <code class="calibre12">IllegalStateException</code> (the deck contains too few cards). Under these circumstances, the rule is to <strong class="calibre11">throw</strong> <code class="calibre12"><strong class="calibre11">IllegalStateException</strong></code> <strong class="calibre11">if no argument values would have worked, otherwise throw</strong> <code class="calibre12"><strong class="calibre11">IllegalArgumentException</strong></code><strong class="calibre11">.</strong></p>
      
      <h3 class="h2"><a id="lev73" class="calibre4"></a><span epub:type="pagebreak" id="page_302" class="calibre15"></span><strong class="calibre10">Item 73: Throw exceptions appropriate to the abstraction</strong></h3>
      
      <p class="noindent">It is disconcerting when a method throws an exception that has no apparent connection
         to the task that it performs. This often happens when a method propagates an exception
         thrown by a lower-level abstraction. Not only is it disconcerting, but it pollutes
         the API of the higher layer with implementation details. If the implementation of
         the higher layer changes in a later release, the exceptions it throws will change
         too, potentially breaking existing client programs.
      </p>
      
      <p class="indent">To avoid this problem, <strong class="calibre11">higher layers should catch lower-level exceptions and, in their place, throw exceptions
            that can be explained in terms of the higher-level abstraction.</strong> This idiom is known as <em class="calibre9">exception translation</em>:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex9a" id="pch10ex9" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Exception Translation</strong><br class="calibre7"/>
         try {<br class="calibre7"/>
             ... // Use lower-level abstraction to do our bidding<br class="calibre7"/>
         } catch (LowerLevelException e) {<br class="calibre7"/>
             throw new HigherLevelException(...);<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Here is an example of exception translation taken from the <code class="calibre12">AbstractSequentialList</code> class, which is a <em class="calibre9">skeletal implementation</em> (<a href="ch4.xhtml#lev20" class="calibre8">Item 20</a>) of the <code class="calibre12">List</code> interface. In this example, exception translation is mandated by the specification
         of the <code class="calibre12">get</code> method in the <code class="calibre12">List&lt;E&gt;</code> interface:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex10a" id="pch10ex10" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">/**<br class="calibre7"/>
          * Returns the element at the specified position in this list.<br class="calibre7"/>
          * @throws IndexOutOfBoundsException if the index is out of range<br class="calibre7"/>
          *         ({@code index &lt;  0 || index &gt;= size()}).<br class="calibre7"/>
          */<br class="calibre7"/>
         public E get(int index) {<br class="calibre7"/>
             ListIterator&lt;E&gt; i = listIterator(index);<br class="calibre7"/>
             try {<br class="calibre7"/>
                 return i.next();<br class="calibre7"/>
             } catch (NoSuchElementException e) {<br class="calibre7"/>
                 throw new IndexOutOfBoundsException("Index: " + index);<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">A special form of exception translation called <em class="calibre9">exception chaining</em> is called for in cases where the lower-level exception might be helpful to someone
         debugging the problem that caused the higher-level exception. The lower-level exception
         (the <span epub:type="pagebreak" id="page_303"></span><em class="calibre9">cause</em>) is passed to the higher-level exception, which provides an accessor method (<code class="calibre12">Throwable</code>’s <code class="calibre12">getCause</code> method) to retrieve the lower-level exception:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex11a" id="pch10ex11" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Exception Chaining</strong><br class="calibre7"/>
         try {<br class="calibre7"/>
             ... // Use lower-level abstraction to do our bidding<br class="calibre7"/>
         } catch (LowerLevelException cause) {<br class="calibre7"/>
             throw new HigherLevelException(<strong class="calibre11">cause</strong>);<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">The higher-level exception’s constructor passes the cause to a <em class="calibre9">chaining-aware</em> superclass constructor, so it is ultimately passed to one of <code class="calibre12">Throwable</code>’s chaining-aware constructors, such as <code class="calibre12">Throwable(Throwable)</code>:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex12a" id="pch10ex12" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Exception with chaining-aware constructor</strong><br class="calibre7"/>
         class HigherLevelException extends Exception {<br class="calibre7"/>
             HigherLevelException(Throwable cause) {<br class="calibre7"/>
                 super(cause);<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Most standard exceptions have chaining-aware constructors. For exceptions that don’t,
         you can set the cause using <code class="calibre12">Throwable</code>’s <code class="calibre12">initCause</code> method. Not only does exception chaining let you access the cause programmatically
         (with <code class="calibre12">getCause</code>), but it integrates the cause’s stack trace into that of the higher-level exception.
      </p>
      
      <p class="indent"><strong class="calibre11">While exception translation is superior to mindless propagation of exceptions from
            lower layers, it should not be overused.</strong> Where possible, the best way to deal with exceptions from lower layers is to avoid
         them, by ensuring that lower-level methods succeed. Sometimes you can do this by checking
         the validity of the higher-level method’s parameters before passing them on to lower
         layers.
      </p>
      
      <p class="indent">If it is impossible to prevent exceptions from lower layers, the next best thing is
         to have the higher layer silently work around these exceptions, insulating the caller
         of the higher-level method from lower-level problems. Under these circumstances, it
         may be appropriate to log the exception using some appropriate logging facility such
         as <code class="calibre12">java.util.logging</code>. This allows programmers to investigate the problem, while insulating client code
         and the users from it.
      </p>
      
      <p class="indent">In summary, if it isn’t feasible to prevent or to handle exceptions from lower layers,
         use exception translation, unless the lower-level method happens to guarantee that
         all of its exceptions are appropriate to the higher level. Chaining provides the best
         of both worlds: it allows you to throw an appropriate higher-level exception, while
         capturing the underlying cause for failure analysis (<a href="ch10.xhtml#lev75" class="calibre8">Item 75</a>).
      </p>
      
      <h3 class="h2"><a id="lev74" class="calibre4"></a><span epub:type="pagebreak" id="page_304" class="calibre15"></span><strong class="calibre10">Item 74: Document all exceptions thrown by each method</strong></h3>
      
      <p class="noindent">A description of the exceptions thrown by a method is an important part of the documentation
         required to use the method properly. Therefore, it is critically important that you
         take the time to carefully document all of the exceptions thrown by each method (<a href="ch8.xhtml#lev56" class="calibre8">Item 56</a>).
      </p>
      
      <p class="indent"><strong class="calibre11">Always declare checked exceptions individually, and document precisely the conditions
            under which each one is thrown</strong> using the Javadoc <code class="calibre12">@throws</code> tag. Don’t take the shortcut of declaring that a method throws some superclass of
         multiple exception classes that it can throw. As an extreme example, don’t declare
         that a public method <code class="calibre12">throws Exception</code> or, worse, <code class="calibre12">throws Throwable</code>. In addition to denying any guidance to the method’s user concerning the exceptions
         it is capable of throwing, such a declaration greatly hinders the use of the method
         because it effectively obscures any other exception that may be thrown in the same
         context. One exception to this advice is the <code class="calibre12">main</code> method, which can safely be declared to throw <code class="calibre12">Exception</code> because it is called only by VM.
      </p>
      
      <p class="indent">While the language does not require programmers to declare the unchecked exceptions
         that a method is capable of throwing, it is wise to document them as carefully as
         the checked exceptions. Unchecked exceptions generally represent programming errors
         (<a href="ch10.xhtml#lev70" class="calibre8">Item 70</a>), and familiarizing programmers with all of the errors they can make helps them avoid
         making these errors. A well-documented list of the unchecked exceptions that a method
         can throw effectively describes the <em class="calibre9">preconditions</em> for its successful execution. It is essential that every public method’s documentation
         describe its preconditions (<a href="ch8.xhtml#lev56" class="calibre8">Item 56</a>), and documenting its unchecked exceptions is the best way to satisfy this requirement.
      </p>
      
      <p class="indent">It is particularly important that methods in interfaces document the unchecked exceptions
         they may throw. This documentation forms a part of the interface’s <em class="calibre9">general contract</em> and enables common behavior among multiple implementations of the interface.
      </p>
      
      <p class="indent"><strong class="calibre11">Use the Javadoc</strong> <code class="calibre12"><strong class="calibre11">@throws</strong></code> <strong class="calibre11">tag to document each exception that a method can throw, but do</strong> <em class="calibre9"><strong class="calibre11">not</strong></em> <strong class="calibre11">use the</strong> <code class="calibre12"><strong class="calibre11">throws</strong></code> <strong class="calibre11">keyword on unchecked exceptions.</strong> It is important that programmers using your API are aware of which exceptions are
         checked and which are unchecked because the programmers’ responsibilities differ in
         these two cases. The documentation generated by the Javadoc <code class="calibre12">@throws</code> tag without a corresponding throws clause in the method declaration provides a strong
         visual cue to the programmer that an exception is unchecked.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_305"></span>It should be noted that documenting all of the unchecked exceptions that each method
         can throw is an ideal, not always achievable in the real world. When a class undergoes
         revision, it is not a violation of source or binary compatibility if an exported method
         is modified to throw additional unchecked exceptions. Suppose a class invokes a method
         from another, independently written class. The authors of the former class may carefully
         document all of the unchecked exceptions that each method throws, but if the latter
         class is revised to throw additional unchecked exceptions, it is quite likely that
         the former class (which has not undergone revision) will propagate the new unchecked
         exceptions even though it does not document them.
      </p>
      
      <p class="indent"><strong class="calibre11">If an exception is thrown by many methods in a class for the same reason, you can
            document the exception in the class’s documentation comment</strong> rather than documenting it individually for each method. A common example is <code class="calibre12">NullPointerException</code>. It is fine for a class’s documentation comment to say, “All methods in this class
         throw a <code class="calibre12">NullPointerException</code> if a null object reference is passed in any parameter,” or words to that effect.
      </p>
      
      <p class="indent">In summary, document every exception that can be thrown by each method that you write.
         This is true for unchecked as well as checked exceptions, and for abstract as well
         as concrete methods. This documentation should take the form of <code class="calibre12">@throws</code> tags in doc comments. Declare each checked exception individually in a method’s <code class="calibre12">throws</code> clause, but do not declare unchecked exceptions. If you fail to document the exceptions
         that your methods can throw, it will be difficult or impossible for others to make
         effective use of your classes and interfaces.
      </p>
      
      <h3 class="h2"><a id="lev75" class="calibre4"></a><span epub:type="pagebreak" id="page_306" class="calibre15"></span><strong class="calibre10">Item 75: Include failure-capture information in detail messages</strong></h3>
      
      <p class="noindent">When a program fails due to an uncaught exception, the system automatically prints
         out the exception’s stack trace. The stack trace contains the exception’s <em class="calibre9">string representation</em>, the result of invoking its <code class="calibre12">toString</code> method. This typically consists of the exception’s class name followed by its <em class="calibre9">detail message</em>. Frequently this is the only information that programmers or site reliability engineers
         will have when investigating a software failure. If the failure is not easily reproducible,
         it may be difficult or impossible to get any more information. Therefore, it is critically
         important that the exception’s <code class="calibre12">toString</code> method return as much information as possible concerning the cause of the failure.
         In other words, the detail message of an exception should <em class="calibre9">capture the failure</em> for subsequent analysis.
      </p>
      
      <p class="indent"><strong class="calibre11">To capture a failure, the detail message of an exception should contain the values
            of all parameters and fields that contributed to the exception.</strong> For example, the detail message of an <code class="calibre12">IndexOutOfBoundsException</code> should contain the lower bound, the upper bound, and the index value that failed
         to lie between the bounds. This information tells a lot about the failure. Any or
         all of the three values could be wrong. The index could be one less than the lower
         bound or equal to the upper bound (a “fencepost error”), or it could be a wild value,
         far too low or high. The lower bound could be greater than the upper bound (a serious
         internal invariant failure). Each of these situations points to a different problem,
         and it greatly aids in the diagnosis if you know what sort of error you’re looking
         for.
      </p>
      
      <p class="indent">One caveat concerns security-sensitive information. Because stack traces may be seen
         by many people in the process of diagnosing and fixing software issues, <strong class="calibre11">do not include passwords, encryption keys, and the like in detail messages.</strong></p>
      
      <p class="indent">While it is critical to include all of the pertinent data in the detail message of
         an exception, it is generally unimportant to include a lot of prose. The stack trace
         is intended to be analyzed in conjunction with the documentation and, if necessary,
         source code. It generally contains the exact file and line number from which the exception
         was thrown, as well as the files and line numbers of all other method invocations
         on the stack. Lengthy prose descriptions of the failure are superfluous; the information
         can be gleaned by reading the documentation and source code.
      </p>
      
      <p class="indent">The detail message of an exception should not be confused with a user-level error
         message, which must be intelligible to end users. Unlike a user-level error message,
         the detail message is primarily for the benefit of programmers or site reliability
         engineers, when analyzing a failure. Therefore, information content is far more important
         than readability. User-level error messages are often <em class="calibre9">localized</em>, whereas exception detail messages rarely are.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_307"></span>One way to ensure that exceptions contain adequate failure-capture information in
         their detail messages is to require this information in their constructors instead
         of a string detail message. The detail message can then be generated automatically
         to include the information. For example, instead of a <code class="calibre12">String</code> constructor, <code class="calibre12">IndexOutOfBoundsException</code> could have had a constructor that looks like this:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex13a" id="pch10ex13" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">/**<br class="calibre7"/>
          * Constructs an IndexOutOfBoundsException.<br class="calibre7"/>
          *<br class="calibre7"/>
          * @param lowerBound the lowest legal index value<br class="calibre7"/>
          * @param upperBound the highest legal index value plus one<br class="calibre7"/>
          * @param index      the actual index value<br class="calibre7"/>
          */<br class="calibre7"/>
         public IndexOutOfBoundsException(int lowerBound, int upperBound,<br class="calibre7"/>
                                          int index) {<br class="calibre7"/>
             <strong class="calibre11">// Generate a detail message that captures the failure</strong><br class="calibre7"/>
             super(String.format(<br class="calibre7"/>
                     "Lower bound: %d, Upper bound: %d, Index: %d",<br class="calibre7"/>
                     lowerBound, upperBound, index));<br class="calibre7"/>
         <br class="calibre7"/>
             // Save failure information for programmatic access<br class="calibre7"/>
             this.lowerBound = lowerBound;<br class="calibre7"/>
             this.upperBound = upperBound;<br class="calibre7"/>
             this.index = index;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">As of Java 9, <code class="calibre12">IndexOutOfBoundsException</code> finally acquired a constructor that takes an <code class="calibre12">int</code> valued <code class="calibre12">index</code> parameter, but sadly it omits the <code class="calibre12">lowerBound</code> and <code class="calibre12">upperBound</code> parameters. More generally, the Java libraries don’t make heavy use of this idiom,
         but it is highly recommended. It makes it easy for the programmer throwing an exception
         to capture the failure. In fact, it makes it hard for the programmer not to capture
         the failure! In effect, the idiom centralizes the code to generate a high-quality
         detail message in the exception class, rather than requiring each user of the class
         to generate the detail message redundantly.
      </p>
      
      <p class="indent">As suggested in <a href="ch10.xhtml#lev70" class="calibre8">Item 70</a>, it may be appropriate for an exception to provide accessor methods for its failure-capture
         information (<code class="calibre12">lowerBound</code>, <code class="calibre12">upperBound</code>, and <code class="calibre12">index</code> in the above example). It is more important to provide such accessor methods on checked
         exceptions than unchecked, because the failure-capture information could be useful
         in recovering from the failure. It is rare (although not inconceivable) that a programmer
         might want programmatic access to the details of an unchecked exception. Even for
         unchecked exceptions, however, it seems advisable to provide these accessors on general
         principle (<a href="ch3.xhtml#lev12" class="calibre8">Item 12</a>, page 57).
      </p>
      
      <h3 class="h2"><a id="lev76" class="calibre4"></a><span epub:type="pagebreak" id="page_308" class="calibre15"></span><strong class="calibre10">Item 76: Strive for failure atomicity</strong></h3>
      
      <p class="noindent">After an object throws an exception, it is generally desirable that the object still
         be in a well-defined, usable state, even if the failure occurred in the midst of performing
         an operation. This is especially true for checked exceptions, from which the caller
         is expected to recover. <strong class="calibre11">Generally speaking, a failed method invocation should leave the object in the state
            that it was in prior to the invocation</strong>. A method with this property is said to be <em class="calibre9">failure-atomic.</em></p>
      
      <p class="indent">There are several ways to achieve this effect. The simplest is to design immutable
         objects (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>). If an object is immutable, failure atomicity is free. If an operation fails, it
         may prevent a new object from getting created, but it will never leave an existing
         object in an inconsistent state, because the state of each object is consistent when
         it is created and can’t be modified thereafter.
      </p>
      
      <p class="indent">For methods that operate on mutable objects, the most common way to achieve failure
         atomicity is to check parameters for validity before performing the operation (<a href="ch8.xhtml#lev49" class="calibre8">Item 49</a>). This causes most exceptions to get thrown before object modification commences.
         For example, consider the <code class="calibre12">Stack.pop</code> method in <a href="ch2.xhtml#lev7" class="calibre8">Item 7</a>:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex14a" id="pch10ex14" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public Object pop() {<br class="calibre7"/>
             <strong class="calibre11">if (size == 0)</strong><br class="calibre7"/>
                 <strong class="calibre11">throw new EmptyStackException();</strong><br class="calibre7"/>
             Object result = elements[--size];<br class="calibre7"/>
             elements[size] = null; // Eliminate obsolete reference<br class="calibre7"/>
             return result;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">If the initial size check were eliminated, the method would still throw an exception
         when it attempted to pop an element from an empty stack. It would, however, leave
         the size field in an inconsistent (negative) state, causing any future method invocations
         on the object to fail. Additionally, the <code class="calibre12">ArrayIndexOutOfBoundsException</code> thrown by the <code class="calibre12">pop</code> method would be inappropriate to the abstraction (<a href="ch10.xhtml#lev73" class="calibre8">Item 73</a>).
      </p>
      
      <p class="indent">A closely related approach to achieving failure atomicity is to order the computation
         so that any part that may fail takes place before any part that modifies the object.
         This approach is a natural extension of the previous one when arguments cannot be
         checked without performing a part of the computation. For example, consider the case
         of <code class="calibre12">TreeMap</code>, whose elements are sorted according to some ordering. In order to add an element
         to a <code class="calibre12">TreeMap</code>, the element must be of a type that can be compared using the <code class="calibre12">TreeMap</code>’s ordering. Attempting to add an incorrectly <span epub:type="pagebreak" id="page_309"></span>typed element will naturally fail with a <code class="calibre12">ClassCastException</code> as a result of searching for the element in the tree, before the tree has been modified
         in any way.
      </p>
      
      <p class="indent">A third approach to achieving failure atomicity is to perform the operation on a temporary
         copy of the object and to replace the contents of the object with the temporary copy
         once the operation is complete. This approach occurs naturally when the computation
         can be performed more quickly once the data has been stored in a temporary data structure.
         For example, some sorting functions copy their input list into an array prior to sorting
         to reduce the cost of accessing elements in the inner loop of the sort. This is done
         for performance, but as an added benefit, it ensures that the input list will be untouched
         if the sort fails.
      </p>
      
      <p class="indent">A last and far less common approach to achieving failure atomicity is to write <em class="calibre9">recovery code</em> that intercepts a failure that occurs in the midst of an operation, and causes the
         object to roll back its state to the point before the operation began. This approach
         is used mainly for durable (disk-based) data structures.
      </p>
      
      <p class="indent">While failure atomicity is generally desirable, it is not always achievable. For example,
         if two threads attempt to modify the same object concurrently without proper synchronization,
         the object may be left in an inconsistent state. It would therefore be wrong to assume
         that an object was still usable after catching a <code class="calibre12">ConcurrentModificationException</code>. Errors are unrecoverable, so you need not even attempt to preserve failure atomicity
         when throwing <code class="calibre12">AssertionError</code>.
      </p>
      
      <p class="indent">Even where failure atomicity is possible, it is not always desirable. For some operations,
         it would significantly increase the cost or complexity. That said, it is often both
         free and easy to achieve failure atomicity once you’re aware of the issue.
      </p>
      
      <p class="indent">In summary, as a rule, any generated exception that is part of a method’s specification
         should leave the object in the same state it was in prior to the method invocation.
         Where this rule is violated, the API documentation should clearly indicate what state
         the object will be left in. Unfortunately, plenty of existing API documentation fails
         to live up to this ideal.
      </p>
      
      <h3 class="h2"><a id="lev77" class="calibre4"></a><span epub:type="pagebreak" id="page_310" class="calibre15"></span><strong class="calibre10">Item 77: Don’t ignore exceptions</strong></h3>
      
      <p class="noindent">While this advice may seem obvious, it is violated often enough that it bears repeating.
         When the designers of an API declare a method to throw an exception, they are trying
         to tell you something. Don’t ignore it! It is easy to ignore exceptions by surrounding
         a method invocation with a <code class="calibre12">try</code> statement whose <code class="calibre12">catch</code> block is empty:
      </p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex15a" id="pch10ex15" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Empty catch block ignores exception - Highly suspect!</strong><br class="calibre7"/>
         try {<br class="calibre7"/>
             ...<br class="calibre7"/>
         } catch (SomeException e) {<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><strong class="calibre11">An empty</strong> <code class="calibre12"><strong class="calibre11">catch</strong></code> <strong class="calibre11">block defeats the purpose of exceptions,</strong> which is to force you to handle exceptional conditions. Ignoring an exception is
         analogous to ignoring a fire alarm—and turning it off so no one else gets a chance
         to see if there’s a real fire. You may get away with it, or the results may be disastrous.
         Whenever you see an empty <code class="calibre12">catch</code> block, alarm bells should go off in your head.
      </p>
      
      <p class="indent">There are situations where it is appropriate to ignore an exception. For example,
         it might be appropriate when closing a <code class="calibre12">FileInputStream</code>. You haven’t changed the state of the file, so there’s no need to perform any recovery
         action, and you’ve already read the information that you need from the file, so there’s
         no reason to abort the operation in progress. It may be wise to log the exception,
         so that you can investigate the matter if these exceptions happen often. <strong class="calibre11">If you choose to ignore an exception, the</strong> <code class="calibre12"><strong class="calibre11">catch</strong></code> <strong class="calibre11">block should contain a comment explaining why it is appropriate to do so, and the
            variable should be named</strong> <code class="calibre12"><strong class="calibre11">ignored:</strong></code></p>
      
      <p class="codelink"><a href="ch10_images.xhtml#pch10ex16a" id="pch10ex16" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Future&lt;Integer&gt; f = exec.submit(planarMap::chromaticNumber);<br class="calibre7"/>
         int numColors = 4; // Default; guaranteed sufficient for any map<br class="calibre7"/>
         try {<br class="calibre7"/>
             numColors = f.get(1L, TimeUnit.SECONDS);<br class="calibre7"/>
         } catch (TimeoutException | ExecutionException <strong class="calibre11">ignored</strong>) {<br class="calibre7"/>
             <strong class="calibre11">// Use default: minimal coloring is desirable, not required</strong><br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The advice in this item applies equally to checked and unchecked exceptions. Whether
         an exception represents a predictable exceptional condition or a programming error,
         ignoring it with an empty <code class="calibre12">catch</code> block will result in a program that continues silently in the face of error. The
         program might then fail at an arbitrary time in the future, at a point in the code
         that bears no apparent relation to the source of the problem. Properly handling an
         exception can avert failure entirely. Merely letting an exception propagate outward
         can at least cause the program to fail swiftly, preserving information to aid in debugging
         the failure.
      </p>
      
   
   


  </div>

  
  <div class="calibreToc">
    <h2><a href="../../../4bgup-l038f.html">Table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="cover.xhtml">Cover Page</a>
    </li>
    <li>
      <a href="pref00.xhtml">About This E-Book</a>
    </li>
    <li>
      <a href="title.xhtml">Title Page</a>
    </li>
    <li>
      <a href="copy.xhtml">Copyright Page</a>
    </li>
    <li>
      <a href="ded.xhtml">Dedication</a>
    </li>
    <li>
      <a href="contents.xhtml">Contents</a>
    </li>
    <li>
      <a href="foreword.xhtml#foreword">Foreword</a>
    </li>
    <li>
      <a href="preface.xhtml#preface">Preface</a>
    </li>
    <li>
      <a href="acknowledgments.xhtml#acknowledgments">Acknowledgments</a>
    </li>
    <li>
      <a href="ch1.xhtml#ch1">1 Introduction</a>
    </li>
    <li>
      <a href="ch2.xhtml#ch2">2 Creating and Destroying Objects</a>
      <ul>
        <li>
          <a href="ch2.xhtml#lev1">Item 1: Consider static factory methods instead of constructors</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev2">Item 2: Consider a builder when faced with many constructor parameters</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev3">Item 3: Enforce the singleton property with a private constructor or an enum type</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev4">Item 4: Enforce noninstantiability with a private constructor</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev5">Item 5: Prefer dependency injection to hardwiring resources</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev6">Item 6: Avoid creating unnecessary objects</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev7">Item 7: Eliminate obsolete object references</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev8">Item 8: Avoid finalizers and cleaners</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev9">Item 9: Prefer try-with-resources to try-finally</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch3.xhtml#ch3">3 Methods Common to All Objects</a>
      <ul>
        <li>
          <a href="ch3.xhtml#lev10">Item 10: Obey the general contract when overriding equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev11">Item 11: Always override hashCode when you override equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev12">Item 12: Always override toString</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev13">Item 13: Override clone judiciously</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev14">Item 14: Consider implementing Comparable</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch4.xhtml#ch4">4 Classes and Interfaces</a>
      <ul>
        <li>
          <a href="ch4.xhtml#lev15">Item 15: Minimize the accessibility of classes and members</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev16">Item 16: In public classes, use accessor methods, not public fields</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev17">Item 17: Minimize mutability</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev18">Item 18: Favor composition over inheritance</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev19">Item 19: Design and document for inheritance or else prohibit it</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev20">Item 20: Prefer interfaces to abstract classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev21">Item 21: Design interfaces for posterity</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev22">Item 22: Use interfaces only to define types</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev23">Item 23: Prefer class hierarchies to tagged classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev24">Item 24: Favor static member classes over nonstatic</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev25">Item 25: Limit source files to a single top-level class</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch5.xhtml#ch5">5 Generics</a>
      <ul>
        <li>
          <a href="ch5.xhtml#lev26">Item 26: Don’t use raw types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev27">Item 27: Eliminate unchecked warnings</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev28">Item 28: Prefer lists to arrays</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev29">Item 29: Favor generic types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev30">Item 30: Favor generic methods</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev31">Item 31: Use bounded wildcards to increase API flexibility</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev32">Item 32: Combine generics and varargs judiciously</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev33">Item 33: Consider typesafe heterogeneous containers</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch6.xhtml#ch6">6 Enums and Annotations</a>
      <ul>
        <li>
          <a href="ch6.xhtml#lev34">Item 34: Use enums instead of int constants</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev35">Item 35: Use instance fields instead of ordinals</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev36">Item 36: Use EnumSet instead of bit fields</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev37">Item 37: Use EnumMap instead of ordinal indexing</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev38">Item 38: Emulate extensible enums with interfaces</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev39">Item 39: Prefer annotations to naming patterns</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev40">Item 40: Consistently use the Override annotation</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev41">Item 41: Use marker interfaces to define types</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch7.xhtml#ch7">7 Lambdas and Streams</a>
      <ul>
        <li>
          <a href="ch7.xhtml#lev42">Item 42: Prefer lambdas to anonymous classes</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev43">Item 43: Prefer method references to lambdas</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev44">Item 44: Favor the use of standard functional interfaces</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev45">Item 45: Use streams judiciously</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev46">Item 46: Prefer side-effect-free functions in streams</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev47">Item 47: Prefer Collection to Stream as a return type</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev48">Item 48: Use caution when making streams parallel</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch8.xhtml#ch8">8 Methods</a>
      <ul>
        <li>
          <a href="ch8.xhtml#lev49">Item 49: Check parameters for validity</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev50">Item 50: Make defensive copies when needed</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev51">Item 51: Design method signatures carefully</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev52">Item 52: Use overloading judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev53">Item 53: Use varargs judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev54">Item 54: Return empty collections or arrays, not nulls</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev55">Item 55: Return optionals judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev56">Item 56: Write doc comments for all exposed API elements</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch9.xhtml#ch9">9 General Programming</a>
      <ul>
        <li>
          <a href="ch9.xhtml#lev57">Item 57: Minimize the scope of local variables</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev58">Item 58: Prefer for-each loops to traditional for loops</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev59">Item 59: Know and use the libraries</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev60">Item 60: Avoid float and double if exact answers are required</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev61">Item 61: Prefer primitive types to boxed primitives</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev62">Item 62: Avoid strings where other types are more appropriate</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev63">Item 63: Beware the performance of string concatenation</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev64">Item 64: Refer to objects by their interfaces</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev65">Item 65: Prefer interfaces to reflection</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev66">Item 66: Use native methods judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev67">Item 67: Optimize judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev68">Item 68: Adhere to generally accepted naming conventions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch10.xhtml#ch10">10 Exceptions</a>
      <ul>
        <li>
          <a href="ch10.xhtml#lev69">Item 69: Use exceptions only for exceptional conditions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev70">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev71">Item 71: Avoid unnecessary use of checked exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev72">Item 72: Favor the use of standard exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev73">Item 73: Throw exceptions appropriate to the abstraction</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev74">Item 74: Document all exceptions thrown by each method</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev75">Item 75: Include failure-capture information in detail messages</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev76">Item 76: Strive for failure atomicity</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev77">Item 77: Don’t ignore exceptions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch11.xhtml#ch11">11 Concurrency</a>
      <ul>
        <li>
          <a href="ch11.xhtml#lev78">Item 78: Synchronize access to shared mutable data</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev79">Item 79: Avoid excessive synchronization</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev80">Item 80: Prefer executors, tasks, and streams to threads</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev81">Item 81: Prefer concurrency utilities to wait and notify</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev82">Item 82: Document thread safety</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev83">Item 83: Use lazy initialization judiciously</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev84">Item 84: Don’t depend on the thread scheduler</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch12.xhtml#ch12">12 Serialization</a>
      <ul>
        <li>
          <a href="ch12.xhtml#lev85">Item 85: Prefer alternatives to Java serialization</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev86">Item 86: Implement Serializable with great caution</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev87">Item 87: Consider using a custom serialized form</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev88">Item 88: Write readObject methods defensively</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev89">Item 89: For instance control, prefer enum types to readResolve</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev90">Item 90: Consider serialization proxies instead of serialized instances</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="app.xhtml#app">Items Corresponding to Second Edition</a>
    </li>
    <li>
      <a href="ref.xhtml#ref">References</a>
    </li>
    <li>
      <a href="index.xhtml#index">Index</a>
    </li>
    <li>
      <a href="ch2_images.xhtml#ch2_images">Code Snippets</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="ch9.xhtml" class="calibreAPrev">previous page
</a>
    

    <a href="../../../4bgup-l038f.html" class="calibreAHome">start
</a>

    
      <a href="ch11.xhtml" class="calibreANext">next page
</a>
    
  </div>

</div>

</body>
</html>
