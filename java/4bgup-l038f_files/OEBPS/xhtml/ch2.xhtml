<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>

    <title>Chapter 2 Creating and Destroying Objects</title>
    <meta content="urn:uuid:232c2138-be82-42d4-8a6b-b460372314a4" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../../4bgup-l038f.html">Effective Java, Third Edition
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    Joshua Bloch

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="ch1.xhtml" class="calibreAPrev">previous page
</a>
        

        
          <a href="ch3.xhtml" class="calibreANext">next page
</a>
        
      </div>
    

    
      
      <h2 class="h1" id="ch2"><span epub:type="pagebreak" id="page_5" class="calibre15"></span>Chapter 2. Creating and Destroying Objects
      </h2>
      
      <p class="noindent"><strong class="calibre11">T</strong><small class="calibre13">HIS</small> chapter concerns creating and destroying objects: when and how to create them, when
         and how to avoid creating them, how to ensure they are destroyed in a timely manner,
         and how to manage any cleanup actions that must precede their destruction.
      </p>
      
      <h3 class="h3b"><a id="lev1" class="calibre4"></a><strong class="calibre10">Item 1: Consider static factory methods instead of constructors</strong></h3>
      
      <p class="noindent">The traditional way for a class to allow a client to obtain an instance is to provide
         a public constructor. There is another technique that should be a part of every programmer’s
         toolkit. A class can provide a public <em class="calibre9">static factory method</em>, which is simply a static method that returns an instance of the class. Here’s a
         simple example from <code class="calibre12">Boolean</code> (the <em class="calibre9">boxed primitive</em> class for <code class="calibre12">boolean</code>). This method translates a <code class="calibre12">boolean</code> primitive value into a <code class="calibre12">Boolean</code> object reference:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex1a" id="pch2ex1" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public static Boolean valueOf(boolean b) {<br class="calibre7"/>
             return b ? Boolean.TRUE : Boolean.FALSE;<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Note that a static factory method is not the same as the <em class="calibre9">Factory Method</em> pattern from <em class="calibre9">Design Patterns</em> [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. The static factory method described in this item has no direct equivalent in <em class="calibre9">Design Patterns</em>.
      </p>
      
      <p class="indent">A class can provide its clients with static factory methods instead of, or in addition
         to, public constructors. Providing a static factory method instead of a public constructor
         has both advantages and disadvantages.
      </p>
      
      <p class="indent"><strong class="calibre11">One advantage of static factory methods is that, unlike constructors, they have names.</strong> If the parameters to a constructor do not, in and of themselves, describe the object
         being returned, a static factory with a well-chosen name is easier to use and the
         resulting client code easier to read. For example, the <span epub:type="pagebreak" id="page_6"></span>constructor <code class="calibre12">BigInteger(int, int, Random)</code>, which returns a <code class="calibre12">BigInteger</code> that is probably prime, would have been better expressed as a static factory method
         named <code class="calibre12">BigInteger.probablePrime</code>. (This method was added in Java 4.)
      </p>
      
      <p class="indent">A class can have only a single constructor with a given signature. Programmers have
         been known to get around this restriction by providing two constructors whose parameter
         lists differ only in the order of their parameter types. This is a really bad idea.
         The user of such an API will never be able to remember which constructor is which
         and will end up calling the wrong one by mistake. People reading code that uses these
         constructors will not know what the code does without referring to the class documentation.
      </p>
      
      <p class="indent">Because they have names, static factory methods don’t share the restriction discussed
         in the previous paragraph. In cases where a class seems to require multiple constructors
         with the same signature, replace the constructors with static factory methods and
         carefully chosen names to highlight their differences.
      </p>
      
      <p class="indent"><strong class="calibre11">A second advantage of static factory methods is that, unlike constructors, they are
            not required to create a new object each time they’re invoked.</strong> This allows immutable classes (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>) to use preconstructed instances, or to cache instances as they’re constructed, and
         dispense them repeatedly to avoid creating unnecessary duplicate objects. The <code class="calibre12">Boolean.valueOf(boolean)</code> method illustrates this technique: it <em class="calibre9">never</em> creates an object. This technique is similar to the <em class="calibre9">Flyweight</em> pattern [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. It can greatly improve performance if equivalent objects are requested often, especially
         if they are expensive to create.
      </p>
      
      <p class="indent">The ability of static factory methods to return the same object from repeated invocations
         allows classes to maintain strict control over what instances exist at any time. Classes
         that do this are said to be <em class="calibre9">instance-controlled.</em> There are several reasons to write instance-controlled classes. Instance control
         allows a class to guarantee that it is a singleton (<a href="ch2.xhtml#lev3" class="calibre8">Item 3</a>) or noninstantiable (<a href="ch2.xhtml#lev4" class="calibre8">Item 4</a>). Also, it allows an immutable value class (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>) to make the guarantee that no two equal instances exist: <code class="calibre12">a.equals(b)</code> if and only if <code class="calibre12">a == b</code>. This is the basis of the <em class="calibre9">Flyweight</em> pattern [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. Enum types (<a href="ch6.xhtml#lev34" class="calibre8">Item 34</a>) provide this guarantee.
      </p>
      
      <p class="indent"><strong class="calibre11">A third advantage of static factory methods is that, unlike constructors, they can
            return an object of any subtype of their return type.</strong> This gives you great flexibility in choosing the class of the returned object.
      </p>
      
      <p class="indent">One application of this flexibility is that an API can return objects without making
         their classes public. Hiding implementation classes in this fashion leads to a very
         compact API. This technique lends itself to <em class="calibre9">interface-based frameworks</em> (<a href="ch4.xhtml#lev20" class="calibre8">Item 20</a>), where interfaces provide natural return types for static factory methods.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_7"></span>Prior to Java 8, interfaces couldn’t have static methods. By convention, static factory
         methods for an interface named <code class="calibre12"><em class="calibre9">Type</em></code> were put in a <em class="calibre9">noninstantiable companion class</em> (<a href="ch2.xhtml#lev4" class="calibre8">Item 4</a>) named <code class="calibre12"><em class="calibre9">Types</em></code>. For example, the Java Collections Framework has forty-five utility implementations
         of its interfaces, providing unmodifiable collections, synchronized collections, and
         the like. Nearly all of these implementations are exported via static factory methods
         in one noninstantiable class (<code class="calibre12">java.util.Collections</code>). The classes of the returned objects are all nonpublic.
      </p>
      
      <p class="indent">The Collections Framework API is much smaller than it would have been had it exported
         forty-five separate public classes, one for each convenience implementation. It is
         not just the <em class="calibre9">bulk</em> of the API that is reduced but the <em class="calibre9">conceptual weight:</em> the number and difficulty of the concepts that programmers must master in order to
         use the API. The programmer knows that the returned object has precisely the API specified
         by its interface, so there is no need to read additional class documentation for the
         implementation class. Furthermore, using such a static factory method requires the
         client to refer to the returned object by interface rather than implementation class,
         which is generally good practice (<a href="ch9.xhtml#lev64" class="calibre8">Item 64</a>).
      </p>
      
      <p class="indent">As of Java 8, the restriction that interfaces cannot contain static methods was eliminated,
         so there is typically little reason to provide a noninstantiable companion class for
         an interface. Many public static members that would have been at home in such a class
         should instead be put in the interface itself. Note, however, that it may still be
         necessary to put the bulk of the implementation code behind these static methods in
         a separate package-private class. This is because Java 8 requires all static members
         of an interface to be public. Java 9 allows private static methods, but static fields
         and static member classes are still required to be public.
      </p>
      
      <p class="indent"><strong class="calibre11">A fourth advantage of static factories is that the class of the returned object can
            vary from call to call as a function of the input parameters.</strong> Any subtype of the declared return type is permissible. The class of the returned
         object can also vary from release to release.
      </p>
      
      <p class="indent">The <code class="calibre12">EnumSet</code> class (<a href="ch6.xhtml#lev36" class="calibre8">Item 36</a>) has no public constructors, only static factories. In the OpenJDK implementation,
         they return an instance of one of two subclasses, depending on the size of the underlying
         enum type: if it has sixty-four or fewer elements, as most enum types do, the static
         factories return a <code class="calibre12">RegularEnumSet</code> instance, which is backed by a single <code class="calibre12">long</code>; if the enum type has sixty-five or more elements, the factories return a <code class="calibre12">JumboEnumSet</code> instance, backed by a <code class="calibre12">long</code> array.
      </p>
      
      <p class="indent">The existence of these two implementation classes is invisible to clients. If <code class="calibre12">RegularEnumSet</code> ceased to offer performance advantages for small enum types, it could be eliminated
         from a future release with no ill effects. Similarly, a future release could add a
         third or fourth implementation of <code class="calibre12">EnumSet</code> if it proved beneficial <span epub:type="pagebreak" id="page_8"></span>for performance. Clients neither know nor care about the class of the object they
         get back from the factory; they care only that it is some subclass of <code class="calibre12">EnumSet</code>.
      </p>
      
      <p class="indent"><strong class="calibre11">A fifth advantage of static factories is that the class of the returned object need
            not exist when the class containing the method is written.</strong> Such flexible static factory methods form the basis of <em class="calibre9">service provider frameworks</em>, like the Java Database Connectivity API (JDBC). A service provider framework is
         a system in which providers implement a service, and the system makes the implementations
         available to clients, decoupling the clients from the implementations.
      </p>
      
      <p class="indent">There are three essential components in a service provider framework: a <em class="calibre9">service interface</em>, which represents an implementation; a <em class="calibre9">provider registration API</em>, which providers use to register implementations; and a <em class="calibre9">service access API</em>, which clients use to obtain instances of the service. The service access API may
         allow clients to specify criteria for choosing an implementation. In the absence of
         such criteria, the API returns an instance of a default implementation, or allows
         the client to cycle through all available implementations. The service access API
         is the flexible static factory that forms the basis of the service provider framework.
      </p>
      
      <p class="indent">An optional fourth component of a service provider framework is a <em class="calibre9">service provider interface</em>, which describes a factory object that produce instances of the service interface.
         In the absence of a service provider interface, implementations must be instantiated
         reflectively (<a href="ch9.xhtml#lev65" class="calibre8">Item 65</a>). In the case of JDBC, <code class="calibre12">Connection</code> plays the part of the service interface, <code class="calibre12">DriverManager.registerDriver</code> is the provider registration API, <code class="calibre12">DriverManager.getConnection</code> is the service access API, and <code class="calibre12">Driver</code> is the service provider interface.
      </p>
      
      <p class="indent">There are many variants of the service provider framework pattern. For example, the
         service access API can return a richer service interface to clients than the one furnished
         by providers. This is the <em class="calibre9">Bridge</em> pattern [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. Dependency injection frameworks (<a href="ch2.xhtml#lev5" class="calibre8">Item 5</a>) can be viewed as powerful service providers. Since Java 6, the platform includes
         a general-purpose service provider framework, <code class="calibre12">java.util.ServiceLoader</code>, so you needn’t, and generally shouldn’t, write your own (<a href="ch9.xhtml#lev59" class="calibre8">Item 59</a>). JDBC doesn’t use <code class="calibre12">ServiceLoader</code>, as the former predates the latter.
      </p>
      
      <p class="indent"><strong class="calibre11">The main limitation of providing only static factory methods is that classes without
            public or protected constructors cannot be subclassed.</strong> For example, it is impossible to subclass any of the convenience implementation classes
         in the Collections Framework. Arguably this can be a blessing in disguise because
         it encourages programmers to use composition instead of inheritance (<a href="ch4.xhtml#lev18" class="calibre8">Item 18</a>), and is required for immutable types (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>).
      </p>
      
      <p class="indentb"><strong class="calibre11">A second shortcoming of static factory methods is that they are hard for programmers
            to find.</strong> They do not stand out in API documentation in the way <span epub:type="pagebreak" id="page_9"></span>that constructors do, so it can be difficult to figure out how to instantiate a class
         that provides static factory methods instead of constructors. The Javadoc tool may
         someday draw attention to static factory methods. In the meantime, you can reduce
         this problem by drawing attention to static factories in class or interface documentation
         and by adhering to common naming conventions. Here are some common names for static
         factory methods. This list is far from exhaustive:
      </p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">from</strong></code>—A <em class="calibre9">type-conversion method</em> that takes a single parameter and returns a corresponding instance of this type,
         for example:
      </p>
      
      <p class="codepb">Date d = Date.from(instant);</p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">of</strong></code>—An <em class="calibre9">aggregation method</em> that takes multiple parameters and returns an instance of this type that incorporates
         them, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex2a" id="pch2ex2" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">valueOf</strong></code>—A more verbose alternative to <code class="calibre12">from</code> and <code class="calibre12">of</code>, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex3a" id="pch2ex3" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">instance</strong></code> or <code class="calibre12"><strong class="calibre11">getInstance</strong></code>—Returns an instance that is described by its parameters (if any) but cannot be said
         to have the same value, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex4a" id="pch2ex4" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">StackWalker luke = StackWalker.getInstance(options);</p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">create</strong></code> or <code class="calibre12"><strong class="calibre11">newInstance</strong></code>—Like <code class="calibre12">instance</code> or <code class="calibre12">getInstance</code>, except that the method guarantees that each call returns a new instance, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex5a" id="pch2ex5" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Object newArray = Array.newInstance(classObject, arrayLen);</p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">get</strong></code><em class="calibre9"><strong class="calibre11">Type</strong></em>—Like <code class="calibre12">getInstance</code>, but used if the factory method is in a different class. <em class="calibre9">Type</em> is the type of object returned by the factory method, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex6a" id="pch2ex6" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">FileStore fs = Files.getFileStore(path);</p>
      
      <p class="bull">• <code class="calibre12"><strong class="calibre11">new</strong></code><em class="calibre9"><strong class="calibre11">Type</strong></em>—Like <code class="calibre12">newInstance</code>, but used if the factory method is in a different class. <em class="calibre9">Type</em> is the type of object returned by the factory method, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex7a" id="pch2ex7" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">BufferedReader br = Files.newBufferedReader(path);</p>
      
      <p class="bull">• <em class="calibre9"><strong class="calibre11">type</strong></em>—A concise alternative to <code class="calibre12">get</code><em class="calibre9">Type</em> and <code class="calibre12">new</code><em class="calibre9">Type</em>, for example:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex8a" id="pch2ex8" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</p>
      
      <p class="indent">In summary, static factory methods and public constructors both have their uses, and
         it pays to understand their relative merits. Often static factories are preferable,
         so avoid the reflex to provide public constructors without first considering static
         factories.
      </p>
      
      <h3 class="h3b"><a id="lev2" class="calibre4"></a><span epub:type="pagebreak" id="page_10" class="calibre15"></span><strong class="calibre10">Item 2: Consider a builder when faced with many constructor parameters</strong></h3>
      
      <p class="noindent">Static factories and constructors share a limitation: they do not scale well to large
         numbers of optional parameters. Consider the case of a class representing the Nutrition
         Facts label that appears on packaged foods. These labels have a few required fields—serving
         size, servings per container, and calories per serving—and more than twenty optional
         fields—total fat, saturated fat, trans fat, cholesterol, sodium, and so on. Most products
         have nonzero values for only a few of these optional fields.
      </p>
      
      <p class="indent">What sort of constructors or static factories should you write for such a class? Traditionally,
         programmers have used the <em class="calibre9">telescoping constructor</em> pattern, in which you provide a constructor with only the required parameters, another
         with a single optional parameter, a third with two optional parameters, and so on,
         culminating in a constructor with all the optional parameters. Here’s how it looks
         in practice. For brevity’s sake, only four optional fields are shown:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex9a" id="pch2ex9" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Telescoping constructor pattern - does not scale well!</strong><br class="calibre7"/>
         public class NutritionFacts {<br class="calibre7"/>
             private final int servingSize;  // (mL)            required<br class="calibre7"/>
             private final int servings;     // (per container) required<br class="calibre7"/>
             private final int calories;     // (per serving)   optional<br class="calibre7"/>
             private final int fat;          // (g/serving)     optional<br class="calibre7"/>
             private final int sodium;       // (mg/serving)    optional<br class="calibre7"/>
             private final int carbohydrate; // (g/serving)     optional<br class="calibre7"/>
         <br class="calibre7"/>
             public NutritionFacts(int servingSize, int servings) {<br class="calibre7"/>
                 this(servingSize, servings, 0);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public NutritionFacts(int servingSize, int servings,<br class="calibre7"/>
                     int calories) {<br class="calibre7"/>
                 this(servingSize, servings, calories, 0);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public NutritionFacts(int servingSize, int servings,<br class="calibre7"/>
                     int calories, int fat) {<br class="calibre7"/>
                 this(servingSize, servings, calories, fat, 0);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public NutritionFacts(int servingSize, int servings,<br class="calibre7"/>
                     int calories, int fat, int sodium) {<br class="calibre7"/>
                 this(servingSize, servings, calories, fat, sodium, 0);<br class="calibre7"/>
             }<br class="calibre7"/>
         <span epub:type="pagebreak" id="page_11"></span>
         <br class="calibre7"/>
             public NutritionFacts(int servingSize, int servings,<br class="calibre7"/>
                    int calories, int fat, int sodium, int carbohydrate) {<br class="calibre7"/>
                 this.servingSize  = servingSize;<br class="calibre7"/>
                 this.servings     = servings;<br class="calibre7"/>
                 this.calories     = calories;<br class="calibre7"/>
                 this.fat          = fat;<br class="calibre7"/>
                 this.sodium       = sodium;<br class="calibre7"/>
                 this.carbohydrate = carbohydrate;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">When you want to create an instance, you use the constructor with the shortest parameter
         list containing all the parameters you want to set:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex10a" id="pch2ex10" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">NutritionFacts cocaCola =<br class="calibre7"/>
             new NutritionFacts(240, 8, 100, 0, 35, 27);
         
      </p>
      
      <p class="noindent">Typically this constructor invocation will require many parameters that you don’t
         want to set, but you’re forced to pass a value for them anyway. In this case, we passed
         a value of <code class="calibre12">0</code> for <code class="calibre12">fat</code>. With “only” six parameters this may not seem so bad, but it quickly gets out of
         hand as the number of parameters increases.
      </p>
      
      <p class="indent">In short, <strong class="calibre11">the telescoping constructor pattern works, but it is hard to write client code when
            there are many parameters, and harder still to read it.</strong> The reader is left wondering what all those values mean and must carefully count
         parameters to find out. Long sequences of identically typed parameters can cause subtle
         bugs. If the client accidentally reverses two such parameters, the compiler won’t
         complain, but the program will misbehave at runtime (<a href="ch8.xhtml#lev51" class="calibre8">Item 51</a>).
      </p>
      
      <p class="indent">A second alternative when you’re faced with many optional parameters in a constructor
         is the <em class="calibre9">JavaBeans</em> pattern, in which you call a parameterless constructor to create the object and then
         call setter methods to set each required parameter and each optional parameter of
         interest:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex11a" id="pch2ex11" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// JavaBeans Pattern - allows inconsistency, mandates mutability</strong><br class="calibre7"/>
         public class NutritionFacts {<br class="calibre7"/>
             // Parameters initialized to default values (if any)<br class="calibre7"/>
             private int servingSize  = -1; // Required; no default value<br class="calibre7"/>
             private int servings     = -1; // Required; no default value<br class="calibre7"/>
             private int calories     = 0;<br class="calibre7"/>
             private int fat          = 0;<br class="calibre7"/>
             private int sodium       = 0;<br class="calibre7"/>
             private int carbohydrate = 0;<br class="calibre7"/>
         <br class="calibre7"/>
             public NutritionFacts() { }<br class="calibre7"/>
         <span epub:type="pagebreak" id="page_12"></span>
             // Setters<br class="calibre7"/>
             public void setServingSize(int val)  { servingSize = val; }<br class="calibre7"/>
             public void setServings(int val)    { servings = val; }<br class="calibre7"/>
             public void setCalories(int val)    { calories = val; }<br class="calibre7"/>
             public void setFat(int val)         { fat = val; }<br class="calibre7"/>
             public void setSodium(int val)      { sodium = val; }<br class="calibre7"/>
             public void setCarbohydrate(int val) { carbohydrate = val; }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">This pattern has none of the disadvantages of the telescoping constructor pattern.
         It is easy, if a bit wordy, to create instances, and easy to read the resulting code:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex12a" id="pch2ex12" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">NutritionFacts cocaCola = new NutritionFacts();<br class="calibre7"/>
         cocaCola.setServingSize(240);<br class="calibre7"/>
         cocaCola.setServings(8);<br class="calibre7"/>
         cocaCola.setCalories(100);<br class="calibre7"/>
         cocaCola.setSodium(35);<br class="calibre7"/>
         cocaCola.setCarbohydrate(27);
      </p>
      
      <p class="indent">Unfortunately, the JavaBeans pattern has serious disadvantages of its own. Because
         construction is split across multiple calls, <strong class="calibre11">a JavaBean may be in an inconsistent state partway through its construction.</strong> The class does not have the option of enforcing consistency merely by checking the
         validity of the constructor parameters. Attempting to use an object when it’s in an
         inconsistent state may cause failures that are far removed from the code containing
         the bug and hence difficult to debug. A related disadvantage is that <strong class="calibre11">the JavaBeans pattern precludes the possibility of making a class immutable</strong> (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>) and requires added effort on the part of the programmer to ensure thread safety.
      </p>
      
      <p class="indent">It is possible to reduce these disadvantages by manually “freezing” the object when
         its construction is complete and not allowing it to be used until frozen, but this
         variant is unwieldy and rarely used in practice. Moreover, it can cause errors at
         runtime because the compiler cannot ensure that the programmer calls the freeze method
         on an object before using it.
      </p>
      
      <p class="indent">Luckily, there is a third alternative that combines the safety of the telescoping
         constructor pattern with the readability of the JavaBeans pattern. It is a form of
         the <em class="calibre9">Builder</em> pattern [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. Instead of making the desired object directly, the client calls a constructor (or
         static factory) with all of the required parameters and gets a <em class="calibre9">builder object</em>. Then the client calls setter-like methods on the builder object to set each optional
         parameter of interest. Finally, the client calls a parameterless <code class="calibre12">build</code> method to generate the object, which is typically immutable. The builder is typically
         a static member class (<a href="ch4.xhtml#lev24" class="calibre8">Item 24</a>) of the class it builds. Here’s how it looks in practice:
      </p>
      <span epub:type="pagebreak" id="page_13"></span>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex13a" id="pch2ex13" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Builder Pattern</strong><br class="calibre7"/>
         public class NutritionFacts {<br class="calibre7"/>
             private final int servingSize;<br class="calibre7"/>
             private final int servings;<br class="calibre7"/>
             private final int calories;<br class="calibre7"/>
             private final int fat;<br class="calibre7"/>
             private final int sodium;<br class="calibre7"/>
             private final int carbohydrate;<br class="calibre7"/>
         <br class="calibre7"/>
             public static class Builder {<br class="calibre7"/>
                 // Required parameters<br class="calibre7"/>
                 private final int servingSize;<br class="calibre7"/>
                 private final int servings;<br class="calibre7"/>
         <br class="calibre7"/>
                 // Optional parameters - initialized to default values<br class="calibre7"/>
                 private int calories      = 0;<br class="calibre7"/>
                 private int fat           = 0;<br class="calibre7"/>
                 private int sodium        = 0;<br class="calibre7"/>
                 private int carbohydrate  = 0;<br class="calibre7"/>
         <br class="calibre7"/>
                 public Builder(int servingSize, int servings) {<br class="calibre7"/>
                     this.servingSize = servingSize;<br class="calibre7"/>
                     this.servings    = servings;<br class="calibre7"/>
                 }<br class="calibre7"/>
         <br class="calibre7"/>
                 public Builder calories(int val)<br class="calibre7"/>
                     { calories = val;      return this; }<br class="calibre7"/>
                 public Builder fat(int val)<br class="calibre7"/>
                     { fat = val;           return this; }<br class="calibre7"/>
                 public Builder sodium(int val)<br class="calibre7"/>
                     { sodium = val;        return this; }<br class="calibre7"/>
                 public Builder carbohydrate(int val)<br class="calibre7"/>
                     { carbohydrate = val;  return this; }<br class="calibre7"/>
         <br class="calibre7"/>
                 public NutritionFacts build() {<br class="calibre7"/>
                     return new NutritionFacts(this);<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private NutritionFacts(Builder builder) {<br class="calibre7"/>
                 servingSize  = builder.servingSize;<br class="calibre7"/>
                 servings     = builder.servings;<br class="calibre7"/>
                 calories     = builder.calories;<br class="calibre7"/>
                 fat          = builder.fat;<br class="calibre7"/>
                 sodium       = builder.sodium;<br class="calibre7"/>
                 carbohydrate = builder.carbohydrate;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_14"></span>The <code class="calibre12">NutritionFacts</code> class is immutable, and all parameter default values are in one place. The builder’s
         setter methods return the builder itself so that invocations can be chained, resulting
         in a <em class="calibre9">fluent API</em>. Here’s how the client code looks:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex14a" id="pch2ex14" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)<br class="calibre7"/>
                 .calories(100).sodium(35).carbohydrate(27).build();
      </p>
      
      <p class="noindent">This client code is easy to write and, more importantly, easy to read. <strong class="calibre11">The Builder pattern simulates named optional parameters</strong> as found in Python and Scala.
      </p>
      
      <p class="indent">Validity checks were omitted for brevity. To detect invalid parameters as soon as
         possible, check parameter validity in the builder’s constructor and methods. Check
         invariants involving multiple parameters in the constructor invoked by the <code class="calibre12">build</code> method. To ensure these invariants against attack, do the checks on object fields
         after copying parameters from the builder (<a href="ch8.xhtml#lev50" class="calibre8">Item 50</a>). If a check fails, throw an <code class="calibre12">IllegalArgumentException</code> (<a href="ch10.xhtml#lev72" class="calibre8">Item 72</a>) whose detail message indicates which parameters are invalid (<a href="ch10.xhtml#lev75" class="calibre8">Item 75</a>).
      </p>
      
      <p class="indent"><strong class="calibre11">The Builder pattern is well suited to class hierarchies.</strong> Use a parallel hierarchy of builders, each nested in the corresponding class. Abstract
         classes have abstract builders; concrete classes have concrete builders. For example,
         consider an abstract class at the root of a hierarchy representing various kinds of
         pizza:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex15a" id="pch2ex15" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Builder pattern for class hierarchies</strong><br class="calibre7"/>
         public abstract class Pizza {<br class="calibre7"/>
            public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }<br class="calibre7"/>
            final Set&lt;Topping&gt; toppings;<br class="calibre7"/>
         <br class="calibre7"/>
            abstract static class <strong class="calibre11">Builder&lt;T extends Builder&lt;T&gt;&gt;</strong> {<br class="calibre7"/>
               EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);<br class="calibre7"/>
               public T addTopping(Topping topping) {<br class="calibre7"/>
                  toppings.add(Objects.requireNonNull(topping));<br class="calibre7"/>
                  <strong class="calibre11">return self();</strong><br class="calibre7"/>
               }<br class="calibre7"/>
         <br class="calibre7"/>
               abstract Pizza build();<br class="calibre7"/>
         <br class="calibre7"/>
               <strong class="calibre11">// Subclasses must override this method to return "this"</strong><br class="calibre7"/>
               <strong class="calibre11">protected abstract T self();</strong><br class="calibre7"/>
            }<br class="calibre7"/>
            Pizza(Builder&lt;?&gt; builder) {<br class="calibre7"/>
               toppings = builder.toppings.clone(); // See Item  50<br class="calibre7"/>
            }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Note that <code class="calibre12">Pizza.Builder</code> is a <em class="calibre9">generic type</em> with a <em class="calibre9">recursive type parameter</em> (<a href="ch5.xhtml#lev30" class="calibre8">Item 30</a>). This, along with the abstract <code class="calibre12">self</code> method, allows method chaining to work properly in subclasses, without the need for
         casts. This workaround for the fact that Java lacks a self type is known as the <em class="calibre9">simulated self-type</em> idiom.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_15"></span>Here are two concrete subclasses of <code class="calibre12">Pizza</code>, one of which represents a standard New-York-style pizza, the other a calzone. The
         former has a required size parameter, while the latter lets you specify whether sauce
         should be inside or out:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex16a" id="pch2ex16" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class NyPizza extends Pizza {<br class="calibre7"/>
             public enum Size { SMALL, MEDIUM, LARGE }<br class="calibre7"/>
             private final Size size;<br class="calibre7"/>
         <br class="calibre7"/>
             public static class Builder extends Pizza.Builder&lt;Builder&gt; {<br class="calibre7"/>
                 private final Size size;<br class="calibre7"/>
         <br class="calibre7"/>
                 public Builder(Size size) {<br class="calibre7"/>
                     this.size = Objects.requireNonNull(size);<br class="calibre7"/>
                 }<br class="calibre7"/>
         <br class="calibre7"/>
                 @Override public NyPizza build() {<br class="calibre7"/>
                     return new NyPizza(this);<br class="calibre7"/>
                 }<br class="calibre7"/>
         <br class="calibre7"/>
                 @Override protected Builder self() { return this; }<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private NyPizza(Builder builder) {<br class="calibre7"/>
                 super(builder);<br class="calibre7"/>
                 size = builder.size;<br class="calibre7"/>
             }<br class="calibre7"/>
         }<br class="calibre7"/>
         <br class="calibre7"/>
         public class Calzone extends Pizza {<br class="calibre7"/>
             private final boolean sauceInside;<br class="calibre7"/>
         <br class="calibre7"/>
             public static class Builder extends Pizza.Builder&lt;Builder&gt; {<br class="calibre7"/>
                 private boolean sauceInside = false; // Default<br class="calibre7"/>
         <br class="calibre7"/>
                 public Builder sauceInside() {<br class="calibre7"/>
                     sauceInside = true;<br class="calibre7"/>
                     return this;<br class="calibre7"/>
                 }<br class="calibre7"/>
         <br class="calibre7"/>
                 @Override public Calzone build() {<br class="calibre7"/>
                     return new Calzone(this);<br class="calibre7"/>
                 }<br class="calibre7"/>
         <br class="calibre7"/>
                 @Override protected Builder self() { return this; }<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private Calzone(Builder builder) {<br class="calibre7"/>
                 super(builder);<br class="calibre7"/>
                 sauceInside = builder.sauceInside;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_16"></span>Note that the <code class="calibre12">build</code> method in each subclass’s builder is declared to return the correct subclass: the
         <code class="calibre12">build</code> method of <code class="calibre12">NyPizza.Builder</code> returns <code class="calibre12">NyPizza</code>, while the one in <code class="calibre12">Calzone.Builder</code> returns <code class="calibre12">Calzone</code>. This technique, wherein a subclass method is declared to return a subtype of the
         return type declared in the super-class, is known as <em class="calibre9">covariant return typing</em>. It allows clients to use these builders without the need for casting.
      </p>
      
      <p class="indent">The client code for these “hierarchical builders” is essentially identical to the
         code for the simple <code class="calibre12">NutritionFacts</code> builder. The example client code shown next assumes static imports on enum constants
         for brevity:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex17a" id="pch2ex17" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">NyPizza pizza = new NyPizza.Builder(SMALL)<br class="calibre7"/>
                 .addTopping(SAUSAGE).addTopping(ONION).build();<br class="calibre7"/>
         Calzone calzone = new Calzone.Builder()<br class="calibre7"/>
                 .addTopping(HAM).sauceInside().build();
      </p>
      
      <p class="indent">A minor advantage of builders over constructors is that builders can have multiple
         varargs parameters because each parameter is specified in its own method. Alternatively,
         builders can aggregate the parameters passed into multiple calls to a method into
         a single field, as demonstrated in the <code class="calibre12">addTopping</code> method earlier.
      </p>
      
      <p class="indent">The Builder pattern is quite flexible. A single builder can be used repeatedly to
         build multiple objects. The parameters of the builder can be tweaked between invocations
         of the <code class="calibre12">build</code> method to vary the objects that are created. A builder can fill in some fields automatically
         upon object creation, such as a serial number that increases each time an object is
         created.
      </p>
      
      <p class="indent">The Builder pattern has disadvantages as well. In order to create an object, you must
         first create its builder. While the cost of creating this builder is unlikely to be
         noticeable in practice, it could be a problem in performance-critical situations.
         Also, the Builder pattern is more verbose than the telescoping constructor pattern,
         so it should be used only if there are enough parameters to make it worthwhile, say
         four or more. But keep in mind that you may want to add more parameters in the future.
         But if you start out with constructors or static factories and switch to a builder
         when the class evolves to the point where the number of parameters gets out of hand,
         the obsolete constructors or static factories will stick out like a sore thumb. Therefore,
         it’s often better to start with a builder in the first place.
      </p>
      
      <p class="indent">In summary, <strong class="calibre11">the Builder pattern is a good choice when designing classes whose constructors or
            static factories would have more than a handful of parameters</strong>, especially if many of the parameters are optional or of identical type. Client code
         is much easier to read and write with builders than with telescoping constructors,
         and builders are much safer than JavaBeans.
      </p>
      
      <h3 class="h3b"><a id="lev3" class="calibre4"></a><span epub:type="pagebreak" id="page_17" class="calibre15"></span><strong class="calibre10">Item 3: Enforce the singleton property with a private constructor or an enum type</strong></h3>
      
      <p class="noindent">A <em class="calibre9">singleton</em> is simply a class that is instantiated exactly once [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. Singletons typically represent either a stateless object such as a function (<a href="ch4.xhtml#lev24" class="calibre8">Item 24</a>) or a system component that is intrinsically unique. <strong class="calibre11">Making a class a singleton can make it difficult to test its clients</strong> because it’s impossible to substitute a mock implementation for a singleton unless
         it implements an interface that serves as its type.
      </p>
      
      <p class="indent">There are two common ways to implement singletons. Both are based on keeping the constructor
         private and exporting a public static member to provide access to the sole instance.
         In one approach, the member is a final field:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex18a" id="pch2ex18" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Singleton with public final field</strong><br class="calibre7"/>
         public class Elvis {<br class="calibre7"/>
             <strong class="calibre11">public static final Elvis INSTANCE = new Elvis();</strong><br class="calibre7"/>
             private Elvis() { ... }<br class="calibre7"/>
         <br class="calibre7"/>
             public void leaveTheBuilding() { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The private constructor is called only once, to initialize the public static final
         field <code class="calibre12">Elvis.INSTANCE</code>. The lack of a public or protected constructor <em class="calibre9">guarantees</em> a “monoelvistic” universe: exactly one <code class="calibre12">Elvis</code> instance will exist once the <code class="calibre12">Elvis</code> class is initialized—no more, no less. Nothing that a client does can change this,
         with one caveat: a privileged client can invoke the private constructor reflectively
         (<a href="ch9.xhtml#lev65" class="calibre8">Item 65</a>) with the aid of the <code class="calibre12">AccessibleObject.setAccessible</code> method. If you need to defend against this attack, modify the constructor to make
         it throw an exception if it’s asked to create a second instance.
      </p>
      
      <p class="indent">In the second approach to implementing singletons, the public member is a static factory
         method:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex19a" id="pch2ex19" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Singleton with static factory</strong><br class="calibre7"/>
         public class Elvis {<br class="calibre7"/>
             <strong class="calibre11">private</strong> static final Elvis INSTANCE = new Elvis();<br class="calibre7"/>
             private Elvis() { ... }<br class="calibre7"/>
             <strong class="calibre11">public static Elvis getInstance()</strong> { return INSTANCE; }<br class="calibre7"/>
         <br class="calibre7"/>
             public void leaveTheBuilding() { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">All calls to <code class="calibre12">Elvis.getInstance</code> return the same object reference, and no other <code class="calibre12">Elvis</code> instance will ever be created (with the same caveat mentioned earlier).
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_18"></span>The main advantage of the public field approach is that the API makes it clear that
         the class is a singleton: the public static field is final, so it will always contain
         the same object reference. The second advantage is that it’s simpler.
      </p>
      
      <p class="indent">One advantage of the static factory approach is that it gives you the flexibility
         to change your mind about whether the class is a singleton without changing its API.
         The factory method returns the sole instance, but it could be modified to return,
         say, a separate instance for each thread that invokes it. A second advantage is that
         you can write a <em class="calibre9">generic singleton factory</em> if your application requires it (<a href="ch5.xhtml#lev30" class="calibre8">Item 30</a>). A final advantage of using a static factory is that a <em class="calibre9">method reference</em> can be used as a supplier, for example <code class="calibre12">Elvis::instance</code> is a <code class="calibre12">Supplier&lt;Elvis&gt;</code>. Unless one of these advantages is relevant, the public field approach is preferable.
      </p>
      
      <p class="indent">To make a singleton class that uses either of these approaches <em class="calibre9">serializable</em> (<a href="ch12.xhtml#ch12" class="calibre8">Chapter 12</a>), it is not sufficient merely to add <code class="calibre12">implements Serializable</code> to its declaration. To maintain the singleton guarantee, declare all instance fields
         <code class="calibre12">transient</code> and provide a <code class="calibre12">readResolve</code> method (<a href="ch12.xhtml#lev89" class="calibre8">Item 89</a>). Otherwise, each time a serialized instance is deserialized, a new instance will
         be created, leading, in the case of our example, to spurious <code class="calibre12">Elvis</code> sightings. To prevent this from happening, add this <code class="calibre12">readResolve</code> method to the <code class="calibre12">Elvis</code> class:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex20a" id="pch2ex20" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readResolve method to preserve singleton property</strong><br class="calibre7"/>
         private Object readResolve() {<br class="calibre7"/>
              // Return the one true Elvis and let the garbage collector<br class="calibre7"/>
              // take care of the Elvis impersonator.<br class="calibre7"/>
             return INSTANCE;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">A third way to implement a singleton is to declare a single-element enum:</p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex21a" id="pch2ex21" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Enum singleton - the preferred approach</strong><br class="calibre7"/>
         public enum Elvis {<br class="calibre7"/>
             INSTANCE;<br class="calibre7"/>
         <br class="calibre7"/>
             public void leaveTheBuilding() { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">This approach is similar to the public field approach, but it is more concise, provides
         the serialization machinery for free, and provides an ironclad guarantee against multiple
         instantiation, even in the face of sophisticated serialization or reflection attacks.
         This approach may feel a bit unnatural, but <strong class="calibre11">a single-element enum type is often the best way to implement a singleton</strong>. Note that you can’t use this approach if your singleton must extend a superclass
         other than <code class="calibre12">Enum</code> (though you <em class="calibre9">can</em> declare an enum to implement interfaces).
      </p>
      
      <h3 class="h3b"><a id="lev4" class="calibre4"></a><span epub:type="pagebreak" id="page_19" class="calibre15"></span><strong class="calibre10">Item 4: Enforce noninstantiability with a private constructor</strong></h3>
      
      <p class="noindent">Occasionally you’ll want to write a class that is just a grouping of static methods
         and static fields. Such classes have acquired a bad reputation because some people
         abuse them to avoid thinking in terms of objects, but they do have valid uses. They
         can be used to group related methods on primitive values or arrays, in the manner
         of <code class="calibre12">java.lang.Math</code> or <code class="calibre12">java.util.Arrays</code>. They can also be used to group static methods, including factories (<a href="ch2.xhtml#lev1" class="calibre8">Item 1</a>), for objects that implement some interface, in the manner of <code class="calibre12">java.util.Collections</code>. (As of Java 8, you can also put such methods <em class="calibre9">in</em> the interface, assuming it’s yours to modify.) Lastly, such classes can be used to
         group methods on a final class, since you can’t put them in a subclass.
      </p>
      
      <p class="indent">Such <em class="calibre9">utility classes</em> were not designed to be instantiated: an instance would be nonsensical. In the absence
         of explicit constructors, however, the compiler provides a public, parameterless <em class="calibre9">default constructor</em>. To a user, this constructor is indistinguishable from any other. It is not uncommon
         to see unintentionally instantiable classes in published APIs.
      </p>
      
      <p class="indent"><strong class="calibre11">Attempting to enforce noninstantiability by making a class abstract does not work.</strong> The class can be subclassed and the subclass instantiated. Furthermore, it misleads
         the user into thinking the class was designed for inheritance (<a href="ch4.xhtml#lev19" class="calibre8">Item 19</a>). There is, however, a simple idiom to ensure noninstantiability. A default constructor
         is generated only if a class contains no explicit constructors, so <strong class="calibre11">a class can be made noninstantiable by including a private constructor</strong>:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex22a" id="pch2ex22" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Noninstantiable utility class</strong><br class="calibre7"/>
         public class UtilityClass {<br class="calibre7"/>
             <strong class="calibre11">// Suppress default constructor for noninstantiability</strong><br class="calibre7"/>
             private UtilityClass() {<br class="calibre7"/>
                 throw new AssertionError();<br class="calibre7"/>
             }<br class="calibre7"/>
             ... // Remainder omitted<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Because the explicit constructor is private, it is inaccessible outside the class.
         The <code class="calibre12">AssertionError</code> isn’t strictly required, but it provides insurance in case the constructor is accidentally
         invoked from within the class. It guarantees the class will never be instantiated
         under any circumstances. This idiom is mildly counterintuitive because the constructor
         is provided expressly so that it cannot be invoked. It is therefore wise to include
         a comment, as shown earlier.
      </p>
      
      <p class="indent">As a side effect, this idiom also prevents the class from being subclassed. All constructors
         must invoke a superclass constructor, explicitly or implicitly, and a subclass would
         have no accessible superclass constructor to invoke.
      </p>
      
      <h3 class="h3b"><a id="lev5" class="calibre4"></a><span epub:type="pagebreak" id="page_20" class="calibre15"></span><strong class="calibre10">Item 5: Prefer dependency injection to hardwiring resources</strong></h3>
      
      <p class="noindent">Many classes depend on one or more underlying resources. For example, a spell checker
         depends on a dictionary. It is not uncommon to see such classes implemented as static
         utility classes (<a href="ch2.xhtml#lev4" class="calibre8">Item 4</a>):
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex23a" id="pch2ex23" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Inappropriate use of static utility - inflexible &amp; untestable!</strong><br class="calibre7"/>
         public class SpellChecker {<br class="calibre7"/>
             private static final Lexicon dictionary = ...;<br class="calibre7"/>
         <br class="calibre7"/>
             private SpellChecker() {} // Noninstantiable<br class="calibre7"/>
         <br class="calibre7"/>
             public static boolean isValid(String word) { ... }<br class="calibre7"/>
             public static List&lt;String&gt; suggestions(String typo) { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Similarly, it’s not uncommon to see them implemented as singletons (<a href="ch2.xhtml#lev3" class="calibre8">Item 3</a>):
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex24a" id="pch2ex24" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Inappropriate use of singleton - inflexible &amp; untestable!</strong><br class="calibre7"/>
         public class SpellChecker {<br class="calibre7"/>
             private final Lexicon dictionary = ...;<br class="calibre7"/>
         <br class="calibre7"/>
             private SpellChecker(...) {}<br class="calibre7"/>
             public static INSTANCE = new SpellChecker(...);<br class="calibre7"/>
         <br class="calibre7"/>
             public boolean isValid(String word) { ... }<br class="calibre7"/>
             public List&lt;String&gt; suggestions(String typo) { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Neither of these approaches is satisfactory, because they assume that there is only
         one dictionary worth using. In practice, each language has its own dictionary, and
         special dictionaries are used for special vocabularies. Also, it may be desirable
         to use a special dictionary for testing. It is wishful thinking to assume that a single
         dictionary will suffice for all time.
      </p>
      
      <p class="indent">You could try to have <code class="calibre12">SpellChecker</code> support multiple dictionaries by making the <code class="calibre12">dictionary</code> field nonfinal and adding a method to change the dictionary in an existing spell
         checker, but this would be awkward, error-prone, and unworkable in a concurrent setting.
         <strong class="calibre11">Static utility classes and singletons are inappropriate for classes whose behavior
            is parameterized by an underlying resource.</strong></p>
      
      <p class="indent">What is required is the ability to support multiple instances of the class (in our
         example, <code class="calibre12">SpellChecker</code>), each of which uses the resource desired by the client (in our example, the dictionary).
         A simple pattern that satisfies this requirement is to <strong class="calibre11">pass the resource into the constructor when creating a new instance</strong>. This is one form of <em class="calibre9">dependency injection</em>: the dictionary is a <em class="calibre9">dependency</em> of the spell checker and is <em class="calibre9">injected</em> into the spell checker when it is created.
      </p>
      <span epub:type="pagebreak" id="page_21"></span>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex25a" id="pch2ex25" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Dependency injection provides flexibility and testability</strong><br class="calibre7"/>
         public class SpellChecker {<br class="calibre7"/>
             private final Lexicon dictionary;<br class="calibre7"/>
         <br class="calibre7"/>
             <strong class="calibre11">public SpellChecker(Lexicon dictionary)</strong> {<br class="calibre7"/>
                 this.dictionary = Objects.requireNonNull(dictionary);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public boolean isValid(String word) { ... }<br class="calibre7"/>
             public List&lt;String&gt; suggestions(String typo) { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The dependency injection pattern is so simple that many programmers use it for years
         without knowing it has a name. While our spell checker example had only a single resource
         (the dictionary), dependency injection works with an arbitrary number of resources
         and arbitrary dependency graphs. It preserves immutability (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>), so multiple clients can share dependent objects (assuming the clients desire the
         same underlying resources). Dependency injection is equally applicable to constructors,
         static factories (<a href="ch2.xhtml#lev1" class="calibre8">Item 1</a>), and builders (<a href="ch2.xhtml#lev2" class="calibre8">Item 2</a>).
      </p>
      
      <p class="indent">A useful variant of the pattern is to pass a resource <em class="calibre9">factory</em> to the constructor. A factory is an object that can be called repeatedly to create
         instances of a type. Such factories embody the <em class="calibre9">Factory Method</em> pattern [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. The <code class="calibre12">Supplier&lt;T&gt;</code> interface, introduced in Java 8, is perfect for representing factories. Methods that
         take a <code class="calibre12">Supplier&lt;T&gt;</code> on input should typically constrain the factory’s type parameter using a <em class="calibre9">bounded wildcard type</em> (<a href="ch5.xhtml#lev31" class="calibre8">Item 31</a>) to allow the client to pass in a factory that creates any subtype of a specified
         type. For example, here is a method that makes a mosaic using a client-provided factory
         to produce each tile:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex26a" id="pch2ex26" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</p>
      
      <p class="indent">Although dependency injection greatly improves flexibility and testability, it can
         clutter up large projects, which typically contain thousands of dependencies. This
         clutter can be all but eliminated by using a <em class="calibre9">dependency injection framework</em>, such as Dagger [<a href="ref.xhtml#rDagger" class="calibre8">Dagger</a>], Guice [<a href="ref.xhtml#rGuice" class="calibre8">Guice</a>], or Spring [<a href="ref.xhtml#rSpring" class="calibre8">Spring</a>]. The use of these frameworks is beyond the scope of this book, but note that APIs
         designed for manual dependency injection are trivially adapted for use by these frameworks.
      </p>
      
      <p class="indent">In summary, do not use a singleton or static utility class to implement a class that
         depends on one or more underlying resources whose behavior affects that of the class,
         and do not have the class create these resources directly. Instead, pass the resources,
         or factories to create them, into the constructor (or static factory or builder).
         This practice, known as dependency injection, will greatly enhance the flexibility,
         reusability, and testability of a class.
      </p>
      
      <h3 class="h3b"><a id="lev6" class="calibre4"></a><span epub:type="pagebreak" id="page_22" class="calibre15"></span><strong class="calibre10">Item 6: Avoid creating unnecessary objects</strong></h3>
      
      <p class="noindent">It is often appropriate to reuse a single object instead of creating a new functionally
         equivalent object each time it is needed. Reuse can be both faster and more stylish.
         An object can always be reused if it is immutable (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>).
      </p>
      
      <p class="indent">As an extreme example of what not to do, consider this statement:</p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex27a" id="pch2ex27" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">String s = new String("bikini");  <strong class="calibre11">// DON'T DO THIS!</strong></p>
      
      <p class="indent">The statement creates a new <code class="calibre12">String</code> instance each time it is executed, and none of those object creations is necessary.
         The argument to the <code class="calibre12">String</code> constructor (<code class="calibre12">"bikini"</code>) is itself a <code class="calibre12">String</code> instance, functionally identical to all of the objects created by the constructor.
         If this usage occurs in a loop or in a frequently invoked method, millions of <code class="calibre12">String</code> instances can be created needlessly.
      </p>
      
      <p class="indent">The improved version is simply the following:</p>
      
      <p class="pre">String s = "bikini";</p>
      
      <p class="indent">This version uses a single <code class="calibre12">String</code> instance, rather than creating a new one each time it is executed. Furthermore, it
         is guaranteed that the object will be reused by any other code running in the same
         virtual machine that happens to contain the same string literal [JLS, 3.10.5].
      </p>
      
      <p class="indent">You can often avoid creating unnecessary objects by using <em class="calibre9">static factory methods</em> (<a href="ch2.xhtml#lev1" class="calibre8">Item 1</a>) in preference to constructors on immutable classes that provide both. For example,
         the factory method <code class="calibre12">Boolean.valueOf(String)</code> is preferable to the constructor <code class="calibre12">Boolean(String)</code>, which was deprecated in Java 9. The constructor <em class="calibre9">must</em> create a new object each time it’s called, while the factory method is never required
         to do so and won’t in practice. In addition to reusing immutable objects, you can
         also reuse mutable objects if you know they won’t be modified.
      </p>
      
      <p class="indent">Some object creations are much more expensive than others. If you’re going to need
         such an “expensive object” repeatedly, it may be advisable to cache it for reuse.
         Unfortunately, it’s not always obvious when you’re creating such an object. Suppose
         you want to write a method to determine whether a string is a valid Roman numeral.
         Here’s the easiest way to do this using a regular expression:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex28a" id="pch2ex28" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Performance can be greatly improved!</strong><br class="calibre7"/>
         static boolean isRomanNumeral(String s) {<br class="calibre7"/>
             return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"<br class="calibre7"/>
                     + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_23"></span>The problem with this implementation is that it relies on the <code class="calibre12">String.matches</code> method. <strong class="calibre11">While</strong> <code class="calibre12"><strong class="calibre11">String.matches</strong></code> <strong class="calibre11">is the easiest way to check if a string matches a regular expression, it’s not suitable
            for repeated use in performance-critical situations.</strong> The problem is that it internally creates a <code class="calibre12">Pattern</code> instance for the regular expression and uses it only once, after which it becomes
         eligible for garbage collection. Creating a <code class="calibre12">Pattern</code> instance is expensive because it requires compiling the regular expression into a
         finite state machine.
      </p>
      
      <p class="indent">To improve the performance, explicitly compile the regular expression into a <code class="calibre12">Pattern</code> instance (which is immutable) as part of class initialization, cache it, and reuse
         the same instance for every invocation of the <code class="calibre12">isRomanNumeral</code> method:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex29a" id="pch2ex29" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Reusing expensive object for improved performance</strong><br class="calibre7"/>
         public class RomanNumerals {<br class="calibre7"/>
             private static final Pattern ROMAN = Pattern.compile(<br class="calibre7"/>
                     "^(?=.)M*(C[MD]|D?C{0,3})"<br class="calibre7"/>
                     + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");<br class="calibre7"/>
         <br class="calibre7"/>
             static boolean isRomanNumeral(String s) {<br class="calibre7"/>
                 return ROMAN.matcher(s).matches();<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The improved version of <code class="calibre12">isRomanNumeral</code> provides significant performance gains if invoked frequently. On my machine, the
         original version takes 1.1 µs on an 8-character input string, while the improved version
         takes 0.17 µs, which is 6.5 times faster. Not only is the performance improved, but
         arguably, so is clarity. Making a static final field for the otherwise invisible <code class="calibre12">Pattern</code> instance allows us to give it a name, which is far more readable than the regular
         expression itself.
      </p>
      
      <p class="indent">If the class containing the improved version of the <code class="calibre12">isRomanNumeral</code> method is initialized but the method is never invoked, the field <code class="calibre12">ROMAN</code> will be initialized needlessly. It would be possible to eliminate the initialization
         by <em class="calibre9">lazily initializing</em> the field (<a href="ch11.xhtml#lev83" class="calibre8">Item 83</a>) the first time the <code class="calibre12">isRomanNumeral</code> method is invoked, but this is <em class="calibre9">not</em> recommended. As is often the case with lazy initialization, it would complicate the
         implementation with no measurable performance improvement (<a href="ch9.xhtml#lev67" class="calibre8">Item 67</a>).
      </p>
      
      <p class="indent">When an object is immutable, it is obvious it can be reused safely, but there are
         other situations where it is far less obvious, even counterintuitive. Consider the
         case of <em class="calibre9">adapters</em> [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]<em class="calibre9">,</em> also known as <em class="calibre9">views</em>. An adapter is an object that delegates to a backing object, providing an alternative
         interface. Because an adapter has no state beyond that of its backing object, there’s
         no need to create more than one instance of a given adapter to a given object.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_24"></span>For example, the <code class="calibre12">keySet</code> method of the <code class="calibre12">Map</code> interface returns a <code class="calibre12">Set</code> view of the <code class="calibre12">Map</code> object, consisting of all the keys in the map. Naively, it would seem that every
         call to <code class="calibre12">keySet</code> would have to create a new <code class="calibre12">Set</code> instance, but every call to <code class="calibre12">keySet</code> on a given <code class="calibre12">Map</code> object may return the same <code class="calibre12">Set</code> instance. Although the returned <code class="calibre12">Set</code> instance is typically mutable, all of the returned objects are functionally identical:
         when one of the returned objects changes, so do all the others, because they’re all
         backed by the same <code class="calibre12">Map</code> instance. While it is largely harmless to create multiple instances of the <code class="calibre12">keySet</code> view object, it is unnecessary and has no benefits.
      </p>
      
      <p class="indent">Another way to create unnecessary objects is <em class="calibre9">autoboxing</em>, which allows the programmer to mix primitive and boxed primitive types, boxing and
         unboxing automatically as needed. <strong class="calibre11">Autoboxing blurs but does not erase the distinction between primitive and boxed primitive
            types.</strong> There are subtle semantic distinctions and not-so-subtle performance differences
         (<a href="ch9.xhtml#lev61" class="calibre8">Item 61</a>). Consider the following method, which calculates the sum of all the positive <code class="calibre12">int</code> values. To do this, the program has to use <code class="calibre12">long</code> arithmetic because an <code class="calibre12">int</code> is not big enough to hold the sum of all the positive <code class="calibre12">int</code> values:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex30a" id="pch2ex30" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Hideously slow! Can you spot the object creation?</strong><br class="calibre7"/>
         private static long sum() {<br class="calibre7"/>
             Long sum = 0L;<br class="calibre7"/>
             for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)<br class="calibre7"/>
                 sum += i;<br class="calibre7"/>
         <br class="calibre7"/>
             return sum;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">This program gets the right answer, but it is <em class="calibre9">much</em> slower than it should be, due to a one-character typographical error. The variable
         <code class="calibre12">sum</code> is declared as a <code class="calibre12">Long</code> instead of a <code class="calibre12">long</code>, which means that the program constructs about 2<sup class="calibre14">31</sup> unnecessary <code class="calibre12">Long</code> instances (roughly one for each time the <code class="calibre12">long i</code> is added to the <code class="calibre12">Long sum</code>). Changing the declaration of <code class="calibre12">sum</code> from <code class="calibre12">Long</code> to <code class="calibre12">long</code> reduces the runtime from 6.3 seconds to 0.59 seconds on my machine. The lesson is
         clear: <strong class="calibre11">prefer primitives to boxed primitives, and watch out for unintentional autoboxing.</strong></p>
      
      <p class="indent">This item should not be misconstrued to imply that object creation is expensive and
         should be avoided. On the contrary, the creation and reclamation of small objects
         whose constructors do little explicit work is cheap, especially on modern JVM implementations.
         Creating additional objects to enhance the clarity, simplicity, or power of a program
         is generally a good thing.
      </p>
      
      <p class="indent">Conversely, avoiding object creation by maintaining your own <em class="calibre9">object pool</em> is a bad idea unless the objects in the pool are extremely heavyweight. The classic
         <span epub:type="pagebreak" id="page_25"></span>example of an object that <em class="calibre9">does</em> justify an object pool is a database connection. The cost of establishing the connection
         is sufficiently high that it makes sense to reuse these objects. Generally speaking,
         however, maintaining your own object pools clutters your code, increases memory footprint,
         and harms performance. Modern JVM implementations have highly optimized garbage collectors
         that easily outperform such object pools on lightweight objects.
      </p>
      
      <p class="indent">The counterpoint to this item is <a href="ch8.xhtml#lev50" class="calibre8">Item 50</a> on <em class="calibre9">defensive copying</em>. The present item says, “Don’t create a new object when you should reuse an existing
         one,” while <a href="ch8.xhtml#lev50" class="calibre8">Item 50</a> says, “Don’t reuse an existing object when you should create a new one.” Note that
         the penalty for reusing an object when defensive copying is called for is far greater
         than the penalty for needlessly creating a duplicate object. Failing to make defensive
         copies where required can lead to insidious bugs and security holes; creating objects
         unnecessarily merely affects style and performance.
      </p>
      
      <h3 class="h3b"><a id="lev7" class="calibre4"></a><span epub:type="pagebreak" id="page_26" class="calibre15"></span><strong class="calibre10">Item 7: Eliminate obsolete object references</strong></h3>
      
      <p class="noindent">If you switched from a language with manual memory management, such as C or C++, to
         a garbage-collected language such as Java, your job as a programmer was made much
         easier by the fact that your objects are automatically reclaimed when you’re through
         with them. It seems almost like magic when you first experience it. It can easily
         lead to the impression that you don’t have to think about memory management, but this
         isn’t quite true.
      </p>
      
      <p class="indent">Consider the following simple stack implementation:</p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex31a" id="pch2ex31" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Can you spot the "memory leak"?</strong><br class="calibre7"/>
         public class Stack {<br class="calibre7"/>
             private Object[] elements;<br class="calibre7"/>
             private int size = 0;<br class="calibre7"/>
             private static final int DEFAULT_INITIAL_CAPACITY = 16;<br class="calibre7"/>
         <br class="calibre7"/>
             public Stack() {<br class="calibre7"/>
                 elements = new Object[DEFAULT_INITIAL_CAPACITY];<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public void push(Object e) {<br class="calibre7"/>
                 ensureCapacity();<br class="calibre7"/>
                 elements[size++] = e;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public Object pop() {<br class="calibre7"/>
                 if (size == 0)<br class="calibre7"/>
                     throw new EmptyStackException();<br class="calibre7"/>
                 return elements[--size];<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             /**<br class="calibre7"/>
              * Ensure space for at least one more element, roughly<br class="calibre7"/>
              * doubling the capacity each time the array needs to grow.<br class="calibre7"/>
              */<br class="calibre7"/>
             private void ensureCapacity() {<br class="calibre7"/>
                 if (elements.length == size)<br class="calibre7"/>
                     elements = Arrays.copyOf(elements, 2 * size + 1);<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">There’s nothing obviously wrong with this program (but see <a href="ch5.xhtml#lev29" class="calibre8">Item 29</a> for a generic version). You could test it exhaustively, and it would pass every test
         with flying colors, but there’s a problem lurking. Loosely speaking, the program has
         a “memory leak,” which can silently manifest itself as reduced performance due to
         <span epub:type="pagebreak" id="page_27"></span>increased garbage collector activity or increased memory footprint. In extreme cases,
         such memory leaks can cause disk paging and even program failure with an <code class="calibre12">OutOfMemoryError</code>, but such failures are relatively rare.
      </p>
      
      <p class="indent">So where is the memory leak? If a stack grows and then shrinks, the objects that were
         popped off the stack will not be garbage collected, even if the program using the
         stack has no more references to them. This is because the stack maintains <em class="calibre9">obsolete references</em> to these objects. An obsolete reference is simply a reference that will never be
         dereferenced again. In this case, any references outside of the “active portion” of
         the element array are obsolete. The active portion consists of the elements whose
         index is less than <code class="calibre12">size</code>.
      </p>
      
      <p class="indent">Memory leaks in garbage-collected languages (more properly known as <em class="calibre9">unintentional object retentions</em>) are insidious. If an object reference is unintentionally retained, not only is that
         object excluded from garbage collection, but so too are any objects referenced by
         that object, and so on. Even if only a few object references are unintentionally retained,
         many, many objects may be prevented from being garbage collected, with potentially
         large effects on performance.
      </p>
      
      <p class="indent">The fix for this sort of problem is simple: null out references once they become obsolete.
         In the case of our <code class="calibre12">Stack</code> class, the reference to an item becomes obsolete as soon as it’s popped off the stack.
         The corrected version of the <code class="calibre12">pop</code> method looks like this:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex32a" id="pch2ex32" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public Object pop() {<br class="calibre7"/>
             if (size == 0)<br class="calibre7"/>
                 throw new EmptyStackException();<br class="calibre7"/>
             Object result = elements[--size];<br class="calibre7"/>
             <strong class="calibre11">elements[size] = null; // Eliminate obsolete reference</strong><br class="calibre7"/>
             return result;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">An added benefit of nulling out obsolete references is that if they are subsequently
         dereferenced by mistake, the program will immediately fail with a <code class="calibre12">NullPointerException</code>, rather than quietly doing the wrong thing. It is always beneficial to detect programming
         errors as quickly as possible.
      </p>
      
      <p class="indent">When programmers are first stung by this problem, they may overcompensate by nulling
         out every object reference as soon as the program is finished using it. This is neither
         necessary nor desirable; it clutters up the program unnecessarily. <strong class="calibre11">Nulling out object references should be the exception rather than the norm.</strong> The best way to eliminate an obsolete reference is to let the variable that contained
         the reference fall out of scope. This occurs naturally if you define each variable
         in the narrowest possible scope (<a href="ch9.xhtml#lev57" class="calibre8">Item 57</a>).
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_28"></span>So when should you null out a reference? What aspect of the <code class="calibre12">Stack</code> class makes it susceptible to memory leaks? Simply put, it <em class="calibre9">manages its own memory</em>. The <em class="calibre9">storage pool</em> consists of the elements of the <code class="calibre12">elements</code> array (the object reference cells, not the objects themselves). The elements in the
         active portion of the array (as defined earlier) are <em class="calibre9">allocated</em>, and those in the remainder of the array are <em class="calibre9">free</em>. The garbage collector has no way of knowing this; to the garbage collector, all
         of the object references in the <code class="calibre12">elements</code> array are equally valid. Only the programmer knows that the inactive portion of the
         array is unimportant. The programmer effectively communicates this fact to the garbage
         collector by manually nulling out array elements as soon as they become part of the
         inactive portion.
      </p>
      
      <p class="indent">Generally speaking, <strong class="calibre11">whenever a class manages its own memory, the programmer should be alert for memory
            leaks</strong>. Whenever an element is freed, any object references contained in the element should
         be nulled out.
      </p>
      
      <p class="indent"><strong class="calibre11">Another common source of memory leaks is caches.</strong> Once you put an object reference into a cache, it’s easy to forget that it’s there
         and leave it in the cache long after it becomes irrelevant. There are several solutions
         to this problem. If you’re lucky enough to implement a cache for which an entry is
         relevant exactly so long as there are references to its key outside of the cache,
         represent the cache as a <code class="calibre12">WeakHashMap</code>; entries will be removed automatically after they become obsolete. Remember that
         <code class="calibre12">WeakHashMap</code> is useful only if the desired lifetime of cache entries is determined by external
         references to the key, not the value.
      </p>
      
      <p class="indent">More commonly, the useful lifetime of a cache entry is less well defined, with entries
         becoming less valuable over time. Under these circumstances, the cache should occasionally
         be cleansed of entries that have fallen into disuse. This can be done by a background
         thread (perhaps a <code class="calibre12">ScheduledThreadPoolExecutor</code>) or as a side effect of adding new entries to the cache. The <code class="calibre12">LinkedHashMap</code> class facilitates the latter approach with its <code class="calibre12">removeEldestEntry</code> method. For more sophisticated caches, you may need to use <code class="calibre12">java.lang.ref</code> directly.
      </p>
      
      <p class="indent"><strong class="calibre11">A third common source of memory leaks is listeners and other callbacks.</strong> If you implement an API where clients register callbacks but don’t deregister them
         explicitly, they will accumulate unless you take some action. One way to ensure that
         callbacks are garbage collected promptly is to store only <em class="calibre9">weak references</em> to them, for instance, by storing them only as keys in a <code class="calibre12">WeakHashMap</code>.
      </p>
      
      <p class="indent">Because memory leaks typically do not manifest themselves as obvious failures, they
         may remain present in a system for years. They are typically discovered only as a
         result of careful code inspection or with the aid of a debugging tool known as a <em class="calibre9">heap profiler</em>. Therefore, it is very desirable to learn to anticipate problems like this before
         they occur and prevent them from happening.
      </p>
      
      <h3 class="h3b"><a id="lev8" class="calibre4"></a><span epub:type="pagebreak" id="page_29" class="calibre15"></span><strong class="calibre10">Item 8: Avoid finalizers and cleaners</strong></h3>
      
      <p class="noindent"><strong class="calibre11">Finalizers are unpredictable, often dangerous, and generally unnecessary.</strong> Their use can cause erratic behavior, poor performance, and portability problems.
         Finalizers have a few valid uses, which we’ll cover later in this item, but as a rule,
         you should avoid them. As of Java 9, finalizers have been deprecated, but they are
         still being used by the Java libraries. The Java 9 replacement for finalizers is <em class="calibre9">cleaners</em>. <strong class="calibre11">Cleaners are less dangerous than finalizers, but still unpredictable, slow, and generally
            unnecessary.</strong></p>
      
      <p class="indent">C++ programmers are cautioned not to think of finalizers or cleaners as Java’s analogue
         of C++ destructors. In C++, destructors are the normal way to reclaim the resources
         associated with an object, a necessary counterpart to constructors. In Java, the garbage
         collector reclaims the storage associated with an object when it becomes unreachable,
         requiring no special effort on the part of the programmer. C++ destructors are also
         used to reclaim other nonmemory resources. In Java, a <code class="calibre12">try</code>-with-resources or <code class="calibre12">try</code>-<code class="calibre12">finally</code> block is used for this purpose (<a href="ch2.xhtml#lev9" class="calibre8">Item 9</a>).
      </p>
      
      <p class="indent">One shortcoming of finalizers and cleaners is that there is no guarantee they’ll be
         executed promptly [JLS, 12.6]. It can take arbitrarily long between the time that
         an object becomes unreachable and the time its finalizer or cleaner runs. This means
         that you should <strong class="calibre11">never do anything time-critical in a finalizer or cleaner.</strong> For example, it is a grave error to depend on a finalizer or cleaner to close files
         because open file descriptors are a limited resource. If many files are left open
         as a result of the system’s tardiness in running finalizers or cleaners, a program
         may fail because it can no longer open files.
      </p>
      
      <p class="indent">The promptness with which finalizers and cleaners are executed is primarily a function
         of the garbage collection algorithm, which varies widely across implementations. The
         behavior of a program that depends on the promptness of finalizer or cleaner execution
         may likewise vary. It is entirely possible that such a program will run perfectly
         on the JVM on which you test it and then fail miserably on the one favored by your
         most important customer.
      </p>
      
      <p class="indent">Tardy finalization is not just a theoretical problem. Providing a finalizer for a
         class can arbitrarily delay reclamation of its instances. A colleague debugged a long-running
         GUI application that was mysteriously dying with an <code class="calibre12">OutOfMemoryError</code>. Analysis revealed that at the time of its death, the application had thousands of
         graphics objects on its finalizer queue just waiting to be finalized and reclaimed.
         Unfortunately, the finalizer thread was running at a lower priority than another application
         thread, so objects weren’t getting finalized at the rate they became eligible for
         finalization. The language specification makes no guarantees <span epub:type="pagebreak" id="page_30"></span>as to which thread will execute finalizers, so there is no portable way to prevent
         this sort of problem other than to refrain from using finalizers. Cleaners are a bit
         better than finalizers in this regard because class authors have control over their
         own cleaner threads, but cleaners still run in the background, under the control of
         the garbage collector, so there can be no guarantee of prompt cleaning.
      </p>
      
      <p class="indent">Not only does the specification provide no guarantee that finalizers or cleaners will
         run promptly; it provides no guarantee that they’ll run at all. It is entirely possible,
         even likely, that a program terminates without running them on some objects that are
         no longer reachable. As a consequence, you should <strong class="calibre11">never depend on a finalizer or cleaner to update persistent state.</strong> For example, depending on a finalizer or cleaner to release a persistent lock on
         a shared resource such as a database is a good way to bring your entire distributed
         system to a grinding halt.
      </p>
      
      <p class="indent">Don’t be seduced by the methods <code class="calibre12">System.gc</code> and <code class="calibre12">System.runFinalization</code>. They may increase the odds of finalizers or cleaners getting executed, but they
         don’t guarantee it. Two methods once claimed to make this guarantee: <code class="calibre12">System.runFinalizersOnExit</code> and its evil twin, <code class="calibre12">Runtime.runFinalizersOnExit</code>. These methods are fatally flawed and have been deprecated for decades [<a href="ref.xhtml#rThreadStop" class="calibre8">ThreadStop</a>].
      </p>
      
      <p class="indent">Another problem with finalizers is that an uncaught exception thrown during finalization
         is ignored, and finalization of that object terminates [JLS, 12.6]. Uncaught exceptions
         can leave other objects in a corrupt state. If another thread attempts to use such
         a corrupted object, arbitrary nondeterministic behavior may result. Normally, an uncaught
         exception will terminate the thread and print a stack trace, but not if it occurs
         in a finalizer—it won’t even print a warning. Cleaners do not have this problem because
         a library using a cleaner has control over its thread.
      </p>
      
      <p class="indent"><strong class="calibre11">There is a</strong> <em class="calibre9"><strong class="calibre11">severe</strong></em> <strong class="calibre11">performance penalty for using finalizers and cleaners.</strong> On my machine, the time to create a simple <code class="calibre12">AutoCloseable</code> object, to close it using <code class="calibre12">try</code>-with-resources, and to have the garbage collector reclaim it is about 12 ns. Using
         a finalizer instead increases the time to 550 ns. In other words, it is about 50 times
         slower to create and destroy objects with finalizers. This is primarily because finalizers
         inhibit efficient garbage collection. Cleaners are comparable in speed to finalizers
         if you use them to clean all instances of the class (about 500 ns per instance on
         my machine), but cleaners are much faster if you use them only as a safety net, as
         discussed below. Under these circumstances, creating, cleaning, and destroying an
         object takes about 66 ns on my machine, which means you pay a factor of five (not
         fifty) for the insurance of a safety net <em class="calibre9">if</em> you don’t use it.
      </p>
      
      <p class="indent"><strong class="calibre11">Finalizers have a serious security problem: they open your class up to</strong> <em class="calibre9"><strong class="calibre11">finalizer attacks</strong></em><strong class="calibre11">.</strong> The idea behind a finalizer attack is simple: If an exception is <span epub:type="pagebreak" id="page_31"></span>thrown from a constructor or its serialization equivalents—the <code class="calibre12">readObject</code> and <code class="calibre12">readResolve</code> methods (<a href="ch12.xhtml#ch12" class="calibre8">Chapter 12</a>)—the finalizer of a malicious subclass can run on the partially constructed object
         that should have “died on the vine.” This finalizer can record a reference to the
         object in a static field, preventing it from being garbage collected. Once the malformed
         object has been recorded, it is a simple matter to invoke arbitrary methods on this
         object that should never have been allowed to exist in the first place. <strong class="calibre11">Throwing an exception from a constructor should be sufficient to prevent an object
            from coming into existence; in the presence of finalizers, it is not.</strong> Such attacks can have dire consequences. Final classes are immune to finalizer attacks
         because no one can write a malicious subclass of a final class. <strong class="calibre11">To protect nonfinal classes from finalizer attacks, write a final</strong> <code class="calibre12"><strong class="calibre11">finalize</strong></code> <strong class="calibre11">method that does nothing.</strong></p>
      
      <p class="indent">So what should you do instead of writing a finalizer or cleaner for a class whose
         objects encapsulate resources that require termination, such as files or threads?
         Just <strong class="calibre11">have your class implement</strong> <code class="calibre12"><strong class="calibre11">AutoCloseable</strong></code><strong class="calibre11">,</strong> and require its clients to invoke the <code class="calibre12">close</code> method on each instance when it is no longer needed, typically using <code class="calibre12">try</code>-with-resources to ensure termination even in the face of exceptions (<a href="ch2.xhtml#lev9" class="calibre8">Item 9</a>). One detail worth mentioning is that the instance must keep track of whether it
         has been closed: the <code class="calibre12">close</code> method must record in a field that the object is no longer valid, and other methods
         must check this field and throw an <code class="calibre12">IllegalStateException</code> if they are called after the object has been closed.
      </p>
      
      <p class="indent">So what, if anything, are cleaners and finalizers good for? They have perhaps two
         legitimate uses. One is to act as a safety net in case the owner of a resource neglects
         to call its <code class="calibre12">close</code> method. While there’s no guarantee that the cleaner or finalizer will run promptly
         (or at all), it is better to free the resource late than never if the client fails
         to do so. If you’re considering writing such a safety-net finalizer, think long and
         hard about whether the protection is worth the cost. Some Java library classes, such
         as <code class="calibre12">FileInputStream</code>, <code class="calibre12">FileOutputStream</code>, <code class="calibre12">ThreadPoolExecutor</code>, and <code class="calibre12">java.sql.Connection</code>, have finalizers that serve as safety nets.
      </p>
      
      <p class="indent">A second legitimate use of cleaners concerns objects with <em class="calibre9">native peers</em>. A native peer is a native (non-Java) object to which a normal object delegates via
         native methods. Because a native peer is not a normal object, the garbage collector
         doesn’t know about it and can’t reclaim it when its Java peer is reclaimed. A cleaner
         or finalizer may be an appropriate vehicle for this task, assuming the performance
         is acceptable and the native peer holds no critical resources. If the performance
         is unacceptable or the native peer holds resources that must be reclaimed promptly,
         the class should have a <code class="calibre12">close</code> method, as described earlier.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_32"></span>Cleaners are a bit tricky to use. Below is a simple <code class="calibre12">Room</code> class demonstrating the facility. Let’s assume that rooms must be cleaned before
         they are reclaimed. The <code class="calibre12">Room</code> class implements <code class="calibre12">AutoCloseable</code>; the fact that its automatic cleaning safety net uses a cleaner is merely an implementation
         detail. Unlike finalizers, cleaners do not pollute a class’s public API:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex33a" id="pch2ex33" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// An autocloseable class using a cleaner as a safety net</strong><br class="calibre7"/>
         public class Room implements AutoCloseable {<br class="calibre7"/>
             private static final Cleaner cleaner = Cleaner.create();<br class="calibre7"/>
         <br class="calibre7"/>
             // Resource that requires cleaning. <strong class="calibre11">Must not refer to Room!</strong><br class="calibre7"/>
             private static class State implements Runnable {<br class="calibre7"/>
                 int numJunkPiles; // Number of junk piles in this room<br class="calibre7"/>
         <br class="calibre7"/>
                 State(int numJunkPiles) {<br class="calibre7"/>
                     this.numJunkPiles = numJunkPiles;<br class="calibre7"/>
                 }<br class="calibre7"/>
         <br class="calibre7"/>
                 // Invoked by close method <em class="calibre9">or</em> cleaner<br class="calibre7"/>
                 @Override public void run() {<br class="calibre7"/>
                     System.out.println("Cleaning room");<br class="calibre7"/>
                     numJunkPiles = 0;<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             // The state of this room, shared with our cleanable<br class="calibre7"/>
             private final State state;<br class="calibre7"/>
         <br class="calibre7"/>
             // Our cleanable. Cleans the room when it’s eligible for gc<br class="calibre7"/>
             private final Cleaner.Cleanable cleanable;<br class="calibre7"/>
         <br class="calibre7"/>
             public Room(int numJunkPiles) {<br class="calibre7"/>
                 state = new State(numJunkPiles);<br class="calibre7"/>
                 cleanable = cleaner.register(this, state);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             @Override public void close() {<br class="calibre7"/>
                 cleanable.clean();<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The static nested <code class="calibre12">State</code> class holds the resources that are required by the cleaner to clean the room. In
         this case, it is simply the <code class="calibre12">numJunkPiles</code> field, which represents the amount of mess in the room. More realistically, it might
         be a final <code class="calibre12">long</code> that contains a pointer to a native peer. <code class="calibre12">State</code> implements <code class="calibre12">Runnable</code>, and its <code class="calibre12">run</code> method is called at most once, by the <code class="calibre12">Cleanable</code> that we get when we register our <code class="calibre12">State</code> instance with our cleaner in the <code class="calibre12">Room</code> constructor. The call to the <code class="calibre12">run</code> method will be triggered by one of two things: Usually it is triggered by a call
         to <span epub:type="pagebreak" id="page_33"></span><code class="calibre12">Room</code>’s <code class="calibre12">close</code> method calling <code class="calibre12">Cleanable</code>’s clean method. If the client fails to call the <code class="calibre12">close</code> method by the time a <code class="calibre12">Room</code> instance is eligible for garbage collection, the cleaner will (hopefully) call <code class="calibre12">State</code>’s <code class="calibre12">run</code> method.
      </p>
      
      <p class="indent">It is critical that a <code class="calibre12">State</code> instance does not refer to its <code class="calibre12">Room</code> instance. If it did, it would create a circularity that would prevent the <code class="calibre12">Room</code> instance from becoming eligible for garbage collection (and from being automatically
         cleaned). Therefore, <code class="calibre12">State</code> must be a <em class="calibre9">static</em> nested class because nonstatic nested classes contain references to their enclosing
         instances (<a href="ch4.xhtml#lev24" class="calibre8">Item 24</a>). It is similarly inadvisable to use a lambda because they can easily capture references
         to enclosing objects.
      </p>
      
      <p class="indent">As we said earlier, <code class="calibre12">Room</code>’s cleaner is used only as a safety net. If clients surround all <code class="calibre12">Room</code> instantiations in <code class="calibre12">try</code>-with-resource blocks, automatic cleaning will never be required. This well-behaved
         client demonstrates that behavior:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex34a" id="pch2ex34" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class Adult {<br class="calibre7"/>
             public static void main(String[] args) {<br class="calibre7"/>
                 try (Room myRoom = new Room(7)) {<br class="calibre7"/>
                     System.out.println("Goodbye");<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">As you’d expect, running the <code class="calibre12">Adult</code> program prints <code class="calibre12">Goodbye</code>, followed by <code class="calibre12">Cleaning room</code>. But what about this ill-behaved program, which never cleans its room?
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex35a" id="pch2ex35" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class Teenager {<br class="calibre7"/>
             public static void main(String[] args) {<br class="calibre7"/>
                 new Room(99);<br class="calibre7"/>
                 System.out.println("Peace out");<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">You might expect it to print <code class="calibre12">Peace out</code>, followed by <code class="calibre12">Cleaning room</code>, but on my machine, it never prints <code class="calibre12">Cleaning room</code>; it just exits. This is the unpredictability we spoke of earlier. The <code class="calibre12">Cleaner</code> spec says, “The behavior of cleaners during <code class="calibre12">System.exit</code> is implementation specific. No guarantees are made relating to whether cleaning actions
         are invoked or not.” While the spec does not say it, the same holds true for normal
         program exit. On my machine, adding the line <code class="calibre12">System.gc()</code> to <code class="calibre12">Teenager</code>’s <code class="calibre12">main</code> method is enough to make it print <code class="calibre12">Cleaning room</code> prior to exit, but there’s no guarantee that you’ll see the same behavior on your
         machine.
      </p>
      
      <p class="indent">In summary, don’t use cleaners, or in releases prior to Java 9, finalizers, except
         as a safety net or to terminate noncritical native resources. Even then, beware the
         indeterminacy and performance consequences.
      </p>
      
      <h3 class="h3b"><a id="lev9" class="calibre4"></a><span epub:type="pagebreak" id="page_34" class="calibre15"></span><strong class="calibre10">Item 9: Prefer</strong> <code class="calibre19"><strong class="calibre10">try</strong></code><strong class="calibre10">-with-resources to</strong> <code class="calibre19"><strong class="calibre10">try</strong></code><strong class="calibre10">-</strong><code class="calibre19"><strong class="calibre10">finally</strong></code></h3>
      
      <p class="noindent">The Java libraries include many resources that must be closed manually by invoking
         a <code class="calibre12">close</code> method. Examples include <code class="calibre12">InputStream</code>, <code class="calibre12">OutputStream</code>, and <code class="calibre12">java.sql.Connection</code>. Closing resources is often overlooked by clients, with predictably dire performance
         consequences. While many of these resources use finalizers as a safety net, finalizers
         don’t work very well (<a href="ch2.xhtml#lev8" class="calibre8">Item 8</a>).
      </p>
      
      <p class="indent">Historically, a <code class="calibre12">try</code>-<code class="calibre12">finally</code> statement was the best way to guarantee that a resource would be closed properly,
         even in the face of an exception or return:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex36a" id="pch2ex36" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// try-finally - No longer the best way to close resources!</strong><br class="calibre7"/>
         static String firstLineOfFile(String path) throws IOException {<br class="calibre7"/>
             BufferedReader br = new BufferedReader(new FileReader(path));<br class="calibre7"/>
             try {<br class="calibre7"/>
                 return br.readLine();<br class="calibre7"/>
             } finally {<br class="calibre7"/>
                 br.close();<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">This may not look bad, but it gets worse when you add a second resource:</p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex37a" id="pch2ex37" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// try-finally is ugly when used with more than one resource!</strong><br class="calibre7"/>
         static void copy(String src, String dst) throws IOException {<br class="calibre7"/>
             InputStream in = new FileInputStream(src);<br class="calibre7"/>
             try {<br class="calibre7"/>
                 OutputStream out = new FileOutputStream(dst);<br class="calibre7"/>
                 try {<br class="calibre7"/>
                     byte[] buf = new byte[BUFFER_SIZE];<br class="calibre7"/>
                     int n;<br class="calibre7"/>
                     while ((n = in.read(buf)) &gt;= 0)<br class="calibre7"/>
                         out.write(buf, 0, n);<br class="calibre7"/>
                 } finally {<br class="calibre7"/>
                     out.close();<br class="calibre7"/>
                 }<br class="calibre7"/>
             } finally {<br class="calibre7"/>
                 in.close();<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">It may be hard to believe, but even good programmers got this wrong most of the time.
         For starters, I got it wrong on page 88 of <em class="calibre9">Java Puzzlers</em> [<a href="ref.xhtml#rBloch05" class="calibre8">Bloch05</a>], and no one noticed for years. In fact, two-thirds of the uses of the <code class="calibre12">close</code> method in the Java libraries were wrong in 2007.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_35"></span>Even the correct code for closing resources with <code class="calibre12">try</code>-<code class="calibre12">finally</code> statements, as illustrated in the previous two code examples, has a subtle deficiency.
         The code in both the <code class="calibre12">try</code> block and the <code class="calibre12">finally</code> block is capable of throwing exceptions. For example, in the <code class="calibre12">firstLineOfFile</code> method, the call to <code class="calibre12">readLine</code> could throw an exception due to a failure in the underlying physical device, and
         the call to <code class="calibre12">close</code> could then fail for the same reason. Under these circumstances, the second exception
         completely obliterates the first one. There is no record of the first exception in
         the exception stack trace, which can greatly complicate debugging in real systems—usually
         it’s the first exception that you want to see in order to diagnose the problem. While
         it is possible to write code to suppress the second exception in favor of the first,
         virtually no one did because it’s just too verbose.
      </p>
      
      <p class="indent">All of these problems were solved in one fell swoop when Java 7 introduced the <code class="calibre12">try</code>-with-resources statement [JLS, 14.20.3]. To be usable with this construct, a resource
         must implement the <code class="calibre12">AutoCloseable</code> interface, which consists of a single <code class="calibre12">void</code>-returning <code class="calibre12">close</code> method. Many classes and interfaces in the Java libraries and in third-party libraries
         now implement or extend <code class="calibre12">AutoCloseable</code>. If you write a class that represents a resource that must be closed, your class
         should implement <code class="calibre12">AutoCloseable</code> too.
      </p>
      
      <p class="indent">Here’s how our first example looks using <code class="calibre12">try</code>-with-resources:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex38a" id="pch2ex38" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// try-with-resources - the the best way to close resources!</strong><br class="calibre7"/>
         static String firstLineOfFile(String path) throws IOException {<br class="calibre7"/>
             try (BufferedReader br = new BufferedReader(<br class="calibre7"/>
                    new FileReader(path))) {<br class="calibre7"/>
                return br.readLine();<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">And here’s how our second example looks using <code class="calibre12">try</code>-with-resources:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex39a" id="pch2ex39" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// try-with-resources on multiple resources - short and sweet</strong><br class="calibre7"/>
         static void copy(String src, String dst) throws IOException {<br class="calibre7"/>
             try (InputStream   in = new FileInputStream(src);<br class="calibre7"/>
                  OutputStream out = new FileOutputStream(dst)) {<br class="calibre7"/>
                 byte[] buf = new byte[BUFFER_SIZE];<br class="calibre7"/>
                 int n;<br class="calibre7"/>
                 while ((n = in.read(buf)) &gt;= 0)<br class="calibre7"/>
                     out.write(buf, 0, n);<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Not only are the <code class="calibre12">try</code>-with-resources versions shorter and more readable than the originals, but they provide
         far better diagnostics. Consider the <code class="calibre12">firstLineOfFile</code> <span epub:type="pagebreak" id="page_36"></span>method. If exceptions are thrown by both the <code class="calibre12">readLine</code> call and the (invisible) <code class="calibre12">close</code>, the latter exception is <em class="calibre9">suppressed</em> in favor of the former. In fact, multiple exceptions may be suppressed in order to
         preserve the exception that you actually want to see. These suppressed exceptions
         are not merely discarded; they are printed in the stack trace with a notation saying
         that they were suppressed. You can also access them programmatically with the <code class="calibre12">getSuppressed</code> method, which was added to <code class="calibre12">Throwable</code> in Java 7.
      </p>
      
      <p class="indent">You can put catch clauses on <code class="calibre12">try</code>-with-resources statements, just as you can on regular <code class="calibre12">try</code>-<code class="calibre12">finally</code> statements. This allows you to handle exceptions without sullying your code with
         another layer of nesting. As a slightly contrived example, here’s a version our <code class="calibre12">firstLineOfFile</code> method that does not throw exceptions, but takes a default value to return if it
         can’t open the file or read from it:
      </p>
      
      <p class="codelink"><a href="ch2_images.xhtml#pch2ex40a" id="pch2ex40" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// try-with-resources with a catch clause</strong><br class="calibre7"/>
         static String firstLineOfFile(String path, String defaultVal) {<br class="calibre7"/>
             try (BufferedReader br = new BufferedReader(<br class="calibre7"/>
                    new FileReader(path))) {<br class="calibre7"/>
                 return br.readLine();<br class="calibre7"/>
             } catch (IOException e) {<br class="calibre7"/>
                 return defaultVal;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The lesson is clear: Always use <code class="calibre12">try</code>-with-resources in preference to <code class="calibre12">try-finally</code> when working with resources that must be closed. The resulting code is shorter and
         clearer, and the exceptions that it generates are more useful. The <code class="calibre12">try-</code>with-resources statement makes it easy to write correct code using resources that
         must be closed, which was practically impossible using <code class="calibre12">try</code>-<code class="calibre12">finally</code>.
      </p>
      
   
   


  </div>

  
  <div class="calibreToc">
    <h2><a href="../../../4bgup-l038f.html">Table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="cover.xhtml">Cover Page</a>
    </li>
    <li>
      <a href="pref00.xhtml">About This E-Book</a>
    </li>
    <li>
      <a href="title.xhtml">Title Page</a>
    </li>
    <li>
      <a href="copy.xhtml">Copyright Page</a>
    </li>
    <li>
      <a href="ded.xhtml">Dedication</a>
    </li>
    <li>
      <a href="contents.xhtml">Contents</a>
    </li>
    <li>
      <a href="foreword.xhtml#foreword">Foreword</a>
    </li>
    <li>
      <a href="preface.xhtml#preface">Preface</a>
    </li>
    <li>
      <a href="acknowledgments.xhtml#acknowledgments">Acknowledgments</a>
    </li>
    <li>
      <a href="ch1.xhtml#ch1">1 Introduction</a>
    </li>
    <li>
      <a href="ch2.xhtml#ch2">2 Creating and Destroying Objects</a>
      <ul>
        <li>
          <a href="ch2.xhtml#lev1">Item 1: Consider static factory methods instead of constructors</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev2">Item 2: Consider a builder when faced with many constructor parameters</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev3">Item 3: Enforce the singleton property with a private constructor or an enum type</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev4">Item 4: Enforce noninstantiability with a private constructor</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev5">Item 5: Prefer dependency injection to hardwiring resources</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev6">Item 6: Avoid creating unnecessary objects</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev7">Item 7: Eliminate obsolete object references</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev8">Item 8: Avoid finalizers and cleaners</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev9">Item 9: Prefer try-with-resources to try-finally</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch3.xhtml#ch3">3 Methods Common to All Objects</a>
      <ul>
        <li>
          <a href="ch3.xhtml#lev10">Item 10: Obey the general contract when overriding equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev11">Item 11: Always override hashCode when you override equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev12">Item 12: Always override toString</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev13">Item 13: Override clone judiciously</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev14">Item 14: Consider implementing Comparable</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch4.xhtml#ch4">4 Classes and Interfaces</a>
      <ul>
        <li>
          <a href="ch4.xhtml#lev15">Item 15: Minimize the accessibility of classes and members</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev16">Item 16: In public classes, use accessor methods, not public fields</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev17">Item 17: Minimize mutability</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev18">Item 18: Favor composition over inheritance</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev19">Item 19: Design and document for inheritance or else prohibit it</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev20">Item 20: Prefer interfaces to abstract classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev21">Item 21: Design interfaces for posterity</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev22">Item 22: Use interfaces only to define types</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev23">Item 23: Prefer class hierarchies to tagged classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev24">Item 24: Favor static member classes over nonstatic</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev25">Item 25: Limit source files to a single top-level class</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch5.xhtml#ch5">5 Generics</a>
      <ul>
        <li>
          <a href="ch5.xhtml#lev26">Item 26: Don’t use raw types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev27">Item 27: Eliminate unchecked warnings</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev28">Item 28: Prefer lists to arrays</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev29">Item 29: Favor generic types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev30">Item 30: Favor generic methods</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev31">Item 31: Use bounded wildcards to increase API flexibility</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev32">Item 32: Combine generics and varargs judiciously</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev33">Item 33: Consider typesafe heterogeneous containers</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch6.xhtml#ch6">6 Enums and Annotations</a>
      <ul>
        <li>
          <a href="ch6.xhtml#lev34">Item 34: Use enums instead of int constants</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev35">Item 35: Use instance fields instead of ordinals</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev36">Item 36: Use EnumSet instead of bit fields</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev37">Item 37: Use EnumMap instead of ordinal indexing</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev38">Item 38: Emulate extensible enums with interfaces</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev39">Item 39: Prefer annotations to naming patterns</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev40">Item 40: Consistently use the Override annotation</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev41">Item 41: Use marker interfaces to define types</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch7.xhtml#ch7">7 Lambdas and Streams</a>
      <ul>
        <li>
          <a href="ch7.xhtml#lev42">Item 42: Prefer lambdas to anonymous classes</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev43">Item 43: Prefer method references to lambdas</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev44">Item 44: Favor the use of standard functional interfaces</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev45">Item 45: Use streams judiciously</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev46">Item 46: Prefer side-effect-free functions in streams</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev47">Item 47: Prefer Collection to Stream as a return type</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev48">Item 48: Use caution when making streams parallel</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch8.xhtml#ch8">8 Methods</a>
      <ul>
        <li>
          <a href="ch8.xhtml#lev49">Item 49: Check parameters for validity</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev50">Item 50: Make defensive copies when needed</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev51">Item 51: Design method signatures carefully</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev52">Item 52: Use overloading judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev53">Item 53: Use varargs judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev54">Item 54: Return empty collections or arrays, not nulls</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev55">Item 55: Return optionals judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev56">Item 56: Write doc comments for all exposed API elements</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch9.xhtml#ch9">9 General Programming</a>
      <ul>
        <li>
          <a href="ch9.xhtml#lev57">Item 57: Minimize the scope of local variables</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev58">Item 58: Prefer for-each loops to traditional for loops</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev59">Item 59: Know and use the libraries</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev60">Item 60: Avoid float and double if exact answers are required</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev61">Item 61: Prefer primitive types to boxed primitives</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev62">Item 62: Avoid strings where other types are more appropriate</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev63">Item 63: Beware the performance of string concatenation</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev64">Item 64: Refer to objects by their interfaces</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev65">Item 65: Prefer interfaces to reflection</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev66">Item 66: Use native methods judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev67">Item 67: Optimize judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev68">Item 68: Adhere to generally accepted naming conventions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch10.xhtml#ch10">10 Exceptions</a>
      <ul>
        <li>
          <a href="ch10.xhtml#lev69">Item 69: Use exceptions only for exceptional conditions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev70">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev71">Item 71: Avoid unnecessary use of checked exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev72">Item 72: Favor the use of standard exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev73">Item 73: Throw exceptions appropriate to the abstraction</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev74">Item 74: Document all exceptions thrown by each method</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev75">Item 75: Include failure-capture information in detail messages</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev76">Item 76: Strive for failure atomicity</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev77">Item 77: Don’t ignore exceptions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch11.xhtml#ch11">11 Concurrency</a>
      <ul>
        <li>
          <a href="ch11.xhtml#lev78">Item 78: Synchronize access to shared mutable data</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev79">Item 79: Avoid excessive synchronization</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev80">Item 80: Prefer executors, tasks, and streams to threads</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev81">Item 81: Prefer concurrency utilities to wait and notify</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev82">Item 82: Document thread safety</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev83">Item 83: Use lazy initialization judiciously</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev84">Item 84: Don’t depend on the thread scheduler</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch12.xhtml#ch12">12 Serialization</a>
      <ul>
        <li>
          <a href="ch12.xhtml#lev85">Item 85: Prefer alternatives to Java serialization</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev86">Item 86: Implement Serializable with great caution</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev87">Item 87: Consider using a custom serialized form</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev88">Item 88: Write readObject methods defensively</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev89">Item 89: For instance control, prefer enum types to readResolve</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev90">Item 90: Consider serialization proxies instead of serialized instances</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="app.xhtml#app">Items Corresponding to Second Edition</a>
    </li>
    <li>
      <a href="ref.xhtml#ref">References</a>
    </li>
    <li>
      <a href="index.xhtml#index">Index</a>
    </li>
    <li>
      <a href="ch2_images.xhtml#ch2_images">Code Snippets</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="ch1.xhtml" class="calibreAPrev">previous page
</a>
    

    <a href="../../../4bgup-l038f.html" class="calibreAHome">start
</a>

    
      <a href="ch3.xhtml" class="calibreANext">next page
</a>
    
  </div>

</div>

</body>
</html>
