<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>

    <title>Chapter 11 Concurrency</title>
    <meta content="urn:uuid:232c2138-be82-42d4-8a6b-b460372314a4" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../../4bgup-l038f.html">Effective Java, Third Edition
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    Joshua Bloch

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="ch10.xhtml" class="calibreAPrev">previous page
</a>
        

        
          <a href="ch12.xhtml" class="calibreANext">next page
</a>
        
      </div>
    

    
      
      <h2 class="h1" id="ch11"><span epub:type="pagebreak" id="page_311" class="calibre15"></span>Chapter 11. Concurrency
      </h2>
      
      <p class="noindent"><strong class="calibre11">T</strong><small class="calibre13">HREADS</small> allow multiple activities to proceed concurrently. Concurrent programming is harder
         than single-threaded programming, because more things can go wrong, and failures can
         be hard to reproduce. You can’t avoid concurrency. It is inherent in the platform
         and a requirement if you are to obtain good performance from multicore processors,
         which are now ubiquitous. This chapter contains advice to help you write clear, correct,
         well-documented concurrent programs.
      </p>
      
      <h3 class="h2"><a id="lev78" class="calibre4"></a><strong class="calibre10">Item 78: Synchronize access to shared mutable data</strong></h3>
      
      <p class="noindent">The <code class="calibre12">synchronized</code> keyword ensures that only a single thread can execute a method or block at one time.
         Many programmers think of synchronization solely as a means of <em class="calibre9">mutual exclusion</em>, to prevent an object from being seen in an inconsistent state by one thread while
         it’s being modified by another. In this view, an object is created in a consistent
         state (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>) and locked by the methods that access it. These methods observe the state and optionally
         cause a <em class="calibre9">state transition</em>, transforming the object from one consistent state to another. Proper use of synchronization
         guarantees that no method will ever observe the object in an inconsistent state.
      </p>
      
      <p class="indent">This view is correct, but it’s only half the story. Without synchronization, one thread’s
         changes might not be visible to other threads. Not only does synchronization prevent
         threads from observing an object in an inconsistent state, but it ensures that each
         thread entering a synchronized method or block sees the effects of all previous modifications
         that were guarded by the same lock.
      </p>
      
      <p class="indent">The language specification guarantees that reading or writing a variable is <em class="calibre9">atomic</em> unless the variable is of type <code class="calibre12">long</code> or <code class="calibre12">double</code> [JLS, 17.4, 17.7]. In other words, reading a variable other than a <code class="calibre12">long</code> or <code class="calibre12">double</code> is guaranteed to return a value that was stored into that variable by some thread,
         even if multiple threads modify the variable concurrently and without synchronization.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_312"></span>You may hear it said that to improve performance, you should dispense with synchronization
         when reading or writing atomic data. This advice is dangerously wrong. While the language
         specification guarantees that a thread will not see an arbitrary value when reading
         a field, it does not guarantee that a value written by one thread will be visible
         to another. <strong class="calibre11">Synchronization is required for reliable communication between threads as well as
            for mutual exclusion.</strong> This is due to a part of the language specification known as the <em class="calibre9">memory model</em>, which specifies when and how changes made by one thread become visible to others
         [JLS, 17.4; Goetz06, 16].
      </p>
      
      <p class="indent">The consequences of failing to synchronize access to shared mutable data can be dire
         even if the data is atomically readable and writable. Consider the task of stopping
         one thread from another. The libraries provide the <code class="calibre12">Thread.stop</code> method, but this method was deprecated long ago because it is inherently <em class="calibre9">unsafe</em>—its use can result in data corruption. <strong class="calibre11">Do not use</strong> <code class="calibre12"><strong class="calibre11">Thread.stop</strong></code><strong class="calibre11">.</strong> A recommended way to stop one thread from another is to have the first thread poll
         a <code class="calibre12">boolean</code> field that is initially <code class="calibre12">false</code> but can be set to <code class="calibre12">true</code> by the second thread to indicate that the first thread is to stop itself. Because
         reading and writing a <code class="calibre12">boolean</code> field is atomic, some programmers dispense with synchronization when accessing the
         field:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex1a" id="pch11ex1" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Broken! - How long would you expect this program to run?</strong><br class="calibre7"/>
         public class StopThread {<br class="calibre7"/>
             private static boolean stopRequested;<br class="calibre7"/>
         <br class="calibre7"/>
             public static void main(String[] args)<br class="calibre7"/>
                     throws InterruptedException {<br class="calibre7"/>
                 Thread backgroundThread = new Thread(() -&gt; {<br class="calibre7"/>
                     int i = 0;<br class="calibre7"/>
                     while (!stopRequested)<br class="calibre7"/>
                         i++;<br class="calibre7"/>
                 });<br class="calibre7"/>
                 backgroundThread.start();<br class="calibre7"/>
         <br class="calibre7"/>
                 TimeUnit.SECONDS.sleep(1);<br class="calibre7"/>
                 stopRequested = true;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">You might expect this program to run for about a second, after which the main thread
         sets <code class="calibre12">stopRequested</code> to <code class="calibre12">true</code>, causing the background thread’s loop to terminate. On my machine, however, the program
         <em class="calibre9">never</em> terminates: the background thread loops forever!
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_313"></span>The problem is that in the absence of synchronization, there is no guarantee as to
         when, if ever, the background thread will see the change in the value of <code class="calibre12">stopRequested</code> made by the main thread. In the absence of synchronization, it’s quite acceptable
         for the virtual machine to transform this code:
      </p>
      
      <p class="pre">    while (!stopRequested)<br class="calibre7"/>
                 i++;
      </p>
      
      <p class="noindent">into this code:</p>
      
      <p class="pre">if (!stopRequested)<br class="calibre7"/>
             while (true)<br class="calibre7"/>
                 i++;
      </p>
      
      <p class="noindent">This optimization is known as <em class="calibre9">hoisting</em>, and it is precisely what the OpenJDK Server VM does. The result is a <em class="calibre9">liveness failure</em>: the program fails to make progress. One way to fix the problem is to synchronize
         access to the <code class="calibre12">stopRequested</code> field. This program terminates in about one second, as expected:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex2a" id="pch11ex2" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Properly synchronized cooperative thread termination</strong><br class="calibre7"/>
         public class StopThread {<br class="calibre7"/>
             private static boolean stopRequested;<br class="calibre7"/>
         <br class="calibre7"/>
             <strong class="calibre11">private static synchronized void requestStop() {</strong><br class="calibre7"/>
                 <strong class="calibre11">stopRequested = true;</strong><br class="calibre7"/>
             <strong class="calibre11">}</strong><br class="calibre7"/>
         <br class="calibre7"/>
             <strong class="calibre11">private static synchronized boolean stopRequested() {</strong><br class="calibre7"/>
                 <strong class="calibre11">return stopRequested;</strong><br class="calibre7"/>
             <strong class="calibre11">}</strong><br class="calibre7"/>
         <br class="calibre7"/>
             public static void main(String[] args)<br class="calibre7"/>
                     throws InterruptedException {<br class="calibre7"/>
                 Thread backgroundThread = new Thread(() -&gt; {<br class="calibre7"/>
                     int i = 0;<br class="calibre7"/>
                     while (!<strong class="calibre11">stopRequested()</strong>)<br class="calibre7"/>
                         i++;<br class="calibre7"/>
                 });<br class="calibre7"/>
                 backgroundThread.start();<br class="calibre7"/>
         <br class="calibre7"/>
                 TimeUnit.SECONDS.sleep(1);<br class="calibre7"/>
                 <strong class="calibre11">requestStop()</strong>;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_314"></span>Note that both the write method (<code class="calibre12">requestStop</code>) and the read method (<code class="calibre12">stop-Requested</code>) are synchronized. It is <em class="calibre9">not</em> sufficient to synchronize only the write method! <strong class="calibre11">Synchronization is not guaranteed to work unless both read and write operations are
            synchronized.</strong> Occasionally a program that synchronizes only writes (or reads) may <em class="calibre9">appear</em> to work on some machines, but in this case, appearances are deceiving.
      </p>
      
      <p class="indent">The actions of the synchronized methods in <code class="calibre12">StopThread</code> would be atomic even without synchronization. In other words, the synchronization
         on these methods is used <em class="calibre9">solely</em> for its communication effects, not for mutual exclusion. While the cost of synchronizing
         on each iteration of the loop is small, there is a correct alternative that is less
         verbose and whose performance is likely to be better. The locking in the second version
         of <code class="calibre12">StopThread</code> can be omitted if <code class="calibre12">stopRequested</code> is declared volatile. While the <code class="calibre12">volatile</code> modifier performs no mutual exclusion, it guarantees that any thread that reads the
         field will see the most recently written value:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex3a" id="pch11ex3" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Cooperative thread termination with a volatile field</strong><br class="calibre7"/>
         public class StopThread {<br class="calibre7"/>
             private static <strong class="calibre11">volatile</strong> boolean stopRequested;<br class="calibre7"/>
         <br class="calibre7"/>
             public static void main(String[] args)<br class="calibre7"/>
                     throws InterruptedException {<br class="calibre7"/>
                 Thread backgroundThread = new Thread(() -&gt; {<br class="calibre7"/>
                     int i = 0;<br class="calibre7"/>
                     while (!stopRequested)<br class="calibre7"/>
                         i++;<br class="calibre7"/>
                 });<br class="calibre7"/>
                 backgroundThread.start();<br class="calibre7"/>
         <br class="calibre7"/>
                 TimeUnit.SECONDS.sleep(1);<br class="calibre7"/>
                 stopRequested = true;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">You do have to be careful when using <code class="calibre12">volatile</code>. Consider the following method, which is supposed to generate serial numbers:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex4a" id="pch11ex4" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Broken - requires synchronization!</strong><br class="calibre7"/>
         private static volatile int nextSerialNumber = 0;<br class="calibre7"/>
         <br class="calibre7"/>
         public static int generateSerialNumber() {<br class="calibre7"/>
             return nextSerialNumber++;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_315"></span>The intent of the method is to guarantee that every invocation returns a unique value
         (so long as there are no more than 2<sup class="calibre14">32</sup> invocations). The method’s state consists of a single atomically accessible field,
         <code class="calibre12">nextSerialNumber</code>, and all possible values of this field are legal. Therefore, no synchronization is
         necessary to protect its invariants. Still, the method won’t work properly without
         synchronization.
      </p>
      
      <p class="indent">The problem is that the increment operator (<code class="calibre12">++</code>) is not atomic. It performs <em class="calibre9">two</em> operations on the <code class="calibre12">nextSerialNumber</code> field: first it reads the value, and then it writes back a new value, equal to the
         old value plus one. If a second thread reads the field between the time a thread reads
         the old value and writes back a new one, the second thread will see the same value
         as the first and return the same serial number. This is a <em class="calibre9">safety failure</em>: the program computes the wrong results.
      </p>
      
      <p class="indent">One way to fix <code class="calibre12">generateSerialNumber</code> is to add the <code class="calibre12">synchronized</code> modifier to its declaration. This ensures that multiple invocations won’t be interleaved
         and that each invocation of the method will see the effects of all previous invocations.
         Once you’ve done that, you can and should remove the <code class="calibre12">volatile</code> modifier from <code class="calibre12">nextSerialNumber</code>. To bulletproof the method, use <code class="calibre12">long</code> instead of <code class="calibre12">int</code>, or throw an exception if <code class="calibre12">nextSerialNumber</code> is about to wrap.
      </p>
      
      <p class="indent">Better still, follow the advice in <a href="ch9.xhtml#lev59" class="calibre8">Item 59</a> and use the class <code class="calibre12">AtomicLong</code>, which is part of <code class="calibre12">java.util.concurrent.atomic</code>. This package provides primitives for lock-free, thread-safe programming on single
         variables. While volatile provides only the communication effects of synchronization,
         this package also provides atomicity. This is exactly what we want for <code class="calibre12">generateSerialNumber</code>, and it is likely to outperform the synchronized version:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex5a" id="pch11ex5" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Lock-free synchronization with java.util.concurrent.atomic</strong><br class="calibre7"/>
         private static final AtomicLong nextSerialNum = new AtomicLong();<br class="calibre7"/>
         <br class="calibre7"/>
         public static long generateSerialNumber() {<br class="calibre7"/>
             return nextSerialNum.getAndIncrement();<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The best way to avoid the problems discussed in this item is not to share mutable
         data. Either share immutable data (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>) or don’t share at all. In other words, <strong class="calibre11">confine mutable data to a single thread.</strong> If you adopt this policy, it is important to document it so that the policy is maintained
         as your program evolves. It is also important to have a deep understanding of the
         frameworks and libraries you’re using because they may introduce threads that you
         are unaware of.
      </p>
      
      <p class="indent">It is acceptable for one thread to modify a data object for a while and then to share
         it with other threads, synchronizing only the act of sharing the object reference.
         Other threads can then read the object without further synchronization, <span epub:type="pagebreak" id="page_316"></span>so long as it isn’t modified again. Such objects are said to be <em class="calibre9">effectively immutable</em> [<a href="ref.xhtml#rGoetz06" class="calibre8">Goetz06, 3.5.4</a>]. Transferring such an object reference from one thread to others is called <em class="calibre9">safe publication</em> [<a href="ref.xhtml#rGoetz06" class="calibre8">Goetz06, 3.5.3</a>]. There are many ways to safely publish an object reference: you can store it in
         a static field as part of class initialization; you can store it in a volatile field,
         a final field, or a field that is accessed with normal locking; or you can put it
         into a concurrent collection (<a href="ch11.xhtml#lev81" class="calibre8">Item 81</a>).
      </p>
      
      <p class="indent">In summary, <strong class="calibre11">when multiple threads share mutable data, each thread that reads or writes the data
            must perform synchronization.</strong> In the absence of synchronization, there is no guarantee that one thread’s changes
         will be visible to another thread. The penalties for failing to synchronize shared
         mutable data are liveness and safety failures. These failures are among the most difficult
         to debug. They can be intermittent and timing-dependent, and program behavior can
         vary radically from one VM to another. If you need only inter-thread communication,
         and not mutual exclusion, the <code class="calibre12">volatile</code> modifier is an acceptable form of synchronization, but it can be tricky to use correctly.
      </p>
      
      <h3 class="h2"><a id="lev79" class="calibre4"></a><span epub:type="pagebreak" id="page_317" class="calibre15"></span><strong class="calibre10">Item 79: Avoid excessive synchronization</strong></h3>
      
      <p class="noindent">Item 78 warns of the dangers of insufficient synchronization. This item concerns the
         opposite problem. Depending on the situation, excessive synchronization can cause
         reduced performance, deadlock, or even nondeterministic behavior.
      </p>
      
      <p class="indent"><strong class="calibre11">To avoid liveness and safety failures, never cede control to the client within a synchronized
            method or block.</strong> In other words, inside a synchronized region, do not invoke a method that is designed
         to be overridden, or one provided by a client in the form of a function object (<a href="ch4.xhtml#lev24" class="calibre8">Item 24</a>). From the perspective of the class with the synchronized region, such methods are
         <em class="calibre9">alien</em>. The class has no knowledge of what the method does and has no control over it. Depending
         on what an alien method does, calling it from a synchronized region can cause exceptions,
         deadlocks, or data corruption.
      </p>
      
      <p class="indent">To make this concrete, consider the following class, which implements an <em class="calibre9">observable</em> set wrapper. It allows clients to subscribe to notifications when elements are added
         to the set. This is the <em class="calibre9">Observer</em> pattern [<a href="ref.xhtml#rGamma95" class="calibre8">Gamma95</a>]. For brevity’s sake, the class does not provide notifications when elements are
         removed from the set, but it would be a simple matter to provide them. This class
         is implemented atop the reusable <code class="calibre12">ForwardingSet</code> from <a href="ch4.xhtml#lev18" class="calibre8">Item 18</a> (page 90):
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex6a" id="pch11ex6" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Broken - invokes alien method from synchronized block!</strong><br class="calibre7"/>
         public class ObservableSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {<br class="calibre7"/>
             public ObservableSet(Set&lt;E&gt; set) { super(set); }<br class="calibre7"/>
         <br class="calibre7"/>
             private final List&lt;SetObserver&lt;E&gt;&gt; observers<br class="calibre7"/>
                     = new ArrayList&lt;&gt;();<br class="calibre7"/>
         <br class="calibre7"/>
             public void addObserver(SetObserver&lt;E&gt; observer) {<br class="calibre7"/>
                 synchronized(observers) {<br class="calibre7"/>
                     observers.add(observer);<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public boolean removeObserver(SetObserver&lt;E&gt; observer) {<br class="calibre7"/>
                 synchronized(observers) {<br class="calibre7"/>
                     return observers.remove(observer);<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private void notifyElementAdded(E element) {<br class="calibre7"/>
                 <strong class="calibre11">synchronized(observers) {</strong><br class="calibre7"/>
                     for (SetObserver&lt;E&gt; observer : observers)<br class="calibre7"/>
                         <strong class="calibre11">observer.added(this, element);</strong><br class="calibre7"/>
                 <strong class="calibre11">}</strong><br class="calibre7"/>
             }<br class="calibre7"/>
         <span epub:type="pagebreak" id="page_318"></span>
         <br class="calibre7"/>
             @Override public boolean add(E element) {<br class="calibre7"/>
                 boolean added = super.add(element);<br class="calibre7"/>
                 if (added)<br class="calibre7"/>
                     notifyElementAdded(element);<br class="calibre7"/>
                 return added;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             @Override public boolean addAll(Collection&lt;? extends E&gt; c) {<br class="calibre7"/>
                 boolean result = false;<br class="calibre7"/>
                 for (E element : c)<br class="calibre7"/>
                     result |= add(element);  // Calls notifyElementAdded<br class="calibre7"/>
                 return result;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Observers subscribe to notifications by invoking the <code class="calibre12">addObserver</code> method and unsubscribe by invoking the <code class="calibre12">removeObserver</code> method. In both cases, an instance of this <em class="calibre9">callback</em> interface is passed to the method.
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex7a" id="pch11ex7" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">@FunctionalInterface public interface SetObserver&lt;E&gt; {<br class="calibre7"/>
             // Invoked when an element is added to the observable set<br class="calibre7"/>
             void added(ObservableSet&lt;E&gt; set, E element);<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">This interface is structurally identical to <code class="calibre12">BiConsumer&lt;ObservableSet&lt;E&gt;,E&gt;</code>. We chose to define a custom functional interface because the interface and method
         names make the code more readable and because the interface could evolve to incorporate
         multiple callbacks. That said, a reasonable argument could also be made for using
         <code class="calibre12">BiConsumer</code> (<a href="ch7.xhtml#lev44" class="calibre8">Item 44</a>).
      </p>
      
      <p class="indent">On cursory inspection, <code class="calibre12">ObservableSet</code> appears to work fine. For example, the following program prints the numbers from
         <code class="calibre12">0</code> through <code class="calibre12">99</code>:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex8a" id="pch11ex8" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public static void main(String[] args) {<br class="calibre7"/>
             ObservableSet&lt;Integer&gt; set =<br class="calibre7"/>
                     new ObservableSet&lt;&gt;(new HashSet&lt;&gt;());<br class="calibre7"/>
         <br class="calibre7"/>
             set.addObserver((s, e) -&gt; System.out.println(e));<br class="calibre7"/>
         <br class="calibre7"/>
             for (int i = 0; i &lt; 100; i++)<br class="calibre7"/>
                 set.add(i);<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Now let’s try something a bit fancier. Suppose we replace the <code class="calibre12">addObserver</code> call with one that passes an observer that prints the <code class="calibre12">Integer</code> value that was added to the set and removes itself if the value is <code class="calibre12">23</code>:
      </p>
      <span epub:type="pagebreak" id="page_319"></span>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex9a" id="pch11ex9" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">set.addObserver(new SetObserver&lt;&gt;() {<br class="calibre7"/>
             public void added(ObservableSet&lt;Integer&gt; s, Integer e) {<br class="calibre7"/>
                 System.out.println(e);<br class="calibre7"/>
                 <strong class="calibre11">if (e == 23)</strong><br class="calibre7"/>
                     <strong class="calibre11">s.removeObserver(this);</strong><br class="calibre7"/>
             }<br class="calibre7"/>
         });
      </p>
      
      <p class="noindent">Note that this call uses an anonymous class instance in place of the lambda used in
         the previous call. That is because the function object needs to pass itself to <code class="calibre12">s.removeObserver</code>, and lambdas cannot access themselves (<a href="ch7.xhtml#lev42" class="calibre8">Item 42</a>).
      </p>
      
      <p class="indent">You might expect the program to print the numbers <code class="calibre12">0</code> through <code class="calibre12">23</code>, after which the observer would unsubscribe and the program would terminate silently.
         In fact, it prints these numbers and then throws a <code class="calibre12">ConcurrentModificationException</code>. The problem is that <code class="calibre12">notifyElementAdded</code> is in the process of iterating over the <code class="calibre12">observers</code> list when it invokes the observer’s <code class="calibre12">added</code> method. The <code class="calibre12">added</code> method calls the observable set’s <code class="calibre12">removeObserver</code> method, which in turn calls the method <code class="calibre12">observers.remove</code>. Now we’re in trouble. We are trying to remove an element from a list in the midst
         of iterating over it, which is illegal. The iteration in the <code class="calibre12">notifyElementAdded</code> method is in a synchronized block to prevent concurrent modification, but it doesn’t
         prevent the iterating thread itself from calling back into the observable set and
         modifying its <code class="calibre12">observers</code> list.
      </p>
      
      <p class="indent">Now let’s try something odd: let’s write an observer that tries to unsubscribe, but
         instead of calling <code class="calibre12">removeObserver</code> directly, it engages the services of another thread to do the deed. This observer
         uses an <em class="calibre9">executor service</em> (<a href="ch11.xhtml#lev80" class="calibre8">Item 80</a>):
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex10a" id="pch11ex10" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Observer that uses a background thread needlessly</strong><br class="calibre7"/>
         set.addObserver(new SetObserver&lt;&gt;() {<br class="calibre7"/>
            public void added(ObservableSet&lt;Integer&gt; s, Integer e) {<br class="calibre7"/>
               System.out.println(e);<br class="calibre7"/>
               if (e == 23) {<br class="calibre7"/>
                  ExecutorService exec =<br class="calibre7"/>
                        Executors.newSingleThreadExecutor();<br class="calibre7"/>
                  try {<br class="calibre7"/>
                     exec.submit(() -&gt; s.removeObserver(this)).get();<br class="calibre7"/>
                  } catch (ExecutionException | InterruptedException ex) {<br class="calibre7"/>
                     throw new AssertionError(ex);<br class="calibre7"/>
                  } finally {<br class="calibre7"/>
                     exec.shutdown();<br class="calibre7"/>
                  }<br class="calibre7"/>
               }<br class="calibre7"/>
            }<br class="calibre7"/>
         });
      </p>
      
      <p class="noindent"><span epub:type="pagebreak" id="page_320"></span>Incidentally, note that this program catches two different exception types in one
         catch clause. This facility, informally known as <em class="calibre9">multi-catch</em>, was added in Java 7. It can greatly increase the clarity and reduce the size of
         programs that behave the same way in response to multiple exception types.
      </p>
      
      <p class="indent">When we run this program, we don’t get an exception; we get a deadlock. The background
         thread calls <code class="calibre12">s.removeObserver</code>, which attempts to lock <code class="calibre12">observers</code>, but it can’t acquire the lock, because the main thread already has the lock. All
         the while, the main thread is waiting for the background thread to finish removing
         the observer, which explains the deadlock.
      </p>
      
      <p class="indent">This example is contrived because there is no reason for the observer to use a background
         thread to unsubscribe itself, but the problem is real. Invoking alien methods from
         within synchronized regions has caused many deadlocks in real systems, such as GUI
         toolkits.
      </p>
      
      <p class="indent">In both of the previous examples (the exception and the deadlock) we were lucky. The
         resource that was guarded by the synchronized region (<code class="calibre12">observers</code>) was in a consistent state when the alien method (<code class="calibre12">added</code>) was invoked. Suppose you were to invoke an alien method from a synchronized region
         while the invariant protected by the synchronized region was temporarily invalid.
         Because locks in the Java programming language are <em class="calibre9">reentrant</em>, such calls won’t deadlock. As in the first example, which resulted in an exception,
         the calling thread already holds the lock, so the thread will succeed when it tries
         to reacquire the lock, even though another conceptually unrelated operation is in
         progress on the data guarded by the lock. The consequences of such a failure can be
         catastrophic. In essence, the lock has failed to do its job. Reentrant locks simplify
         the construction of multithreaded object-oriented programs, but they can turn liveness
         failures into safety failures.
      </p>
      
      <p class="indent">Luckily, it is usually not too hard to fix this sort of problem by moving alien method
         invocations out of synchronized blocks. For the <code class="calibre12">notifyElementAdded</code> method, this involves taking a “snapshot” of the <code class="calibre12">observers</code> list that can then be safely traversed without a lock. With this change, both of
         the previous examples run without exception or deadlock:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex11a" id="pch11ex11" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Alien method moved outside of synchronized block - open calls</strong><br class="calibre7"/>
         private void notifyElementAdded(E element) {<br class="calibre7"/>
             List&lt;SetObserver&lt;E&gt;&gt; snapshot = null;<br class="calibre7"/>
             synchronized(observers) {<br class="calibre7"/>
                 snapshot = new ArrayList&lt;&gt;(observers);<br class="calibre7"/>
             }<br class="calibre7"/>
             for (SetObserver&lt;E&gt; observer : snapshot)<br class="calibre7"/>
                 observer.added(this, element);<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_321"></span>In fact, there’s a better way to move the alien method invocations out of the synchronized
         block. The libraries provide a <em class="calibre9">concurrent collection</em> (<a href="ch11.xhtml#lev81" class="calibre8">Item 81</a>) known as <code class="calibre12">CopyOnWriteArrayList</code> that is tailor-made for this purpose. This <code class="calibre12">List</code> implementation is a variant of <code class="calibre12">ArrayList</code> in which all modification operations are implemented by making a fresh copy of the
         entire underlying array. Because the internal array is never modified, iteration requires
         no locking and is very fast. For most uses, the performance of <code class="calibre12">CopyOnWriteArrayList</code> would be atrocious, but it’s perfect for observer lists, which are rarely modified
         and often traversed.
      </p>
      
      <p class="indent">The <code class="calibre12">add</code> and <code class="calibre12">addAll</code> methods of <code class="calibre12">ObservableSet</code> need not be changed if the list is modified to use <code class="calibre12">CopyOnWriteArrayList</code>. Here is how the remainder of the class looks. Notice that there is no explicit synchronization
         whatsoever:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex12a" id="pch11ex12" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Thread-safe observable set with CopyOnWriteArrayList</strong><br class="calibre7"/>
         private final List&lt;SetObserver&lt;E&gt;&gt; observers =<br class="calibre7"/>
                 new CopyOnWriteArrayList&lt;&gt;();<br class="calibre7"/>
         <br class="calibre7"/>
         public void addObserver(SetObserver&lt;E&gt; observer) {<br class="calibre7"/>
             observers.add(observer);<br class="calibre7"/>
         }<br class="calibre7"/>
         <br class="calibre7"/>
         public boolean removeObserver(SetObserver&lt;E&gt; observer) {<br class="calibre7"/>
             return observers.remove(observer);<br class="calibre7"/>
         }<br class="calibre7"/>
         <br class="calibre7"/>
         private void notifyElementAdded(E element) {<br class="calibre7"/>
             for (SetObserver&lt;E&gt; observer : observers)<br class="calibre7"/>
                 observer.added(this, element);<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">An alien method invoked outside of a synchronized region is known as an <em class="calibre9">open call</em> [<a href="ref.xhtml#rGoetz06" class="calibre8">Goetz06, 10.1.4</a>]. Besides preventing failures, open calls can greatly increase concurrency. An alien
         method might run for an arbitrarily long period. If the alien method were invoked
         from a synchronized region, other threads would be denied access to the protected
         resource unnecessarily.
      </p>
      
      <p class="indent"><strong class="calibre11">As a rule, you should do as little work as possible inside synchronized regions.</strong> Obtain the lock, examine the shared data, transform it as necessary, and drop the
         lock. If you must perform some time-consuming activity, find a way to move it out
         of the synchronized region without violating the guidelines in <a href="ch11.xhtml#lev78" class="calibre8">Item 78</a>.
      </p>
      
      <p class="indent">The first part of this item was about correctness. Now let’s take a brief look at
         performance. While the cost of synchronization has plummeted since the early days
         of Java, it is more important than ever not to oversynchronize. In a multicore world,
         the real cost of excessive synchronization is not the CPU time spent getting locks;
         it is <em class="calibre9">contention</em>: the lost opportunities for parallelism and the delays <span epub:type="pagebreak" id="page_322"></span>imposed by the need to ensure that every core has a consistent view of memory. Another
         hidden cost of oversynchronization is that it can limit the VM’s ability to optimize
         code execution.
      </p>
      
      <p class="indent">If you are writing a mutable class, you have two options: you can omit all synchronization
         and allow the client to synchronize externally if concurrent use is desired, or you
         can synchronize internally, making the class <em class="calibre9">thread-safe</em> (<a href="ch11.xhtml#lev82" class="calibre8">Item 82</a>). You should choose the latter option only if you can achieve significantly higher
         concurrency with internal synchronization than you could by having the client lock
         the entire object externally. The collections in <code class="calibre12">java.util</code> (with the exception of the obsolete <code class="calibre12">Vector</code> and <code class="calibre12">Hashtable</code>) take the former approach, while those in <code class="calibre12">java.util.concurrent</code> take the latter (<a href="ch11.xhtml#lev81" class="calibre8">Item 81</a>).
      </p>
      
      <p class="indent">In the early days of Java, many classes violated these guidelines. For example, <code class="calibre12">StringBuffer</code> instances are almost always used by a single thread, yet they perform internal synchronization.
         It is for this reason that <code class="calibre12">StringBuffer</code> was supplanted by <code class="calibre12">StringBuilder</code>, which is just an unsynchronized <code class="calibre12">StringBuffer</code>. Similarly, it’s a large part of the reason that the thread-safe pseudorandom number
         generator in <code class="calibre12">java.util.Random</code> was supplanted by the unsynchronized implementation in <code class="calibre12">java.util.concurrent.ThreadLocalRandom</code>. When in doubt, do <em class="calibre9">not</em> synchronize your class, but document that it is not thread-safe.
      </p>
      
      <p class="indent">If you do synchronize your class internally, you can use various techniques to achieve
         high concurrency, such as lock splitting, lock striping, and nonblocking concurrency
         control. These techniques are beyond the scope of this book, but they are discussed
         elsewhere [<a href="ref.xhtml#rGoetz06" class="calibre8">Goetz06</a>, Herlihy08].
      </p>
      
      <p class="indent">If a method modifies a static field and there is any possibility that the method will
         be called from multiple threads, you <em class="calibre9">must</em> synchronize access to the field internally (unless the class can tolerate nondeterministic
         behavior). It is not possible for a multithreaded client to perform external synchronization
         on such a method, because unrelated clients can invoke the method without synchronization.
         The field is essentially a global variable even if it is private because it can be
         read and modified by unrelated clients. The <code class="calibre12">nextSerialNumber</code> field used by the method <code class="calibre12">generateSerialNumber</code> in <a href="ch11.xhtml#lev78" class="calibre8">Item 78</a> exemplifies this situation.
      </p>
      
      <p class="indent">In summary, to avoid deadlock and data corruption, never call an alien method from
         within a synchronized region. More generally, keep the amount of work that you do
         from within synchronized regions to a minimum. When you are designing a mutable class,
         think about whether it should do its own synchronization. In the multicore era, it
         is more important than ever not to oversynchronize. Synchronize your class internally
         only if there is a good reason to do so, and document your decision clearly (<a href="ch11.xhtml#lev82" class="calibre8">Item 82</a>).
      </p>
      
      <h3 class="h2"><a id="lev80" class="calibre4"></a><span epub:type="pagebreak" id="page_323" class="calibre15"></span><strong class="calibre10">Item 80: Prefer executors, tasks, and streams to threads</strong></h3>
      
      <p class="noindent">The first edition of this book contained code for a simple <em class="calibre9">work queue</em> [<a href="ref.xhtml#rBloch01" class="calibre8">Bloch01</a>, <a href="ch8.xhtml#lev49" class="calibre8">Item 49</a>]. This class allowed clients to enqueue work for asynchronous processing by a background
         thread. When the work queue was no longer needed, the client could invoke a method
         to ask the background thread to terminate itself gracefully after completing any work
         that was already on the queue. The implementation was little more than a toy, but
         even so, it required a full page of subtle, delicate code, of the sort that is prone
         to safety and liveness failures if you don’t get it just right. Luckily, there is
         no reason to write this sort of code anymore.
      </p>
      
      <p class="indent">By the time the second edition of this book came out, <code class="calibre12">java.util.concurrent</code> had been added to Java. This package contains an <em class="calibre9">Executor Framework</em>, which is a flexible interface-based task execution facility. Creating a work queue
         that is better in every way than the one in the first edition of this book requires
         but a single line of code:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex13a" id="pch11ex13" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">ExecutorService exec = Executors.newSingleThreadExecutor();</p>
      
      <p class="noindent">Here is how to submit a runnable for execution:</p>
      
      <p class="codep1">exec.execute(runnable);</p>
      
      <p class="noindent">And here is how to tell the executor to terminate gracefully (if you fail to do this,
         it is likely that your VM will not exit):
      </p>
      
      <p class="codep1">exec.shutdown();</p>
      
      <p class="indent">You can do <em class="calibre9">many</em> more things with an executor service. For example, you can wait for a particular
         task to complete (with the <code class="calibre12">get</code> method, as shown in <a href="ch11.xhtml#lev79" class="calibre8">Item 79</a>, page 319), you can wait for any or all of a collection of tasks to complete (using
         the <code class="calibre12">invokeAny</code> or <code class="calibre12">invokeAll</code> methods), you can wait for the executor service to terminate (using the <code class="calibre12">awaitTermination</code> method), you can retrieve the results of tasks one by one as they complete (using
         an <code class="calibre12">ExecutorCompletionService</code>), you can schedule tasks to run at a particular time or to run periodically (using
         a <code class="calibre12">ScheduledThreadPoolExecutor</code>), and so on.
      </p>
      
      <p class="indent">If you want more than one thread to process requests from the queue, simply call a
         different static factory that creates a different kind of executor service called
         a <em class="calibre9">thread pool</em>. You can create a thread pool with a fixed or variable number of threads. The <code class="calibre12">java.util.concurrent.Executors</code> class contains static factories that provide most of the executors you’ll ever need.
         If, however, you want something <span epub:type="pagebreak" id="page_324"></span>out of the ordinary, you can use the <code class="calibre12">ThreadPoolExecutor</code> class directly. This class lets you configure nearly every aspect of a thread pool’s
         operation.
      </p>
      
      <p class="indent">Choosing the executor service for a particular application can be tricky. For a small
         program, or a lightly loaded server, <code class="calibre12">Executors.newCachedThreadPool</code> is generally a good choice because it demands no configuration and generally “does
         the right thing.” But a cached thread pool is not a good choice for a heavily loaded
         production server! In a cached thread pool, submitted tasks are not queued but immediately
         handed off to a thread for execution. If no threads are available, a new one is created.
         If a server is so heavily loaded that all of its CPUs are fully utilized and more
         tasks arrive, more threads will be created, which will only make matters worse. Therefore,
         in a heavily loaded production server, you are much better off using <code class="calibre12">Executors.newFixedThreadPool</code>, which gives you a pool with a fixed number of threads, or using the <code class="calibre12">ThreadPoolExecutor</code> class directly, for maximum control.
      </p>
      
      <p class="indent">Not only should you refrain from writing your own work queues, but you should generally
         refrain from working directly with threads. When you work directly with threads, a
         <code class="calibre12">Thread</code> serves as both a unit of work and the mechanism for executing it. In the executor
         framework, the unit of work and the execution mechanism are separate. The key abstraction
         is the unit of work, which is the <em class="calibre9">task</em>. There are two kinds of tasks: <code class="calibre12">Runnable</code> and its close cousin, <code class="calibre12">Callable</code> (which is like <code class="calibre12">Runnable</code>, except that it returns a value and can throw arbitrary exceptions). The general
         mechanism for executing tasks is the <em class="calibre9">executor service</em>. If you think in terms of tasks and let an executor service execute them for you,
         you gain the flexibility to select an appropriate execution policy to meet your needs
         and to change the policy if your needs change. In essence, the Executor Framework
         does for execution what the Collections Framework did for aggregation.
      </p>
      
      <p class="indent">In Java 7, the Executor Framework was extended to support fork-join tasks, which are
         run by a special kind of executor service known as a fork-join pool. A fork-join task,
         represented by a <code class="calibre12">ForkJoinTask</code> instance, may be split up into smaller subtasks, and the threads comprising a <code class="calibre12">ForkJoinPool</code> not only process these tasks but “steal” tasks from one another to ensure that all
         threads remain busy, resulting in higher CPU utilization, higher throughput, and lower
         latency. Writing and tuning fork-join tasks is tricky. Parallel streams (<a href="ch7.xhtml#lev48" class="calibre8">Item 48</a>) are written atop fork join pools and allow you to take advantage of their performance
         benefits with little effort, assuming they are appropriate for the task at hand.
      </p>
      
      <p class="indent">A complete treatment of the Executor Framework is beyond the scope of this book, but
         the interested reader is directed to <em class="calibre9">Java Concurrency in Practice</em> [<a href="ref.xhtml#rGoetz06" class="calibre8">Goetz06</a>].
      </p>
      
      <h3 class="h2"><a id="lev81" class="calibre4"></a><span epub:type="pagebreak" id="page_325" class="calibre15"></span><strong class="calibre10">Item 81: Prefer concurrency utilities to</strong> <code class="calibre19"><strong class="calibre10">wait</strong></code> <strong class="calibre10">and</strong> <code class="calibre19"><strong class="calibre10">notify</strong></code></h3>
      
      <p class="noindent">The first edition of this book devoted an item to the correct use of <code class="calibre12">wait</code> and <code class="calibre12">notify</code> [<a href="ref.xhtml#rBloch01" class="calibre8">Bloch01</a>, <a href="ch8.xhtml#lev50" class="calibre8">Item 50</a>]. Its advice is still valid and is summarized at end of this item, but this advice
         is far less important than it once was. This is because there is far less reason to
         use <code class="calibre12">wait</code> and <code class="calibre12">notify</code>. Since Java 5, the platform has provided higher-level concurrency utilities that
         do the sorts of things you formerly had to hand-code atop <code class="calibre12">wait</code> and <code class="calibre12">notify</code>. <strong class="calibre11">Given the difficulty of using</strong> <code class="calibre12"><strong class="calibre11">wait</strong></code> <strong class="calibre11">and</strong> <code class="calibre12"><strong class="calibre11">notify</strong></code> <strong class="calibre11">correctly, you should use the higher-level concurrency utilities instead.</strong></p>
      
      <p class="indent">The higher-level utilities in <code class="calibre12">java.util.concurrent</code> fall into three categories: the Executor Framework, which was covered briefly in
         <a href="ch11.xhtml#lev80" class="calibre8">Item 80</a>; concurrent collections; and synchronizers. Concurrent collections and synchronizers
         are covered briefly in this item.
      </p>
      
      <p class="indent">The concurrent collections are high-performance concurrent implementations of standard
         collection interfaces such as <code class="calibre12">List</code>, <code class="calibre12">Queue</code>, and <code class="calibre12">Map</code>. To provide high concurrency, these implementations manage their own synchronization
         internally (<a href="ch11.xhtml#lev79" class="calibre8">Item 79</a>). Therefore, <strong class="calibre11">it is impossible to exclude concurrent activity from a concurrent collection; locking
            it will only slow the program.</strong></p>
      
      <p class="indent">Because you can’t exclude concurrent activity on concurrent collections, you can’t
         atomically compose method invocations on them either. Therefore, concurrent collection
         interfaces were outfitted with <em class="calibre9">state-dependent modify operations</em>, which combine several primitives into a single atomic operation. These operations
         proved sufficiently useful on concurrent collections that they were added to the corresponding
         collection interfaces in Java 8, using default methods (<a href="ch4.xhtml#lev21" class="calibre8">Item 21</a>).
      </p>
      
      <p class="indent">For example, <code class="calibre12">Map</code>’s <code class="calibre12">putIfAbsent(key, value)</code> method inserts a mapping for a key if none was present and returns the previous value
         associated with the key, or <code class="calibre12">null</code> if there was none. This makes it easy to implement thread-safe canonicalizing maps.
         This method simulates the behavior of <code class="calibre12">String.intern</code>:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex14a" id="pch11ex14" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Concurrent canonicalizing map atop ConcurrentMap - not optimal</strong><br class="calibre7"/>
         private static final ConcurrentMap&lt;String, String&gt; map =<br class="calibre7"/>
                 new ConcurrentHashMap&lt;&gt;();<br class="calibre7"/>
         <br class="calibre7"/>
         public static String intern(String s) {<br class="calibre7"/>
             String previousValue = map.putIfAbsent(s, s);<br class="calibre7"/>
             return previousValue == null ? s : previousValue;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">In fact, you can do even better. <code class="calibre12">ConcurrentHashMap</code> is optimized for retrieval operations, such as <code class="calibre12">get</code>. Therefore, it is worth invoking <code class="calibre12">get</code> initially and calling <code class="calibre12">putIfAbsent</code> only if <code class="calibre12">get</code> indicates that it is necessary:
      </p>
      <span epub:type="pagebreak" id="page_326"></span>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex15a" id="pch11ex15" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Concurrent canonicalizing map atop ConcurrentMap - faster!</strong><br class="calibre7"/>
         public static String intern(String s) {<br class="calibre7"/>
             String result = map.get(s);<br class="calibre7"/>
             if (result == null) {<br class="calibre7"/>
                 result = map.putIfAbsent(s, s);<br class="calibre7"/>
                 if (result == null)<br class="calibre7"/>
                     result = s;<br class="calibre7"/>
             }<br class="calibre7"/>
             return result;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Besides offering excellent concurrency, <code class="calibre12">ConcurrentHashMap</code> is very fast. On my machine, the <code class="calibre12">intern</code> method above is over six times faster than <code class="calibre12">String.intern</code> (but keep in mind that <code class="calibre12">String.intern</code> must employ some strategy to keep from leaking memory in a long-lived application).
         Concurrent collections make synchronized collections largely obsolete. For example,
         <strong class="calibre11">use</strong> <code class="calibre12"><strong class="calibre11">ConcurrentHashMap</strong></code> <strong class="calibre11">in preference to</strong> <code class="calibre12"><strong class="calibre11">Collections.synchronizedMap</strong></code><strong class="calibre11">.</strong> Simply replacing synchronized maps with concurrent maps can dramatically increase
         the performance of concurrent applications.
      </p>
      
      <p class="indent">Some of the collection interfaces were extended with <em class="calibre9">blocking operations,</em> which wait (or <em class="calibre9">block</em>) until they can be successfully performed. For example, <code class="calibre12">BlockingQueue</code> extends <code class="calibre12">Queue</code> and adds several methods, including <code class="calibre12">take</code>, which removes and returns the head element from the queue, waiting if the queue
         is empty. This allows blocking queues to be used for <em class="calibre9">work queues</em> (also known as <em class="calibre9">producer-consumer queues</em>), to which one or more <em class="calibre9">producer threads</em> enqueue work items and from which one or more <em class="calibre9">consumer threads</em> dequeue and process items as they become available. As you’d expect, most <code class="calibre12">ExecutorService</code> implementations, including <code class="calibre12">ThreadPoolExecutor</code>, use a <code class="calibre12">BlockingQueue</code> (<a href="ch11.xhtml#lev80" class="calibre8">Item 80</a>).
      </p>
      
      <p class="indent"><em class="calibre9">Synchronizers</em> are objects that enable threads to wait for one another, allowing them to coordinate
         their activities. The most commonly used synchronizers are <code class="calibre12">CountDownLatch</code> and <code class="calibre12">Semaphore</code>. Less commonly used are <code class="calibre12">CyclicBarrier</code> and <code class="calibre12">Exchanger</code>. The most powerful synchronizer is <code class="calibre12">Phaser</code>.
      </p>
      
      <p class="indent">Countdown latches are single-use barriers that allow one or more threads to wait for
         one or more other threads to do something. The sole constructor for <code class="calibre12">CountDownLatch</code> takes an <code class="calibre12">int</code> that is the number of times the <code class="calibre12">countDown</code> method must be invoked on the latch before all waiting threads are allowed to proceed.
      </p>
      
      <p class="indent">It is surprisingly easy to build useful things atop this simple primitive. For example,
         suppose you want to build a simple framework for timing the concurrent execution of
         an action. This framework consists of a single method that takes an executor to execute
         the action, a concurrency level representing the number of actions to be executed
         concurrently, and a runnable representing the action. All of <span epub:type="pagebreak" id="page_327"></span>the worker threads ready themselves to run the action before the timer thread starts
         the clock. When the last worker thread is ready to run the action, the timer thread
         “fires the starting gun,” allowing the worker threads to perform the action. As soon
         as the last worker thread finishes performing the action, the timer thread stops the
         clock. Implementing this logic directly on top of <code class="calibre12">wait</code> and <code class="calibre12">notify</code> would be messy to say the least, but it is surprisingly straightforward on top of
         <code class="calibre12">CountDownLatch</code>:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex16a" id="pch11ex16" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Simple framework for timing concurrent execution</strong><br class="calibre7"/>
         public static long time(Executor executor, int concurrency,<br class="calibre7"/>
                     Runnable action) throws InterruptedException {<br class="calibre7"/>
             CountDownLatch ready = new CountDownLatch(concurrency);<br class="calibre7"/>
             CountDownLatch start = new CountDownLatch(1);<br class="calibre7"/>
             CountDownLatch done  = new CountDownLatch(concurrency);<br class="calibre7"/>
         <br class="calibre7"/>
             for (int i = 0; i &lt; concurrency; i++) {<br class="calibre7"/>
                 executor.execute(() -&gt; {<br class="calibre7"/>
                     ready.countDown(); // Tell timer we're ready<br class="calibre7"/>
                     try {<br class="calibre7"/>
                         start.await(); // Wait till peers are ready<br class="calibre7"/>
                         action.run();<br class="calibre7"/>
                     } catch (InterruptedException e) {<br class="calibre7"/>
                         Thread.currentThread().interrupt();<br class="calibre7"/>
                     } finally {<br class="calibre7"/>
                         done.countDown();  // Tell timer we're done<br class="calibre7"/>
                     }<br class="calibre7"/>
                 });<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             ready.await();     // Wait for all workers to be ready<br class="calibre7"/>
             long startNanos = System.nanoTime();<br class="calibre7"/>
             start.countDown(); // And they're off!<br class="calibre7"/>
             done.await();      // Wait for all workers to finish<br class="calibre7"/>
             return System.nanoTime() - startNanos;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Note that the method uses three countdown latches. The first, <code class="calibre12">ready</code>, is used by worker threads to tell the timer thread when they’re ready. The worker
         threads then wait on the second latch, which is <code class="calibre12">start</code>. When the last worker thread invokes <code class="calibre12">ready.countDown</code>, the timer thread records the start time and invokes <code class="calibre12">start.countDown</code>, allowing all of the worker threads to proceed. Then the timer thread waits on the
         third latch, <code class="calibre12">done</code>, until the last of the worker threads finishes running the action and calls <code class="calibre12">done.countDown</code>. As soon as this happens, the timer thread awakens and records the end time.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_328"></span>A few more details bear noting. The executor passed to the <code class="calibre12">time</code> method must allow for the creation of at least as many threads as the given concurrency
         level, or the test will never complete. This is known as a <em class="calibre9">thread starvation deadlock</em> [Goetz06, 8.1.1]. If a worker thread catches an <code class="calibre12">InterruptedException</code>, it reasserts the interrupt using the idiom <code class="calibre12">Thread.currentThread().interrupt()</code> and returns from its <code class="calibre12">run</code> method. This allows the executor to deal with the interrupt as it sees fit. Note
         that <code class="calibre12">System.nanoTime</code> is used to time the activity. <strong class="calibre11">For interval timing, always use</strong> <code class="calibre12"><strong class="calibre11">System.nanoTime</strong></code> <strong class="calibre11">rather than</strong> <code class="calibre12"><strong class="calibre11">System.currentTimeMillis</strong></code><strong class="calibre11">.</strong> <code class="calibre12">System.nanoTime</code> is both more accurate and more precise and is unaffected by adjustments to the system’s
         real-time clock. Finally, note that the code in this example won’t yield accurate
         timings unless <code class="calibre12">action</code> does a fair amount of work, say a second or more. Accurate microbenchmarking is notoriously
         hard and is best done with the aid of a specialized framework such as jmh [<a href="ref.xhtml#rJMH" class="calibre8">JMH</a>].
      </p>
      
      <p class="indent">This item only scratches the surface of what you can do with the concurrency utilities.
         For example, the three countdown latches in the previous example could be replaced
         by a single <code class="calibre12">CyclicBarrier</code> or <code class="calibre12">Phaser</code> instance. The resulting code would be a bit more concise but perhaps more difficult
         to understand.
      </p>
      
      <p class="indent">While you should always use the concurrency utilities in preference to <code class="calibre12">wait</code> and <code class="calibre12">notify</code>, you might have to maintain legacy code that uses <code class="calibre12">wait</code> and <code class="calibre12">notify</code>. The <code class="calibre12">wait</code> method is used to make a thread wait for some condition. It must be invoked inside
         a synchronized region that locks the object on which it is invoked. Here is the standard
         idiom for using the <code class="calibre12">wait</code> method:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex17a" id="pch11ex17" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// The standard idiom for using the wait method</strong><br class="calibre7"/>
         synchronized (obj) {<br class="calibre7"/>
             while (&lt;condition does not hold&gt;)<br class="calibre7"/>
                 obj.wait(); // (Releases lock, and reacquires on wakeup)<br class="calibre7"/>
             ... // Perform action appropriate to condition<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent"><strong class="calibre11">Always use the wait loop idiom to invoke the</strong> <code class="calibre12"><strong class="calibre11">wait</strong></code> <strong class="calibre11">method; never invoke it outside of a loop.</strong> The loop serves to test the condition before and after waiting.
      </p>
      
      <p class="indent">Testing the condition before waiting and skipping the wait if the condition already
         holds are necessary to ensure liveness. If the condition already holds and the <code class="calibre12">notify</code> (or <code class="calibre12">notifyAll</code>) method has already been invoked before a thread waits, there is no guarantee that
         the thread will <em class="calibre9">ever</em> wake from the wait.
      </p>
      
      <p class="indentb">Testing the condition after waiting and waiting again if the condition does not hold
         are necessary to ensure safety. If the thread proceeds with the action when the condition
         does not hold, it can destroy the invariant guarded by the lock. There are several
         reasons a thread might wake up when the condition does not hold:
      </p>
      
      <p class="bullb"><span epub:type="pagebreak" id="page_329"></span>• Another thread could have obtained the lock and changed the guarded state between
         the time a thread invoked <code class="calibre12">notify</code> and the waiting thread woke up.
      </p>
      
      <p class="bullb">• Another thread could have invoked <code class="calibre12">notify</code> accidentally or maliciously when the condition did not hold. Classes expose themselves
         to this sort of mischief by waiting on publicly accessible objects. Any <code class="calibre12">wait</code> in a synchronized method of a publicly accessible object is susceptible to this problem.
      </p>
      
      <p class="bullb">• The notifying thread could be overly “generous” in waking waiting threads. For example,
         the notifying thread might invoke <code class="calibre12">notifyAll</code> even if only some of the waiting threads have their condition satisfied.
      </p>
      
      <p class="bullb">• The waiting thread could (rarely) wake up in the absence of a notify. This is known
         as a <em class="calibre9">spurious wakeup</em> [<a href="ref.xhtml#rPOSIX" class="calibre8">POSIX, 11.4.3.6.1</a>; <a href="ref.xhtml#rJava9-api" class="calibre8">Java9-api</a>].
      </p>
      
      <p class="indent">A related issue is whether to use <code class="calibre12">notify</code> or <code class="calibre12">notifyAll</code> to wake waiting threads. (Recall that <code class="calibre12">notify</code> wakes a single waiting thread, assuming such a thread exists, and <code class="calibre12">notifyAll</code> wakes all waiting threads.) It is sometimes said that you should <em class="calibre9">always</em> use <code class="calibre12">notifyAll</code>. This is reasonable, conservative advice. It will always yield correct results because
         it guarantees that you’ll wake the threads that need to be awakened. You may wake
         some other threads, too, but this won’t affect the correctness of your program. These
         threads will check the condition for which they’re waiting and, finding it false,
         will continue waiting.
      </p>
      
      <p class="indent">As an optimization, you may choose to invoke <code class="calibre12">notify</code> instead of <code class="calibre12">notifyAll</code> if all threads that could be in the wait-set are waiting for the same condition and
         only one thread at a time can benefit from the condition becoming true.
      </p>
      
      <p class="indent">Even if these preconditions are satisfied, there may be cause to use <code class="calibre12">notifyAll</code> in place of <code class="calibre12">notify</code>. Just as placing the <code class="calibre12">wait</code> invocation in a loop protects against accidental or malicious notifications on a
         publicly accessible object, using <code class="calibre12">notifyAll</code> in place of <code class="calibre12">notify</code> protects against accidental or malicious waits by an unrelated thread. Such waits
         could otherwise “swallow” a critical notification, leaving its intended recipient
         waiting indefinitely.
      </p>
      
      <p class="indent">In summary, using <code class="calibre12">wait</code> and <code class="calibre12">notify</code> directly is like programming in “concurrency assembly language,” as compared to the
         higher-level language provided by <code class="calibre12">java.util.concurrent</code>. <strong class="calibre11">There is seldom, if ever, a reason to use</strong> <code class="calibre12"><strong class="calibre11">wait</strong></code> <strong class="calibre11">and</strong> <code class="calibre12"><strong class="calibre11">notify</strong></code> <strong class="calibre11">in new code.</strong> If you maintain code that uses <code class="calibre12">wait</code> and <code class="calibre12">notify</code>, make sure that it always invokes <code class="calibre12">wait</code> from within a <code class="calibre12">while</code> loop using the standard idiom. The <code class="calibre12">notifyAll</code> method should generally be used in preference to <code class="calibre12">notify</code>. If <code class="calibre12">notify</code> is used, great care must be taken to ensure liveness.
      </p>
      
      <h3 class="h2"><a id="lev82" class="calibre4"></a><span epub:type="pagebreak" id="page_330" class="calibre15"></span><strong class="calibre10">Item 82: Document thread safety</strong></h3>
      
      <p class="noindent">How a class behaves when its methods are used concurrently is an important part of
         its contract with its clients. If you fail to document this aspect of a class’s behavior,
         its users will be forced to make assumptions. If these assumptions are wrong, the
         resulting program may perform insufficient synchronization (<a href="ch11.xhtml#lev78" class="calibre8">Item 78</a>) or excessive synchronization (<a href="ch11.xhtml#lev79" class="calibre8">Item 79</a>). In either case, serious errors may result.
      </p>
      
      <p class="indent">You may hear it said that you can tell if a method is thread-safe by looking for the
         <code class="calibre12">synchronized</code> modifier in its documentation. This is wrong on several counts. In normal operation,
         Javadoc does not include the <code class="calibre12">synchronized</code> modifier in its output, and with good reason. <strong class="calibre11">The presence of the</strong> <code class="calibre12"><strong class="calibre11">synchronized</strong></code> <strong class="calibre11">modifier in a method declaration is an implementation detail, not a part of its API.</strong> It does not reliably indicate that a method is thread-safe.
      </p>
      
      <p class="indentb">Moreover, the claim that the presence of the <code class="calibre12">synchronized</code> modifier is sufficient to document thread safety embodies the misconception that
         thread safety is an all-or-nothing property. In fact, there are several levels of
         thread safety. <strong class="calibre11">To enable safe concurrent use, a class must clearly document what level of thread
            safety it supports.</strong> The following list summarizes levels of thread safety. It is not exhaustive but covers
         the common cases:
      </p>
      
      <p class="bullb">• <strong class="calibre11">Immutable</strong>—Instances of this class appear constant. No external synchronization is necessary.
         Examples include <code class="calibre12">String</code>, <code class="calibre12">Long</code>, and <code class="calibre12">BigInteger</code> (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>).
      </p>
      
      <p class="bullb">• <strong class="calibre11">Unconditionally thread-safe</strong>—Instances of this class are mutable, but the class has sufficient internal synchronization
         that its instances can be used concurrently without the need for any external synchronization.
         Examples include <code class="calibre12">AtomicLong</code> and <code class="calibre12">ConcurrentHashMap</code>.
      </p>
      
      <p class="bullb">• <strong class="calibre11">Conditionally thread-safe</strong>—Like unconditionally thread-safe, except that some methods require external synchronization
         for safe concurrent use. Examples include the collections returned by the <code class="calibre12">Collections.synchronized</code> wrappers, whose iterators require external synchronization.
      </p>
      
      <p class="bullb">• <strong class="calibre11">Not thread-safe</strong>—Instances of this class are mutable. To use them concurrently, clients must surround
         each method invocation (or invocation sequence) with external synchronization of the
         clients’ choosing. Examples include the general-purpose collection implementations,
         such as <code class="calibre12">ArrayList</code> and <code class="calibre12">HashMap</code>.
      </p>
      
      <p class="bullb">• <strong class="calibre11">Thread-hostile</strong>—This class is unsafe for concurrent use even if every method invocation is surrounded
         by external synchronization. Thread hostility usually results from modifying static
         data without synchronization. No one writes a <span epub:type="pagebreak" id="page_331"></span>thread-hostile class on purpose; such classes typically result from the failure to
         consider concurrency. When a class or method is found to be thread-hostile, it is
         typically fixed or deprecated. The <code class="calibre12">generateSerialNumber</code> method in <a href="ch11.xhtml#lev78" class="calibre8">Item 78</a> would be thread-hostile in the absence of internal synchronization, as discussed
         on page 322.
      </p>
      
      <p class="indent">These categories (apart from thread-hostile) correspond roughly to the <em class="calibre9">thread safety annotations</em> in <em class="calibre9">Java Concurrency in Practice</em>, which are <code class="calibre12">Immutable</code>, <code class="calibre12">ThreadSafe</code>, and <code class="calibre12">NotThreadSafe</code> [Goetz06, Appendix A]. The unconditionally and conditionally thread-safe categories
         in the above taxonomy are both covered under the <code class="calibre12">ThreadSafe</code> annotation.
      </p>
      
      <p class="indent">Documenting a conditionally thread-safe class requires care. You must indicate which
         invocation sequences require external synchronization, and which lock (or in rare
         cases, locks) must be acquired to execute these sequences. Typically it is the lock
         on the instance itself, but there are exceptions. For example, the documentation for
         <code class="calibre12">Collections.synchronizedMap</code> says this:
      </p>
      
      <p class="bq">It is imperative that the user manually synchronize on the returned map when iterating
         over any of its collection views:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex18a" id="pch11ex18" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Map&lt;K, V&gt; m = Collections.synchronizedMap(new HashMap&lt;&gt;());<br class="calibre7"/>
         Set&lt;K&gt; s = m.keySet();  // Needn't be in synchronized block<br class="calibre7"/>
             ...<br class="calibre7"/>
         synchronized(m) {  // Synchronizing on m, not s!<br class="calibre7"/>
             for (K key : s)<br class="calibre7"/>
                 key.f();<br class="calibre7"/>
         }
      </p>
      
      <p class="indentb">Failure to follow this advice may result in non-deterministic behavior.</p>
      
      <p class="indent">The description of a class’s thread safety generally belongs in the class’s doc comment,
         but methods with special thread safety properties should describe these properties
         in their own documentation comments. It is not necessary to document the immutability
         of enum types. Unless it is obvious from the return type, static factories must document
         the thread safety of the returned object, as demonstrated by <code class="calibre12">Collections.synchronizedMap</code> (above).
      </p>
      
      <p class="indent">When a class commits to using a publicly accessible lock, it enables clients to execute
         a sequence of method invocations atomically, but this flexibility comes at a price.
         It is incompatible with high-performance internal concurrency control, of the sort
         used by concurrent collections such as <code class="calibre12">ConcurrentHashMap</code>. Also, a client can mount a denial-of-service attack by holding the publicly accessible
         lock for a prolonged period. This can be done accidentally or intentionally.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_332"></span>To prevent this denial-of-service attack, you can use a <em class="calibre9">private lock object</em> instead of using synchronized methods (which imply a publicly accessible lock):
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex19a" id="pch11ex19" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Private lock object idiom - thwarts denial-of-service attack</strong><br class="calibre7"/>
         private final Object lock = new Object();<br class="calibre7"/>
         <br class="calibre7"/>
         public void foo() {<br class="calibre7"/>
             synchronized(lock) {<br class="calibre7"/>
                 ...<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Because the private lock object is inaccessible outside the class, it is impossible
         for clients to interfere with the object’s synchronization. In effect, we are applying
         the advice of <a href="ch4.xhtml#lev15" class="calibre8">Item 15</a> by encapsulating the lock object in the object it synchronizes.
      </p>
      
      <p class="indent">Note that the <code class="calibre12">lock</code> field is declared <code class="calibre12">final</code>. This prevents you from inadvertently changing its contents, which could result in
         catastrophic unsynchronized access (<a href="ch11.xhtml#lev78" class="calibre8">Item 78</a>). We are applying the advice of <a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>, by minimizing the mutability of the <code class="calibre12">lock</code> field. <strong class="calibre11">Lock fields should always be declared</strong> <code class="calibre12"><strong class="calibre11">final</strong></code><strong class="calibre11">.</strong> This is true whether you use an ordinary monitor lock (as shown above) or a lock
         from the <code class="calibre12">java.util.concurrent.locks</code> package.
      </p>
      
      <p class="indent">The private lock object idiom can be used only on <em class="calibre9">unconditionally</em> thread-safe classes. Conditionally thread-safe classes can’t use this idiom because
         they must document which lock their clients are to acquire when performing certain
         method invocation sequences.
      </p>
      
      <p class="indent">The private lock object idiom is particularly well-suited to classes designed for
         inheritance (<a href="ch4.xhtml#lev19" class="calibre8">Item 19</a>). If such a class were to use its instances for locking, a subclass could easily
         and unintentionally interfere with the operation of the base class, or vice versa.
         By using the same lock for different purposes, the subclass and the base class could
         end up “stepping on each other’s toes.” This is not just a theoretical problem; it
         happened with the <code class="calibre12">Thread</code> class [<a href="ref.xhtml#rBloch05" class="calibre8">Bloch05</a>, Puzzle 77].
      </p>
      
      <p class="indent">To summarize, every class should clearly document its thread safety properties with
         a carefully worded prose description or a thread safety annotation. The <code class="calibre12">synchronized</code> modifier plays no part in this documentation. Conditionally thread-safe classes must
         document which method invocation sequences require external synchronization and which
         lock to acquire when executing these sequences. If you write an unconditionally thread-safe
         class, consider using a private lock object in place of synchronized methods. This
         protects you against synchronization interference by clients and subclasses and gives
         you more flexibility to adopt a sophisticated approach to concurrency control in a
         later release.
      </p>
      
      <h3 class="h2"><a id="lev83" class="calibre4"></a><span epub:type="pagebreak" id="page_333" class="calibre15"></span><strong class="calibre10">Item 83: Use lazy initialization judiciously</strong></h3>
      
      <p class="noindent"><em class="calibre9">Lazy initialization</em> is the act of delaying the initialization of a field until its value is needed. If
         the value is never needed, the field is never initialized. This technique is applicable
         to both static and instance fields. While lazy initialization is primarily an optimization,
         it can also be used to break harmful circularities in class and instance initialization
         [<a href="ref.xhtml#rBloch05" class="calibre8">Bloch05</a>, Puzzle 51].
      </p>
      
      <p class="indent">As is the case for most optimizations, the best advice for lazy initialization is
         “don’t do it unless you need to” (<a href="ch9.xhtml#lev67" class="calibre8">Item 67</a>). Lazy initialization is a double-edged sword. It decreases the cost of initializing
         a class or creating an instance, at the expense of increasing the cost of accessing
         the lazily initialized field. Depending on what fraction of these fields eventually
         require initialization, how expensive it is to initialize them, and how often each
         one is accessed once initialized, lazy initialization can (like many “optimizations”)
         actually harm performance.
      </p>
      
      <p class="indent">That said, lazy initialization has its uses. If a field is accessed only on a fraction
         of the instances of a class <em class="calibre9">and</em> it is costly to initialize the field, then lazy initialization may be worthwhile.
         The only way to know for sure is to measure the performance of the class with and
         without lazy initialization.
      </p>
      
      <p class="indent">In the presence of multiple threads, lazy initialization is tricky. If two or more
         threads share a lazily initialized field, it is critical that some form of synchronization
         be employed, or severe bugs can result (<a href="ch11.xhtml#lev78" class="calibre8">Item 78</a>). All of the initialization techniques discussed in this item are thread-safe.
      </p>
      
      <p class="indent"><strong class="calibre11">Under most circumstances, normal initialization is preferable to lazy initialization.</strong> Here is a typical declaration for a normally initialized instance field. Note the
         use of the <code class="calibre12">final</code> modifier (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>):
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex20a" id="pch11ex20" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Normal initialization of an instance field</strong><br class="calibre7"/>
         private final FieldType field = computeFieldValue();
      </p>
      
      <p class="indent"><strong class="calibre11">If you use lazy initialization to break an initialization circularity, use a synchronized
            accessor</strong> because it is the simplest, clearest alternative:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex21a" id="pch11ex21" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Lazy initialization of instance field - synchronized accessor</strong><br class="calibre7"/>
         private FieldType field;<br class="calibre7"/>
         <br class="calibre7"/>
         private <strong class="calibre11">synchronized</strong> FieldType getField() {<br class="calibre7"/>
             if (field == null)<br class="calibre7"/>
                 field = computeFieldValue();<br class="calibre7"/>
             return field;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_334"></span>Both of these idioms (<em class="calibre9">normal initialization</em> and <em class="calibre9">lazy initialization with a synchronized accessor</em>) are unchanged when applied to static fields, except that you add the <code class="calibre12">static</code> modifier to the field and accessor declarations.
      </p>
      
      <p class="indent"><strong class="calibre11">If you need to use lazy initialization for performance on a static field, use the</strong> <em class="calibre9"><strong class="calibre11">lazy initialization holder class idiom</strong></em><strong class="calibre11">.</strong> This idiom exploits the guarantee that a class will not be initialized until it is
         used [JLS, 12.4.1]. Here’s how it looks:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex22a" id="pch11ex22" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Lazy initialization holder class idiom for static fields</strong><br class="calibre7"/>
         private static class FieldHolder {<br class="calibre7"/>
             static final FieldType field = computeFieldValue();<br class="calibre7"/>
         }<br class="calibre7"/>
         <br class="calibre7"/>
         private static FieldType getField() { return FieldHolder.field; }
      </p>
      
      <p class="indent">When <code class="calibre12">getField</code> is invoked for the first time, it reads <code class="calibre12">FieldHolder.field</code> for the first time, causing the initialization of the <code class="calibre12">FieldHolder</code> class. The beauty of this idiom is that the <code class="calibre12">getField</code> method is not synchronized and performs only a field access, so lazy initialization
         adds practically nothing to the cost of access. A typical VM will synchronize field
         access only to initialize the class. Once the class is initialized, the VM patches
         the code so that subsequent access to the field does not involve any testing or synchronization.
      </p>
      
      <p class="indent"><strong class="calibre11">If you need to use lazy initialization for performance on an instance field, use the</strong> <em class="calibre9"><strong class="calibre11">double-check idiom</strong></em><strong class="calibre11">.</strong> This idiom avoids the cost of locking when accessing the field after initialization
         (<a href="ch11.xhtml#lev79" class="calibre8">Item 79</a>). The idea behind the idiom is to check the value of the field twice (hence the name
         <em class="calibre9">double-check</em>): once without locking and then, if the field appears to be uninitialized, a second
         time with locking. Only if the second check indicates that the field is uninitialized
         does the call initialize the field. Because there is no locking once the field is
         initialized, it is <em class="calibre9">critical</em> that the field be declared <code class="calibre12">volatile</code> (<a href="ch11.xhtml#lev78" class="calibre8">Item 78</a>). Here is the idiom:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex23a" id="pch11ex23" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Double-check idiom for lazy initialization of instance fields</strong><br class="calibre7"/>
         private <strong class="calibre11">volatile</strong> FieldType field;<br class="calibre7"/>
         <br class="calibre7"/>
         private FieldType getField() {<br class="calibre7"/>
             FieldType result = field;<br class="calibre7"/>
             if (result == null) {  // First check (no locking)<br class="calibre7"/>
                 synchronized(this) {<br class="calibre7"/>
                     if (field == null)  // Second check (with locking)<br class="calibre7"/>
                         field = result = computeFieldValue();<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
             return result;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_335"></span>This code may appear a bit convoluted. In particular, the need for the local variable
         (<code class="calibre12">result</code>) may be unclear. What this variable does is to ensure that <code class="calibre12">field</code> is read only once in the common case where it’s already initialized. While not strictly
         necessary, this may improve performance and is more elegant by the standards applied
         to low-level concurrent programming. On my machine, the method above is about 1.4
         times as fast as the obvious version without a local variable.
      </p>
      
      <p class="indent">While you can apply the double-check idiom to static fields as well, there is no reason
         to do so: the lazy initialization holder class idiom is a better choice.
      </p>
      
      <p class="indent">Two variants of the double-check idiom bear noting. Occasionally, you may need to
         lazily initialize an instance field that can tolerate repeated initialization. If
         you find yourself in this situation, you can use a variant of the double-check idiom
         that dispenses with the second check. It is, not surprisingly, known as the <em class="calibre9">single-check idiom</em>. Here is how it looks. Note that <code class="calibre12">field</code> is still declared <code class="calibre12">volatile</code>:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex24a" id="pch11ex24" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Single-check idiom - can cause repeated initialization!</strong><br class="calibre7"/>
         private <strong class="calibre11">volatile</strong> FieldType field;<br class="calibre7"/>
         <br class="calibre7"/>
         private FieldType getField() {<br class="calibre7"/>
             FieldType result = field;<br class="calibre7"/>
             if (result == null)<br class="calibre7"/>
                 field = result = computeFieldValue();<br class="calibre7"/>
             return result;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">All of the initialization techniques discussed in this item apply to primitive fields
         as well as object reference fields. When the double-check or single-check idiom is
         applied to a numerical primitive field, the field’s value is checked against <code class="calibre12">0</code> (the default value for numerical primitive variables) rather than <code class="calibre12">null</code>.
      </p>
      
      <p class="indent">If you don’t care whether <em class="calibre9">every</em> thread recalculates the value of a field, and the type of the field is a primitive
         other than <code class="calibre12">long</code> or <code class="calibre12">double</code>, then you may choose to remove the <code class="calibre12">volatile</code> modifier from the field declaration in the single-check idiom. This variant is known
         as the <em class="calibre9">racy single-check idiom.</em> It speeds up field access on some architectures, at the expense of additional initializations
         (up to one per thread that accesses the field). This is definitely an exotic technique,
         not for everyday use.
      </p>
      
      <p class="indent">In summary, you should initialize most fields normally, not lazily. If you must initialize
         a field lazily in order to achieve your performance goals or to break a harmful initialization
         circularity, then use the appropriate lazy initialization technique. For instance
         fields, it is the double-check idiom; for static fields, the lazy initialization holder
         class idiom. For instance fields that can tolerate repeated initialization, you may
         also consider the single-check idiom.
      </p>
      
      <h3 class="h2"><a id="lev84" class="calibre4"></a><span epub:type="pagebreak" id="page_336" class="calibre15"></span><strong class="calibre10">Item 84: Don’t depend on the thread scheduler</strong></h3>
      
      <p class="noindent">When many threads are runnable, the thread scheduler determines which ones get to
         run and for how long. Any reasonable operating system will try to make this determination
         fairly, but the policy can vary. Therefore, well-written programs shouldn’t depend
         on the details of this policy. <strong class="calibre11">Any program that relies on the thread scheduler for correctness or performance is
            likely to be nonportable.</strong></p>
      
      <p class="indent">The best way to write a robust, responsive, portable program is to ensure that the
         average number of <em class="calibre9">runnable</em> threads is not significantly greater than the number of processors. This leaves the
         thread scheduler with little choice: it simply runs the runnable threads till they’re
         no longer runnable. The program’s behavior doesn’t vary too much, even under radically
         different thread-scheduling policies. Note that the number of runnable threads isn’t
         the same as the total number of threads, which can be much higher. Threads that are
         waiting are not runnable.
      </p>
      
      <p class="indent">The main technique for keeping the number of runnable threads low is to have each
         thread do some useful work, and then wait for more. <strong class="calibre11">Threads should not run if they aren’t doing useful work.</strong> In terms of the Executor Framework (<a href="ch11.xhtml#lev80" class="calibre8">Item 80</a>), this means sizing thread pools appropriately [Goetz06, 8.2] and keeping tasks short,
         but not <em class="calibre9">too</em> short, or dispatching overhead will harm performance.
      </p>
      
      <p class="indent">Threads should not <em class="calibre9">busy-wait</em>, repeatedly checking a shared object waiting for its state to change. Besides making
         the program vulnerable to the vagaries of the thread scheduler, busy-waiting greatly
         increases the load on the processor, reducing the amount of useful work that others
         can accomplish. As an extreme example of what <em class="calibre9">not</em> to do, consider this perverse reimplementation of <code class="calibre12">CountDownLatch</code>:
      </p>
      
      <p class="codelink"><a href="ch11_images.xhtml#pch11ex25a" id="pch11ex25" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Awful CountDownLatch implementation - busy-waits incessantly!</strong><br class="calibre7"/>
         public class SlowCountDownLatch {<br class="calibre7"/>
             private int count;<br class="calibre7"/>
         <br class="calibre7"/>
             public SlowCountDownLatch(int count) {<br class="calibre7"/>
                 if (count &lt; 0)<br class="calibre7"/>
                     throw new IllegalArgumentException(count + " &lt; 0");<br class="calibre7"/>
                 this.count = count;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public void await() {<br class="calibre7"/>
                 <strong class="calibre11">while (true) {</strong><br class="calibre7"/>
                     <strong class="calibre11">synchronized(this) {</strong><br class="calibre7"/>
                         <strong class="calibre11">if (count == 0)</strong><br class="calibre7"/>
                             <strong class="calibre11">return;</strong><br class="calibre7"/>
                     <strong class="calibre11">}</strong><br class="calibre7"/>
                 <strong class="calibre11">}</strong><br class="calibre7"/>
             }<br class="calibre7"/>
         <span epub:type="pagebreak" id="page_337"></span>
         <br class="calibre7"/>
             public synchronized void countDown() {<br class="calibre7"/>
                 if (count != 0)<br class="calibre7"/>
                     count--;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">On my machine, <code class="calibre12">SlowCountDownLatch</code> is about ten times slower than Java’s <code class="calibre12">CountDownLatch</code> when 1,000 threads wait on a latch. While this example may seem a bit far-fetched,
         it’s not uncommon to see systems with one or more threads that are unnecessarily runnable.
         Performance and portability are likely to suffer.
      </p>
      
      <p class="indent">When faced with a program that barely works because some threads aren’t getting enough
         CPU time relative to others, <strong class="calibre11">resist the temptation to “fix” the program by putting in calls to</strong> <code class="calibre12"><strong class="calibre11">Thread.yield</strong></code><strong class="calibre11">.</strong> You may succeed in getting the program to work after a fashion, but it will not be
         portable. The same <code class="calibre12">yield</code> invocations that improve performance on one JVM implementation might make it worse
         on a second and have no effect on a third. <code class="calibre12"><strong class="calibre11">Thread.yield</strong></code> <strong class="calibre11">has no testable semantics.</strong> A better course of action is to restructure the application to reduce the number
         of concurrently runnable threads.
      </p>
      
      <p class="indent">A related technique, to which similar caveats apply, is adjusting thread priorities.
         <strong class="calibre11">Thread priorities are among the least portable features of Java.</strong> It is not unreasonable to tune the responsiveness of an application by tweaking a
         few thread priorities, but it is rarely necessary and is not portable. It is unreasonable
         to attempt to solve a serious liveness problem by adjusting thread priorities. The
         problem is likely to return until you find and fix the underlying cause.
      </p>
      
      <p class="indent">In summary, do not depend on the thread scheduler for the correctness of your program.
         The resulting program will be neither robust nor portable. As a corollary, do not
         rely on <code class="calibre12">Thread.yield</code> or thread priorities. These facilities are merely hints to the scheduler. Thread
         priorities may be used sparingly to improve the quality of service of an already working
         program, but they should never be used to “fix” a program that barely works.<span epub:type="pagebreak" id="page_338"></span></p>
      
   
   


  </div>

  
  <div class="calibreToc">
    <h2><a href="../../../4bgup-l038f.html">Table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="cover.xhtml">Cover Page</a>
    </li>
    <li>
      <a href="pref00.xhtml">About This E-Book</a>
    </li>
    <li>
      <a href="title.xhtml">Title Page</a>
    </li>
    <li>
      <a href="copy.xhtml">Copyright Page</a>
    </li>
    <li>
      <a href="ded.xhtml">Dedication</a>
    </li>
    <li>
      <a href="contents.xhtml">Contents</a>
    </li>
    <li>
      <a href="foreword.xhtml#foreword">Foreword</a>
    </li>
    <li>
      <a href="preface.xhtml#preface">Preface</a>
    </li>
    <li>
      <a href="acknowledgments.xhtml#acknowledgments">Acknowledgments</a>
    </li>
    <li>
      <a href="ch1.xhtml#ch1">1 Introduction</a>
    </li>
    <li>
      <a href="ch2.xhtml#ch2">2 Creating and Destroying Objects</a>
      <ul>
        <li>
          <a href="ch2.xhtml#lev1">Item 1: Consider static factory methods instead of constructors</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev2">Item 2: Consider a builder when faced with many constructor parameters</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev3">Item 3: Enforce the singleton property with a private constructor or an enum type</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev4">Item 4: Enforce noninstantiability with a private constructor</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev5">Item 5: Prefer dependency injection to hardwiring resources</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev6">Item 6: Avoid creating unnecessary objects</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev7">Item 7: Eliminate obsolete object references</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev8">Item 8: Avoid finalizers and cleaners</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev9">Item 9: Prefer try-with-resources to try-finally</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch3.xhtml#ch3">3 Methods Common to All Objects</a>
      <ul>
        <li>
          <a href="ch3.xhtml#lev10">Item 10: Obey the general contract when overriding equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev11">Item 11: Always override hashCode when you override equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev12">Item 12: Always override toString</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev13">Item 13: Override clone judiciously</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev14">Item 14: Consider implementing Comparable</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch4.xhtml#ch4">4 Classes and Interfaces</a>
      <ul>
        <li>
          <a href="ch4.xhtml#lev15">Item 15: Minimize the accessibility of classes and members</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev16">Item 16: In public classes, use accessor methods, not public fields</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev17">Item 17: Minimize mutability</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev18">Item 18: Favor composition over inheritance</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev19">Item 19: Design and document for inheritance or else prohibit it</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev20">Item 20: Prefer interfaces to abstract classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev21">Item 21: Design interfaces for posterity</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev22">Item 22: Use interfaces only to define types</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev23">Item 23: Prefer class hierarchies to tagged classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev24">Item 24: Favor static member classes over nonstatic</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev25">Item 25: Limit source files to a single top-level class</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch5.xhtml#ch5">5 Generics</a>
      <ul>
        <li>
          <a href="ch5.xhtml#lev26">Item 26: Don’t use raw types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev27">Item 27: Eliminate unchecked warnings</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev28">Item 28: Prefer lists to arrays</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev29">Item 29: Favor generic types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev30">Item 30: Favor generic methods</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev31">Item 31: Use bounded wildcards to increase API flexibility</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev32">Item 32: Combine generics and varargs judiciously</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev33">Item 33: Consider typesafe heterogeneous containers</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch6.xhtml#ch6">6 Enums and Annotations</a>
      <ul>
        <li>
          <a href="ch6.xhtml#lev34">Item 34: Use enums instead of int constants</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev35">Item 35: Use instance fields instead of ordinals</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev36">Item 36: Use EnumSet instead of bit fields</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev37">Item 37: Use EnumMap instead of ordinal indexing</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev38">Item 38: Emulate extensible enums with interfaces</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev39">Item 39: Prefer annotations to naming patterns</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev40">Item 40: Consistently use the Override annotation</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev41">Item 41: Use marker interfaces to define types</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch7.xhtml#ch7">7 Lambdas and Streams</a>
      <ul>
        <li>
          <a href="ch7.xhtml#lev42">Item 42: Prefer lambdas to anonymous classes</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev43">Item 43: Prefer method references to lambdas</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev44">Item 44: Favor the use of standard functional interfaces</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev45">Item 45: Use streams judiciously</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev46">Item 46: Prefer side-effect-free functions in streams</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev47">Item 47: Prefer Collection to Stream as a return type</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev48">Item 48: Use caution when making streams parallel</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch8.xhtml#ch8">8 Methods</a>
      <ul>
        <li>
          <a href="ch8.xhtml#lev49">Item 49: Check parameters for validity</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev50">Item 50: Make defensive copies when needed</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev51">Item 51: Design method signatures carefully</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev52">Item 52: Use overloading judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev53">Item 53: Use varargs judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev54">Item 54: Return empty collections or arrays, not nulls</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev55">Item 55: Return optionals judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev56">Item 56: Write doc comments for all exposed API elements</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch9.xhtml#ch9">9 General Programming</a>
      <ul>
        <li>
          <a href="ch9.xhtml#lev57">Item 57: Minimize the scope of local variables</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev58">Item 58: Prefer for-each loops to traditional for loops</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev59">Item 59: Know and use the libraries</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev60">Item 60: Avoid float and double if exact answers are required</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev61">Item 61: Prefer primitive types to boxed primitives</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev62">Item 62: Avoid strings where other types are more appropriate</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev63">Item 63: Beware the performance of string concatenation</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev64">Item 64: Refer to objects by their interfaces</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev65">Item 65: Prefer interfaces to reflection</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev66">Item 66: Use native methods judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev67">Item 67: Optimize judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev68">Item 68: Adhere to generally accepted naming conventions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch10.xhtml#ch10">10 Exceptions</a>
      <ul>
        <li>
          <a href="ch10.xhtml#lev69">Item 69: Use exceptions only for exceptional conditions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev70">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev71">Item 71: Avoid unnecessary use of checked exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev72">Item 72: Favor the use of standard exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev73">Item 73: Throw exceptions appropriate to the abstraction</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev74">Item 74: Document all exceptions thrown by each method</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev75">Item 75: Include failure-capture information in detail messages</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev76">Item 76: Strive for failure atomicity</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev77">Item 77: Don’t ignore exceptions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch11.xhtml#ch11">11 Concurrency</a>
      <ul>
        <li>
          <a href="ch11.xhtml#lev78">Item 78: Synchronize access to shared mutable data</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev79">Item 79: Avoid excessive synchronization</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev80">Item 80: Prefer executors, tasks, and streams to threads</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev81">Item 81: Prefer concurrency utilities to wait and notify</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev82">Item 82: Document thread safety</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev83">Item 83: Use lazy initialization judiciously</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev84">Item 84: Don’t depend on the thread scheduler</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch12.xhtml#ch12">12 Serialization</a>
      <ul>
        <li>
          <a href="ch12.xhtml#lev85">Item 85: Prefer alternatives to Java serialization</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev86">Item 86: Implement Serializable with great caution</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev87">Item 87: Consider using a custom serialized form</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev88">Item 88: Write readObject methods defensively</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev89">Item 89: For instance control, prefer enum types to readResolve</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev90">Item 90: Consider serialization proxies instead of serialized instances</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="app.xhtml#app">Items Corresponding to Second Edition</a>
    </li>
    <li>
      <a href="ref.xhtml#ref">References</a>
    </li>
    <li>
      <a href="index.xhtml#index">Index</a>
    </li>
    <li>
      <a href="ch2_images.xhtml#ch2_images">Code Snippets</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="ch10.xhtml" class="calibreAPrev">previous page
</a>
    

    <a href="../../../4bgup-l038f.html" class="calibreAHome">start
</a>

    
      <a href="ch12.xhtml" class="calibreANext">next page
</a>
    
  </div>

</div>

</body>
</html>
