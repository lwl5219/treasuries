<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>

    <title>Chapter 12 Serialization</title>
    <meta content="urn:uuid:232c2138-be82-42d4-8a6b-b460372314a4" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../../4bgup-l038f.html">Effective Java, Third Edition
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    Joshua Bloch

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="ch11.xhtml" class="calibreAPrev">previous page
</a>
        

        
          <a href="app.xhtml" class="calibreANext">next page
</a>
        
      </div>
    

    
      
      <h2 class="h1" id="ch12"><span epub:type="pagebreak" id="page_339" class="calibre15"></span>Chapter 12. Serialization
      </h2>
      
      <p class="noindent"><strong class="calibre11">T</strong><small class="calibre13">HIS</small> chapter concerns <em class="calibre9">object serialization</em>, which is Java’s framework for encoding objects as byte streams (<em class="calibre9">serializing</em>) and reconstructing objects from their encodings (<em class="calibre9">deserializing</em>). Once an object has been serialized, its encoding can be sent from one VM to another
         or stored on disk for later deserialization. This chapter focuses on the dangers of
         serialization and how to minimize them.
      </p>
      
      <h3 class="h2"><a id="lev85" class="calibre4"></a><strong class="calibre10">Item 85: Prefer alternatives to Java serialization</strong></h3>
      
      <p class="noindent">When serialization was added to Java in 1997, it was known to be somewhat risky. The
         approach had been tried in a research language (Modula-3) but never in a production
         language. While the promise of distributed objects with little effort on the part
         of the programmer was appealing, the price was invisible constructors and blurred
         lines between API and implementation, with the potential for problems with correctness,
         performance, security, and maintenance. Proponents believed the benefits outweighed
         the risks, but history has shown otherwise.
      </p>
      
      <p class="indent">The security issues described in previous editions of this book turned out to be every
         bit as serious as some had feared. The vulnerabilities discussed in the early 2000s
         were transformed into serious exploits over the next decade, famously including a
         ransomware attack on the San Francisco Metropolitan Transit Agency Municipal Railway
         (SFMTA Muni) that shut down the entire fare collection system for two days in November
         2016 [<a href="ref.xhtml#rGallagher16" class="calibre8">Gallagher16</a>].
      </p>
      
      <p class="indent">A fundamental problem with serialization is that its <em class="calibre9">attack surface</em> is too big to protect, and constantly growing: Object graphs are deserialized by
         invoking the <code class="calibre12">readObject</code> method on an <code class="calibre12">ObjectInputStream</code>. This method is essentially a magic constructor that can be made to instantiate objects
         of almost any type on the class path, so long as the type implements the <code class="calibre12">Serializable</code> interface. In the process of deserializing a byte stream, this method can execute
         code from any of these types, so the code for <em class="calibre9">all</em> of these types is part of the attack surface.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_340"></span>The attack surface includes classes in the Java platform libraries, in third-party
         libraries such as Apache Commons Collections, and in the application itself. Even
         if you adhere to all of the relevant best practices and succeed in writing serializable
         classes that are invulnerable to attack, your application may still be vulnerable.
         To quote Robert Seacord, technical manager of the CERT Coordination Center:
      </p>
      
      <p class="bq">Java deserialization is a clear and present danger as it is widely used both directly
         by applications and indirectly by Java subsystems such as RMI (Remote Method Invocation),
         JMX (Java Management Extension), and JMS (Java Messaging System). Deserialization
         of untrusted streams can result in remote code execution (RCE), denial-of-service
         (DoS), and a range of other exploits. Applications can be vulnerable to these attacks
         even if they did nothing wrong. [<a href="ref.xhtml#rSeacord17" class="calibre8">Seacord17</a>]
      </p>
      
      <p class="indent">Attackers and security researchers study the serializable types in the Java libraries
         and in commonly used third-party libraries, looking for methods invoked during deserialization
         that perform potentially dangerous activities. Such methods are known as <em class="calibre9">gadgets</em>. Multiple gadgets can be used in concert, to form a <em class="calibre9">gadget chain</em>. From time to time, a gadget chain is discovered that is sufficiently powerful to
         allow an attacker to execute arbitrary native code on the underlying hardware, given
         only the opportunity to submit a carefully crafted byte stream for deserialization.
         This is exactly what happened in the SFMTA Muni attack. This attack was not isolated.
         There have been others, and there will be more.
      </p>
      
      <p class="indent">Without using any gadgets, you can easily mount a denial-of-service attack by causing
         the deserialization of a short stream that requires a long time to deserialize. Such
         streams are known as <em class="calibre9">deserialization bombs</em> [<a href="ref.xhtml#rSvoboda16" class="calibre8">Svoboda16</a>]. Here’s an example by Wouter Coekaerts that uses only hash sets and a string [<a href="ref.xhtml#rCoekaerts15" class="calibre8">Coekaerts15</a>]:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex1a" id="pch12ex1" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Deserialization bomb - deserializing this stream takes forever</strong><br class="calibre7"/>
         static byte[] bomb() {<br class="calibre7"/>
             Set&lt;Object&gt; root = new HashSet&lt;&gt;();<br class="calibre7"/>
             Set&lt;Object&gt; s1 = root;<br class="calibre7"/>
             Set&lt;Object&gt; s2 = new HashSet&lt;&gt;();<br class="calibre7"/>
             for (int i = 0; i &lt; 100; i++) {<br class="calibre7"/>
                 Set&lt;Object&gt; t1 = new HashSet&lt;&gt;();<br class="calibre7"/>
                 Set&lt;Object&gt; t2 = new HashSet&lt;&gt;();<br class="calibre7"/>
                 t1.add("foo"); // Make t1 unequal to t2<br class="calibre7"/>
                 s1.add(t1);  s1.add(t2);<br class="calibre7"/>
                 s2.add(t1);  s2.add(t2);<br class="calibre7"/>
                 s1 = t1;<br class="calibre7"/>
                 s2 = t2;<br class="calibre7"/>
             }<br class="calibre7"/>
             return serialize(root); // Method omitted for brevity<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_341"></span>The object graph consists of 201 <code class="calibre12">HashSet</code> instances, each of which contains 3 or fewer object references. The entire stream
         is 5,744 bytes long, yet the sun would burn out long before you could deserialize
         it. The problem is that deserializing a <code class="calibre12">HashSet</code> instance requires computing the hash codes of its elements. The 2 elements of the
         root hash set are themselves hash sets containing 2 hash-set elements, each of which
         contains 2 hash-set elements, and so on, 100 levels deep. Therefore, deserializing
         the set causes the <code class="calibre12">hashCode</code> method to be invoked over 2<sup class="calibre14">100</sup> times. Other than the fact that the deserialization is taking forever, the deserializer
         has no indication that anything is amiss. Few objects are produced, and the stack
         depth is bounded.
      </p>
      
      <p class="indent">So what can you do defend against these problems? You open yourself up to attack whenever
         you deserialize a byte stream that you don’t trust. <strong class="calibre11">The best way to avoid serialization exploits is never to deserialize anything.</strong> In the words of the computer named Joshua in the 1983 movie <em class="calibre9">WarGames</em>, “the only winning move is not to play.” <strong class="calibre11">There is no reason to use Java serialization in any new system you write.</strong> There are other mechanisms for translating between objects and byte sequences that
         avoid many of the dangers of Java serialization, while offering numerous advantages,
         such as cross-platform support, high performance, a large ecosystem of tools, and
         a broad community of expertise. In this book, we refer to these mechanisms as <em class="calibre9">cross-platform structured-data representations.</em> While others sometimes refer to them as serialization systems, this book avoids that
         usage to prevent confusion with Java serialization.
      </p>
      
      <p class="indent">What these representations have in common is that they’re <em class="calibre9">far</em> simpler than Java serialization. They don’t support automatic serialization and deserialization
         of arbitrary object graphs. Instead, they support simple, structured data-objects
         consisting of a collection of attribute-value pairs. Only a few primitive and array
         data types are supported. This simple abstraction turns out to be sufficient for building
         extremely powerful distributed systems and simple enough to avoid the serious problems
         that have plagued Java serialization since its inception.
      </p>
      
      <p class="indent">The leading cross-platform structured data representations are JSON [<a href="ref.xhtml#rJSON" class="calibre8">JSON</a>] and Protocol Buffers, also known as protobuf [<a href="ref.xhtml#rProtobuf" class="calibre8">Protobuf</a>]. JSON was designed by Douglas Crockford for browser-server communication, and protocol
         buffers were designed by Google for storing and interchanging structured data among
         its servers. Even though these representations are sometimes called <em class="calibre9">language-neutral</em>, JSON was originally developed for JavaScript and protobuf for C++; both representations
         retain vestiges of their origins.
      </p>
      
      <p class="indent">The most significant differences between JSON and protobuf are that JSON is text-based
         and human-readable, whereas protobuf is binary and substantially more <span epub:type="pagebreak" id="page_342"></span>efficient; and that JSON is exclusively a data representation, whereas protobuf offers
         <em class="calibre9">schemas</em> (types) to document and enforce appropriate usage. Although protobuf is more efficient
         than JSON, JSON is extremely efficient for a text-based representation. And while
         protobuf is a binary representation, it does provide an alternative text representation
         for use where human-readability is desired (pbtxt).
      </p>
      
      <p class="indent">If you can’t avoid Java serialization entirely, perhaps because you’re working in
         the context of a legacy system that requires it, your next best alternative is to
         <strong class="calibre11">never deserialize untrusted data.</strong> In particular, you should never accept RMI traffic from untrusted sources. The official
         secure coding guidelines for Java say “Deserialization of untrusted data is inherently
         dangerous and should be avoided.” This sentence is set in large, bold, italic, red
         type, and it is the only text in the entire document that gets this treatment [Java-secure].
      </p>
      
      <p class="indent">If you can’t avoid serialization and you aren’t absolutely certain of the safety of
         the data you’re deserializing, use the object deserialization filtering added in Java
         9 and backported to earlier releases (<code class="calibre12">java.io.ObjectInputFilter</code>). This facility lets you specify a filter that is applied to data streams before
         they’re deserialized. It operates at the class granularity, letting you accept or
         reject certain classes. Accepting classes by default and rejecting a list of potentially
         dangerous ones is known as <em class="calibre9">blacklisting</em>; rejecting classes by default and accepting a list of those that are presumed safe
         is known as <em class="calibre9">whitelisting</em>. <strong class="calibre11">Prefer whitelisting to blacklisting</strong>, as blacklisting only protects you against known threats. A tool called Serial Whitelist
         Application Trainer (SWAT) can be used to automatically prepare a whitelist for your
         application [<a href="ref.xhtml#rSchneider16" class="calibre8">Schneider16</a>]. The filtering facility will also protect you against excessive memory usage, and
         excessively deep object graphs, but it will not protect you against serialization
         bombs like the one shown above.
      </p>
      
      <p class="indent">Unfortunately, serialization is still pervasive in the Java ecosystem. If you are
         maintaining a system that is based on Java serialization, seriously consider migrating
         to a cross-platform structured-data representation, even though this may be a time-consuming
         endeavor. Realistically, you may still find yourself having to write or maintain a
         serializable class. It requires great care to write a serializable class that is correct,
         safe, and efficient. The remainder of this chapter provides advice on when and how
         to do this.
      </p>
      
      <p class="indent">In summary, serialization is dangerous and should be avoided. If you are designing
         a system from scratch, use a cross-platform structured-data representation such as
         JSON or protobuf instead. Do not deserialize untrusted data. If you must do so, use
         object deserialization filtering, but be aware that it is not guaranteed to thwart
         all attacks. Avoid writing serializable classes. If you must do so, exercise great
         caution.
      </p>
      
      <h3 class="h2"><a id="lev86" class="calibre4"></a><span epub:type="pagebreak" id="page_343" class="calibre15"></span><strong class="calibre10">Item 86: Implement</strong> <code class="calibre19"><strong class="calibre10">Serializable</strong></code> <strong class="calibre10">with great caution</strong></h3>
      
      <p class="noindent">Allowing a class’s instances to be serialized can be as simple as adding the words
         <code class="calibre12">implements Serializable</code> to its declaration. Because this is so easy to do, there was a common misconception
         that serialization requires little effort on the part of the programmer. The truth
         is far more complex. While the immediate cost to make a class serializable can be
         negligible, the long-term costs are often substantial.
      </p>
      
      <p class="indent"><strong class="calibre11">A major cost of implementing</strong> <code class="calibre12"><strong class="calibre11">Serializable</strong></code> <strong class="calibre11">is that it decreases the flexibility to change a class’s implementation once it has
            been released.</strong> When a class implements <code class="calibre12">Serializable</code>, its byte-stream encoding (or <em class="calibre9">serialized form</em>) becomes part of its exported API. Once you distribute a class widely, you are generally
         required to support the serialized form forever, just as you are required to support
         all other parts of the exported API. If you do not make the effort to design a <em class="calibre9">custom serialized form</em> but merely accept the default, the serialized form will forever be tied to the class’s
         original internal representation. In other words, if you accept the default serialized
         form, the class’s private and package-private instance fields become part of its exported
         API, and the practice of minimizing access to fields (<a href="ch4.xhtml#lev15" class="calibre8">Item 15</a>) loses its effectiveness as a tool for information hiding.
      </p>
      
      <p class="indent">If you accept the default serialized form and later change a class’s internal representation,
         an incompatible change in the serialized form will result. Clients attempting to serialize
         an instance using an old version of the class and deserialize it using the new one
         (or vice versa) will experience program failures. It is possible to change the internal
         representation while maintaining the original serialized form (using <code class="calibre12">ObjectOutputStream.putFields</code> and <code class="calibre12">ObjectInputStream.readFields</code>), but it can be difficult and leaves visible warts in the source code. If you opt
         to make a class serializable, you should carefully design a high-quality serialized
         form that you’re willing to live with for the long haul (<a href="ch12.xhtml#lev87" class="calibre8">Items 87</a>, <a href="ch12.xhtml#lev90" class="calibre8">90</a>). Doing so will add to the initial cost of development, but it’s worth the effort.
         Even a well-designed serialized form places constraints on the evolution of a class;
         an ill-designed serialized form can be crippling.
      </p>
      
      <p class="indent">A simple example of the constraints on evolution imposed by serializability concerns
         <em class="calibre9">stream unique identifiers</em>, more commonly known as <em class="calibre9">serial version UIDs</em>. Every serializable class has a unique identification number associated with it.
         If you do not specify this number by declaring a static final <code class="calibre12">long</code> field named <code class="calibre12">serialVersionUID</code>, the system automatically generates it at runtime by applying a cryptographic hash
         function (SHA-1) to the structure of the class. This value is affected by the names
         of the class, the interfaces it implements, and most of its members, including synthetic
         members generated by the compiler. If you change <span epub:type="pagebreak" id="page_344"></span>any of these things, for example, by adding a convenience method, the generated serial
         version UID changes. If you fail to declare a serial version UID, compatibility will
         be broken, resulting in an <code class="calibre12">InvalidClassException</code> at runtime.
      </p>
      
      <p class="indent"><strong class="calibre11">A second cost of implementing</strong> <code class="calibre12"><strong class="calibre11">Serializable</strong></code> <strong class="calibre11">is that it increases the likelihood of bugs and security holes (<a href="ch12.xhtml#lev85" class="calibre8">Item 85</a>).</strong> Normally, objects are created with constructors; serialization is an <em class="calibre9">extralinguistic mechanism</em> for creating objects. Whether you accept the default behavior or override it, deserialization
         is a “hidden constructor” with all of the same issues as other constructors. Because
         there is no explicit constructor associated with deserialization, it is easy to forget
         that you must ensure that it guarantees all of the invariants established by the constructors
         and that it does not allow an attacker to gain access to the internals of the object
         under construction. Relying on the default deserialization mechanism can easily leave
         objects open to invariant corruption and illegal access (<a href="ch12.xhtml#lev88" class="calibre8">Item 88</a>).
      </p>
      
      <p class="indent"><strong class="calibre11">A third cost of implementing</strong> <code class="calibre12"><strong class="calibre11">Serializable</strong></code> <strong class="calibre11">is that it increases the testing burden associated with releasing a new version of
            a class.</strong> When a serializable class is revised, it is important to check that it is possible
         to serialize an instance in the new release and deserialize it in old releases, and
         vice versa. The amount of testing required is thus proportional to the product of
         the number of serializable classes and the number of releases, which can be large.
         You must ensure both that the serialization-deserialization process succeeds and that
         it results in a faithful replica of the original object. The need for testing is reduced
         if a custom serialized form is carefully designed when the class is first written
         (<a href="ch12.xhtml#lev87" class="calibre8">Items 87</a>, <a href="ch12.xhtml#lev90" class="calibre8">90</a>).
      </p>
      
      <p class="indent"><strong class="calibre11">Implementing</strong> <code class="calibre12"><strong class="calibre11">Serializable</strong></code> <strong class="calibre11">is not a decision to be undertaken lightly.</strong> It is essential if a class is to participate in a framework that relies on Java serialization
         for object transmission or persistence. Also, it greatly eases the use of a class
         as a component in another class that must implement <code class="calibre12">Serializable</code>. There are, however, many costs associated with implementing <code class="calibre12">Serializable</code>. Each time you design a class, weigh the costs against the benefits. Historically,
         value classes such as <code class="calibre12">BigInteger and Instant</code> implemented <code class="calibre12">Serializable</code>, and collection classes did too. Classes representing active entities, such as thread
         pools, should rarely implement <code class="calibre12">Serializable</code>.
      </p>
      
      <p class="indent"><strong class="calibre11">Classes designed for inheritance (<a href="ch4.xhtml#lev19" class="calibre8">Item 19</a>) should rarely implement</strong> <code class="calibre12"><strong class="calibre11">Serializable</strong></code>, <strong class="calibre11">and interfaces should rarely extend it.</strong> Violating this rule places a substantial burden on anyone who extends the class or
         implements the interface. There are times when it is appropriate to violate the rule.
         For example, if a class or interface exists primarily to participate in a framework
         that requires all participants to implement <code class="calibre12">Serializable</code>, then it may make sense for the class or interface to implement or extend <code class="calibre12">Serializable</code>.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_345"></span>Classes designed for inheritance that do implement <code class="calibre12">Serializable</code> include <code class="calibre12">Throwable</code> and <code class="calibre12">Component</code>. <code class="calibre12">Throwable</code> implements <code class="calibre12">Serializable</code> so RMI can send exceptions from server to client. <code class="calibre12">Component</code> implements <code class="calibre12">Serializable</code> so GUIs can be sent, saved, and restored, but even in the heyday of Swing and AWT,
         this facility was little-used in practice.
      </p>
      
      <p class="indent">If you implement a class with instance fields that is both serializable and extendable,
         there are several risks to be aware of. If there are any invariants on the instance
         field values, it is critical to prevent subclasses from overriding the <code class="calibre12">finalize</code> method, which the class can do by overriding <code class="calibre12">finalize</code> and declaring it final. Otherwise, the class will be susceptible to <em class="calibre9">finalizer attacks (</em>Item 8). Finally, if the class has invariants that would be violated if its instance
         fields were initialized to their default values (zero for integral types, <code class="calibre12">false</code> for <code class="calibre12">boolean</code>, and <code class="calibre12">null</code> for object reference types), you must add this <code class="calibre12">readObjectNoData</code> method:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex2a" id="pch12ex2" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readObjectNoData for stateful extendable serializable classes</strong><br class="calibre7"/>
         private void readObjectNoData() throws InvalidObjectException {<br class="calibre7"/>
             throw new InvalidObjectException("Stream data required");<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">This method was added in Java 4 to cover a corner case involving the addition of a
         serializable superclass to an existing serializable class [Serialization, 3.5].
      </p>
      
      <p class="indent">There is one caveat regarding the decision <em class="calibre9">not</em> to implement <code class="calibre12">Serializable</code>. If a class designed for inheritance is not serializable, it may require extra effort
         to write a serializable subclass. Normal deserialization of such a class requires
         the superclass to have an accessible parameterless constructor [Serialization, 1.10].
         If you don’t provide such a constructor, subclasses are forced to use the serialization
         proxy pattern (<a href="ch12.xhtml#lev90" class="calibre8">Item 90</a>).
      </p>
      
      <p class="indent"><strong class="calibre11">Inner classes (<a href="ch4.xhtml#lev24" class="calibre8">Item 24</a>) should not implement</strong> <code class="calibre12"><strong class="calibre11">Serializable</strong></code><strong class="calibre11">.</strong> They use compiler-generated <em class="calibre9">synthetic fields</em> to store references to <em class="calibre9">enclosing instances</em> and to store values of local variables from enclosing scopes. How these fields correspond
         to the class definition is unspecified, as are the names of anonymous and local classes.
         Therefore, the default serialized form of an inner class is ill-defined. A <em class="calibre9">static member class</em> can, however, implement <code class="calibre12">Serializable</code>.
      </p>
      
      <p class="indent">To summarize, the ease of implementing <code class="calibre12">Serializable</code> is specious. Unless a class is to be used only in a protected environment where versions
         will never have to interoperate and servers will never be exposed to untrusted data,
         implementing <code class="calibre12">Serializable</code> is a serious commitment that should be made with great care. Extra caution is warranted
         if a class permits inheritance.
      </p>
      
      <h3 class="h2"><a id="lev87" class="calibre4"></a><span epub:type="pagebreak" id="page_346" class="calibre15"></span><strong class="calibre10">Item 87: Consider using a custom serialized form</strong></h3>
      
      <p class="noindent">When you are writing a class under time pressure, it is generally appropriate to concentrate
         your efforts on designing the best API. Sometimes this means releasing a “throwaway”
         implementation that you know you’ll replace in a future release. Normally this is
         not a problem, but if the class implements <code class="calibre12">Serializable</code> and uses the default serialized form, you’ll never be able to escape completely from
         the throwaway implementation. It will dictate the serialized form forever. This is
         not just a theoretical problem. It happened to several classes in the Java libraries,
         including <code class="calibre12">BigInteger</code>.
      </p>
      
      <p class="indent"><strong class="calibre11">Do not accept the default serialized form without first considering whether it is
            appropriate.</strong> Accepting the default serialized form should be a conscious decision that this encoding
         is reasonable from the standpoint of flexibility, performance, and correctness. Generally
         speaking, you should accept the default serialized form only if it is largely identical
         to the encoding that you would choose if you were designing a custom serialized form.
      </p>
      
      <p class="indent">The default serialized form of an object is a reasonably efficient encoding of the
         <em class="calibre9">physical</em> representation of the object graph rooted at the object. In other words, it describes
         the data contained in the object and in every object that is reachable from this object.
         It also describes the topology by which all of these objects are interlinked. The
         ideal serialized form of an object contains only the <em class="calibre9">logical</em> data represented by the object. It is independent of the physical representation.
      </p>
      
      <p class="indent"><strong class="calibre11">The default serialized form is likely to be appropriate if an object’s physical representation
            is identical to its logical content.</strong> For example, the default serialized form would be reasonable for the following class,
         which simplistically represents a person’s name:
      </p>
      
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex3a" id="pch12ex3" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Good candidate for default serialized form</strong><br class="calibre7"/>
         public class Name implements Serializable {<br class="calibre7"/>
             /**<br class="calibre7"/>
              * Last name. Must be non-null.<br class="calibre7"/>
              * @serial<br class="calibre7"/>
              */<br class="calibre7"/>
             private final String lastName;<br class="calibre7"/>
         <br class="calibre7"/>
             /**<br class="calibre7"/>
              * First name. Must be non-null.<br class="calibre7"/>
              * @serial<br class="calibre7"/>
              */<br class="calibre7"/>
             private final String firstName;<br class="calibre7"/>
         <span epub:type="pagebreak" id="page_347"></span>
             /**<br class="calibre7"/>
              * Middle name, or null if there is none.<br class="calibre7"/>
              * @serial<br class="calibre7"/>
              */<br class="calibre7"/>
             private final String middleName;<br class="calibre7"/>
         <br class="calibre7"/>
             ... // Remainder omitted<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Logically speaking, a name consists of three strings that represent a last name, a
         first name, and a middle name. The instance fields in <code class="calibre12">Name</code> precisely mirror this logical content.
      </p>
      
      <p class="indent"><strong class="calibre11">Even if you decide that the default serialized form is appropriate, you often must
            provide a</strong> <code class="calibre12"><strong class="calibre11">readObject</strong></code> <strong class="calibre11">method to ensure invariants and security.</strong> In the case of <code class="calibre12">Name</code>, the <code class="calibre12">readObject</code> method must ensure that the fields <code class="calibre12">lastName</code> and <code class="calibre12">firstName</code> are non-null. This issue is discussed at length in Items 88 and 90.
      </p>
      
      <p class="indent">Note that there are documentation comments on the <code class="calibre12">lastName</code>, <code class="calibre12">firstName</code>, and <code class="calibre12">middleName</code> fields, even though they are private. That is because these private fields define
         a public API, which is the serialized form of the class, and this public API must
         be documented. The presence of the <code class="calibre12">@serial</code> tag tells Javadoc to place this documentation on a special page that documents serialized
         forms.
      </p>
      
      <p class="indent">Near the opposite end of the spectrum from <code class="calibre12">Name</code>, consider the following class, which represents a list of strings (ignoring for the
         moment that you would probably be better off using one of the standard <code class="calibre12">List</code> implementations):
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex4a" id="pch12ex4" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Awful candidate for default serialized form</strong><br class="calibre7"/>
         public final class StringList implements Serializable {<br class="calibre7"/>
             private int size = 0;<br class="calibre7"/>
             private Entry head = null;<br class="calibre7"/>
         <br class="calibre7"/>
             private static class Entry implements Serializable {<br class="calibre7"/>
                 String data;<br class="calibre7"/>
                 Entry  next;<br class="calibre7"/>
                 Entry  previous;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             ... // Remainder omitted<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Logically speaking, this class represents a sequence of strings. Physically, it represents
         the sequence as a doubly linked list. If you accept the default serialized form, the
         serialized form will painstakingly mirror every entry in the linked list and all the
         links between the entries, in both directions.
      </p>
      
      <p class="indentb"><span epub:type="pagebreak" id="page_348"></span><strong class="calibre11">Using the default serialized form when an object’s physical representation differs
            substantially from its logical data content has four disadvantages:</strong></p>
      
      <p class="bullb">• <strong class="calibre11">It permanently ties the exported API to the current internal representation.</strong> In the above example, the private <code class="calibre12">StringList.Entry</code> class becomes part of the public API. If the representation is changed in a future
         release, the <code class="calibre12">StringList</code> class will still need to accept the linked list representation on input and generate
         it on output. The class will never be rid of all the code dealing with linked list
         entries, even if it doesn’t use them anymore.
      </p>
      
      <p class="bullb">• <strong class="calibre11">It can consume excessive space.</strong> In the above example, the serialized form unnecessarily represents each entry in
         the linked list and all the links. These entries and links are mere implementation
         details, not worthy of inclusion in the serialized form. Because the serialized form
         is excessively large, writing it to disk or sending it across the network will be
         excessively slow.
      </p>
      
      <p class="bullb">• <strong class="calibre11">It can consume excessive time.</strong> The serialization logic has no knowledge of the topology of the object graph, so
         it must go through an expensive graph traversal. In the example above, it would be
         sufficient simply to follow the <code class="calibre12">next</code> references.
      </p>
      
      <p class="bullb">• <strong class="calibre11">It can cause stack overflows.</strong> The default serialization procedure performs a recursive traversal of the object
         graph, which can cause stack overflows even for moderately sized object graphs. Serializing
         a <code class="calibre12">StringList</code> instance with 1,000–1,800 elements generates a <code class="calibre12">StackOverflowError</code> on my machine. Surprisingly, the minimum list size for which serialization causes
         a stack overflow varies from run to run (on my machine). The minimum list size that
         exhibits this problem may depend on the platform implementation and command-line flags;
         some implementations may not have this problem at all.
      </p>
      
      <p class="indent">A reasonable serialized form for <code class="calibre12">StringList</code> is simply the number of strings in the list, followed by the strings themselves.
         This constitutes the logical data represented by a <code class="calibre12">StringList</code>, stripped of the details of its physical representation. Here is a revised version
         of <code class="calibre12">StringList</code> with <code class="calibre12">writeObject</code> and <code class="calibre12">readObject</code> methods that implement this serialized form. As a reminder, the <code class="calibre12">transient</code> modifier indicates that an instance field is to be omitted from a class’s default
         serialized form:
      </p>
      <span epub:type="pagebreak" id="page_349"></span>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex5a" id="pch12ex5" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// StringList with a reasonable custom serialized form</strong><br class="calibre7"/>
         public final class StringList implements Serializable {<br class="calibre7"/>
             private transient int size   = 0;<br class="calibre7"/>
             private transient Entry head = null;<br class="calibre7"/>
         <br class="calibre7"/>
             <strong class="calibre11">// No longer Serializable!</strong><br class="calibre7"/>
             private static class Entry {<br class="calibre7"/>
                 String data;<br class="calibre7"/>
                 Entry  next;<br class="calibre7"/>
                 Entry  previous;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             // Appends the specified string to the list<br class="calibre7"/>
             public final void add(String s) { ... }<br class="calibre7"/>
         <br class="calibre7"/>
             /**<br class="calibre7"/>
              * Serialize this {@code StringList} instance.<br class="calibre7"/>
              *<br class="calibre7"/>
              * @serialData The size of the list (the number of strings<br class="calibre7"/>
              * it contains) is emitted ({@code int}), followed by all of<br class="calibre7"/>
              * its elements (each a {@code String}), in the proper<br class="calibre7"/>
              * sequence.<br class="calibre7"/>
              */<br class="calibre7"/>
             private void writeObject(ObjectOutputStream s)<br class="calibre7"/>
                     throws IOException {<br class="calibre7"/>
                 s.defaultWriteObject();<br class="calibre7"/>
                 s.writeInt(size);<br class="calibre7"/>
         <br class="calibre7"/>
                 // Write out all elements in the proper order.<br class="calibre7"/>
                 for (Entry e = head; e != null; e = e.next)<br class="calibre7"/>
                     s.writeObject(e.data);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private void readObject(ObjectInputStream s)<br class="calibre7"/>
                     throws IOException, ClassNotFoundException {<br class="calibre7"/>
                 s.defaultReadObject();<br class="calibre7"/>
                 int numElements = s.readInt();<br class="calibre7"/>
         <br class="calibre7"/>
                 // Read in all elements and insert them in list<br class="calibre7"/>
                 for (int i = 0; i &lt; numElements; i++)<br class="calibre7"/>
                     add((String) s.readObject());<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             ... // Remainder omitted<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_350"></span>The first thing <code class="calibre12">writeObject</code> does is to invoke <code class="calibre12">defaultWriteObject</code>, and the first thing <code class="calibre12">readObject</code> does is to invoke <code class="calibre12">defaultReadObject</code>, even though all of <code class="calibre12">StringList</code>’s fields are transient. You may hear it said that if all of a class’s instance fields
         are transient, you can dispense with invoking <code class="calibre12">defaultWriteObject</code> and <code class="calibre12">defaultReadObject</code>, but the serialization specification requires you to invoke them regardless. The
         presence of these calls makes it possible to add nontransient instance fields in a
         later release while preserving backward and forward compatibility. If an instance
         is serialized in a later version and deserialized in an earlier version, the added
         fields will be ignored. Had the earlier version’s <code class="calibre12">readObject</code> method failed to invoke <code class="calibre12">defaultReadObject</code>, the deserialization would fail with a <code class="calibre12">StreamCorruptedException</code>.
      </p>
      
      <p class="indent">Note that there is a documentation comment on the <code class="calibre12">writeObject</code> method, even though it is private. This is analogous to the documentation comment
         on the private fields in the <code class="calibre12">Name</code> class. This private method defines a public API, which is the serialized form, and
         that public API should be documented. Like the <code class="calibre12">@serial</code> tag for fields, the <code class="calibre12">@serialData</code> tag for methods tells the Javadoc utility to place this documentation on the serialized
         forms page.
      </p>
      
      <p class="indent">To lend some sense of scale to the earlier performance discussion, if the average
         string length is ten characters, the serialized form of the revised version of <code class="calibre12">StringList</code> occupies about half as much space as the serialized form of the original. On my machine,
         serializing the revised version of <code class="calibre12">StringList</code> is over twice as fast as serializing the original version, with a list length of
         ten. Finally, there is no stack overflow problem in the revised form and hence no
         practical upper limit to the size of <code class="calibre12">StringList</code> that can be serialized.
      </p>
      
      <p class="indent">While the default serialized form would be bad for <code class="calibre12">StringList</code>, there are classes for which it would be far worse. For <code class="calibre12">StringList</code>, the default serialized form is inflexible and performs badly, but it is <em class="calibre9">correct</em> in the sense that serializing and deserializing a <code class="calibre12">StringList</code> instance yields a faithful copy of the original object with all of its invariants
         intact. This is not the case for any object whose invariants are tied to implementation-specific
         details.
      </p>
      
      <p class="indent">For example, consider the case of a hash table. The physical representation is a sequence
         of hash buckets containing key-value entries. The bucket that an entry resides in
         is a function of the hash code of its key, which is not, in general, guaranteed to
         be the same from implementation to implementation. In fact, it isn’t even guaranteed
         to be the same from run to run. Therefore, accepting the default serialized form for
         a hash table would constitute a serious bug. Serializing and deserializing the hash
         table could yield an object whose invariants were seriously corrupt.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_351"></span>Whether or not you accept the default serialized form, every instance field that isn’t
         labeled <code class="calibre12">transient</code> will be serialized when the <code class="calibre12">defaultWriteObject</code> method is invoked. Therefore, every instance field that can be declared transient
         should be. This includes derived fields, whose values can be computed from primary
         data fields, such as a cached hash value. It also includes fields whose values are
         tied to one particular run of the JVM, such as a <code class="calibre12">long</code> field representing a pointer to a native data structure. <strong class="calibre11">Before deciding to make a field nontransient, convince yourself that its value is
            part of the logical state of the object.</strong> If you use a custom serialized form, most or all of the instance fields should be
         labeled <code class="calibre12">transient</code>, as in the <code class="calibre12">StringList</code> example above.
      </p>
      
      <p class="indent">If you are using the default serialized form and you have labeled one or more fields
         <code class="calibre12">transient</code>, remember that these fields will be initialized to their <em class="calibre9">default values</em> when an instance is deserialized: <code class="calibre12">null</code> for object reference fields, zero for numeric primitive fields, and <code class="calibre12">false</code> for <code class="calibre12">boolean</code> fields [JLS, 4.12.5]. If these values are unacceptable for any transient fields,
         you must provide a <code class="calibre12">readObject</code> method that invokes the <code class="calibre12">defaultReadObject</code> method and then restores transient fields to acceptable values (<a href="ch12.xhtml#lev88" class="calibre8">Item 88</a>). Alternatively, these fields can be lazily initialized the first time they are used
         (<a href="ch11.xhtml#lev83" class="calibre8">Item 83</a>).
      </p>
      
      <p class="indent">Whether or not you use the default serialized form, <strong class="calibre11">you must impose any synchronization on object serialization that you would impose
            on any other method that reads the entire state of the object.</strong> So, for example, if you have a thread-safe object (<a href="ch11.xhtml#lev82" class="calibre8">Item 82</a>) that achieves its thread safety by synchronizing every method and you elect to use
         the default serialized form, use the following <code class="calibre12">write-Object</code> method:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex6a" id="pch12ex6" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// writeObject for synchronized class with default serialized form</strong><br class="calibre7"/>
         private <strong class="calibre11">synchronized</strong> void writeObject(ObjectOutputStream s)<br class="calibre7"/>
                 throws IOException {<br class="calibre7"/>
             s.defaultWriteObject();<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">If you put synchronization in the <code class="calibre12">writeObject</code> method, you must ensure that it adheres to the same lock-ordering constraints as
         other activities, or you risk a resource-ordering deadlock [Goetz06, 10.1.5].
      </p>
      
      <p class="indent"><strong class="calibre11">Regardless of what serialized form you choose, declare an explicit serial version
            UID in every serializable class you write.</strong> This eliminates the serial version UID as a potential source of incompatibility (<a href="ch12.xhtml#lev86" class="calibre8">Item 86</a>). There is also a small performance benefit. If no serial version UID is provided,
         an expensive computation is performed to generate one at runtime.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_352"></span>Declaring a serial version UID is simple. Just add this line to your class:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex7a" id="pch12ex7" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">private static final long serialVersionUID = <em class="calibre9">randomLongValue</em>;
      </p>
      
      <p class="noindent">If you write a new class, it doesn’t matter what value you choose for <em class="calibre9">randomLongValue</em>. You can generate the value by running the <code class="calibre12">serialver</code> utility on the class, but it’s also fine to pick a number out of thin air. It is
         <em class="calibre9">not</em> required that serial version UIDs be unique. If you modify an existing class that
         lacks a serial version UID, and you want the new version to accept existing serialized
         instances, you must use the value that was automatically generated for the old version.
         You can get this number by running the <code class="calibre12">serialver</code> utility on the old version of the class—the one for which serialized instances exist.
      </p>
      
      <p class="indent">If you ever want to make a new version of a class that is <em class="calibre9">incompatible</em> with existing versions, merely change the value in the serial version UID declaration.
         This will cause attempts to deserialize serialized instances of previous versions
         to throw an <code class="calibre12">InvalidClassException</code>. <strong class="calibre11">Do not change the serial version UID unless you want to break compatibility with all
            existing serialized instances of a class.</strong></p>
      
      <p class="indent">To summarize, if you have decided that a class should be serializable (<a href="ch12.xhtml#lev86" class="calibre8">Item 86</a>), think hard about what the serialized form should be. Use the default serialized
         form <em class="calibre9">only</em> if it is a reasonable description of the logical state of the object; otherwise design
         a custom serialized form that aptly describes the object. You should allocate as much
         time to designing the serialized form of a class as you allocate to designing an exported
         method (<a href="ch8.xhtml#lev51" class="calibre8">Item 51</a>). Just as you can’t eliminate exported methods from future versions, you can’t eliminate
         fields from the serialized form; they must be preserved forever to ensure serialization
         compatibility. Choosing the wrong serialized form can have a permanent, negative impact
         on the complexity and performance of a class.
      </p>
      
      <h3 class="h2"><a id="lev88" class="calibre4"></a><span epub:type="pagebreak" id="page_353" class="calibre15"></span><strong class="calibre10">Item 88: Write</strong> <code class="calibre19"><strong class="calibre10">readObject</strong></code> <strong class="calibre10">methods defensively</strong></h3>
      
      <p class="noindent">Item 50 contains an immutable date-range class with mutable private <code class="calibre12">Date</code> fields. The class goes to great lengths to preserve its invariants and immutability
         by defensively copying <code class="calibre12">Date</code> objects in its constructor and accessors. Here is the class:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex8a" id="pch12ex8" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Immutable class that uses defensive copying</strong><br class="calibre7"/>
         public final class Period {<br class="calibre7"/>
             private final Date start;<br class="calibre7"/>
             private final Date end;<br class="calibre7"/>
             /**<br class="calibre7"/>
              * @param  start the beginning of the period<br class="calibre7"/>
              * @param  end the end of the period; must not precede start<br class="calibre7"/>
              * @throws IllegalArgumentException if start is after end<br class="calibre7"/>
              * @throws NullPointerException if start or end is null<br class="calibre7"/>
              */<br class="calibre7"/>
             public Period(Date start, Date end) {<br class="calibre7"/>
                 this.start = new Date(start.getTime());<br class="calibre7"/>
                 this.end   = new Date(end.getTime());<br class="calibre7"/>
                 if (this.start.compareTo(this.end) &gt; 0)<br class="calibre7"/>
                     throw new IllegalArgumentException(<br class="calibre7"/>
                                   start + " after " + end);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             public Date start () { return new Date(start.getTime()); }<br class="calibre7"/>
         <br class="calibre7"/>
             public Date end () { return new Date(end.getTime()); }<br class="calibre7"/>
         <br class="calibre7"/>
             public String toString() { return start + " - " + end; }<br class="calibre7"/>
         <br class="calibre7"/>
             ... // Remainder omitted<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Suppose you decide that you want this class to be serializable. Because the physical
         representation of a <code class="calibre12">Period</code> object exactly mirrors its logical data content, it is not unreasonable to use the
         default serialized form (<a href="ch12.xhtml#lev87" class="calibre8">Item 87</a>). Therefore, it might seem that all you have to do to make the class serializable
         is to add the words <code class="calibre12">implements Serializable</code> to the class declaration. If you did so, however, the class would no longer guarantee
         its critical invariants.
      </p>
      
      <p class="indent">The problem is that the <code class="calibre12">readObject</code> method is effectively another public constructor, and it demands all of the same
         care as any other constructor. Just as a constructor must check its arguments for
         validity (<a href="ch8.xhtml#lev49" class="calibre8">Item 49</a>) and make defensive copies of parameters where appropriate (<a href="ch8.xhtml#lev50" class="calibre8">Item 50</a>), so must a <code class="calibre12">readObject</code> method. If a <code class="calibre12">readObject</code> method fails to do either of these things, it is a relatively simple matter for an
         attacker to violate the class’s invariants.
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_354"></span>Loosely speaking, <code class="calibre12">readObject</code> is a constructor that takes a byte stream as its sole parameter. In normal use, the
         byte stream is generated by serializing a normally constructed instance. The problem
         arises when <code class="calibre12">readObject</code> is presented with a byte stream that is artificially constructed to generate an object
         that violates the invariants of its class. Such a byte stream can be used to create
         an <em class="calibre9">impossible object</em>, which could not have been created using a normal constructor.
      </p>
      
      <p class="indent">Assume that we simply added <code class="calibre12">implements Serializable</code> to the class declaration for <code class="calibre12">Period</code>. This ugly program would then generate a <code class="calibre12">Period</code> instance whose end precedes its start. The casts on <code class="calibre12">byte</code> values whose high-order bit is set is a consequence of Java’s lack of <code class="calibre12">byte</code> literals combined with the unfortunate decision to make the <code class="calibre12">byte</code> type signed:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex9a" id="pch12ex9" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class BogusPeriod {<br class="calibre7"/>
           <strong class="calibre11">// Byte stream couldn't have come from a real Period instance!</strong><br class="calibre7"/>
           private static final byte[] serializedForm = {<br class="calibre7"/>
             (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,<br class="calibre7"/>
             0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,<br class="calibre7"/>
             0x2b, 0x4f, 0x46, (byte)0xc0, (byte)0xf4, 0x02, 0x00, 0x02,<br class="calibre7"/>
             0x4c, 0x00, 0x03, 0x65, 0x6e, 0x64, 0x74, 0x00, 0x10, 0x4c,<br class="calibre7"/>
             0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f,<br class="calibre7"/>
             0x44, 0x61, 0x74, 0x65, 0x3b, 0x4c, 0x00, 0x05, 0x73, 0x74,<br class="calibre7"/>
             0x61, 0x72, 0x74, 0x71, 0x00, 0x7e, 0x00, 0x01, 0x78, 0x70,<br class="calibre7"/>
             0x73, 0x72, 0x00, 0x0e, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75,<br class="calibre7"/>
             0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x68, 0x6a,<br class="calibre7"/>
             (byte)0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, 0x03, 0x00, 0x00,<br class="calibre7"/>
             0x78, 0x70, 0x77, 0x08, 0x00, 0x00, 0x00, 0x66, (byte)0xdf,<br class="calibre7"/>
             0x6e, 0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03,<br class="calibre7"/>
             0x77, 0x08, 0x00, 0x00, 0x00, (byte)0xd5, 0x17, 0x69, 0x22,<br class="calibre7"/>
             0x00, 0x78<br class="calibre7"/>
           };<br class="calibre7"/>
         <br class="calibre7"/>
           public static void main(String[] args) {<br class="calibre7"/>
             Period p = (Period) deserialize(serializedForm);<br class="calibre7"/>
             System.out.println(p);<br class="calibre7"/>
           }<br class="calibre7"/>
         <br class="calibre7"/>
           // Returns the object with the specified serialized form<br class="calibre7"/>
           static Object deserialize(byte[] sf) {<br class="calibre7"/>
             try {<br class="calibre7"/>
               return new ObjectInputStream(<br class="calibre7"/>
                   new ByteArrayInputStream(sf)).readObject();<br class="calibre7"/>
             } catch (IOException | ClassNotFoundException e) {<br class="calibre7"/>
               throw new IllegalArgumentException(e);<br class="calibre7"/>
             }<br class="calibre7"/>
           }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_355"></span>The <code class="calibre12">byte</code> array literal used to initialize <code class="calibre12">serializedForm</code> was generated by serializing a normal <code class="calibre12">Period</code> instance and hand-editing the resulting byte stream. The details of the stream are
         unimportant to the example, but if you’re curious, the serialization byte-stream format
         is described in the <em class="calibre9">Java Object Serialization Specification</em> [Serialization, 6]. If you run this program, it prints <code class="calibre12">Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code>. Simply declaring <code class="calibre12">Period</code> serializable enabled us to create an object that violates its class invariants.
      </p>
      
      <p class="indent">To fix this problem, provide a <code class="calibre12">readObject</code> method for <code class="calibre12">Period</code> that calls <code class="calibre12">defaultReadObject</code> and then checks the validity of the deserialized object. If the validity check fails,
         the <code class="calibre12">readObject</code> method throws <code class="calibre12">InvalidObjectException</code>, preventing the deserialization from completing:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex10a" id="pch12ex10" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readObject method with validity checking - insufficient!</strong><br class="calibre7"/>
         private void readObject(ObjectInputStream s)<br class="calibre7"/>
                 throws IOException, ClassNotFoundException {<br class="calibre7"/>
             s.defaultReadObject();<br class="calibre7"/>
         <br class="calibre7"/>
             // Check that our invariants are satisfied<br class="calibre7"/>
             if (start.compareTo(end) &gt; 0)<br class="calibre7"/>
                 throw new InvalidObjectException(start +" after "+ end);<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">While this prevents an attacker from creating an invalid <code class="calibre12">Period</code> instance, there is a more subtle problem still lurking. It is possible to create
         a mutable <code class="calibre12">Period</code> instance by fabricating a byte stream that begins with a valid <code class="calibre12">Period</code> instance and then appends extra references to the private <code class="calibre12">Date</code> fields internal to the <code class="calibre12">Period</code> instance. The attacker reads the <code class="calibre12">Period</code> instance from the <code class="calibre12">ObjectInputStream</code> and then reads the “rogue object references” that were appended to the stream. These
         references give the attacker access to the objects referenced by the private <code class="calibre12">Date</code> fields within the <code class="calibre12">Period</code> object. By mutating these <code class="calibre12">Date</code> instances, the attacker can mutate the <code class="calibre12">Period</code> instance. The following class demonstrates this attack:
      </p>
      
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex11a" id="pch12ex11" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class MutablePeriod {<br class="calibre7"/>
             // A period instance<br class="calibre7"/>
             public final Period period;<br class="calibre7"/>
         <br class="calibre7"/>
             // period's start field, to which we shouldn't have access<br class="calibre7"/>
             public final Date start;<br class="calibre7"/>
         <br class="calibre7"/>
             // period's end field, to which we shouldn't have access<br class="calibre7"/>
             public final Date end;<br class="calibre7"/>
         <span epub:type="pagebreak" id="page_356"></span>
             public MutablePeriod() {<br class="calibre7"/>
                 try {<br class="calibre7"/>
                     ByteArrayOutputStream bos =<br class="calibre7"/>
                         new ByteArrayOutputStream();<br class="calibre7"/>
                     ObjectOutputStream out =<br class="calibre7"/>
                         new ObjectOutputStream(bos);<br class="calibre7"/>
         <br class="calibre7"/>
                     // Serialize a valid Period instance<br class="calibre7"/>
                     out.writeObject(new Period(new Date(), new Date()));<br class="calibre7"/>
         <br class="calibre7"/>
                     /*<br class="calibre7"/>
                      * Append rogue "previous object refs" for internal<br class="calibre7"/>
                      * Date fields in Period. For details, see "Java<br class="calibre7"/>
                      * Object Serialization Specification," Section 6.4.<br class="calibre7"/>
                      */<br class="calibre7"/>
                     byte[] ref = { 0x71, 0, 0x7e, 0, 5 };  // Ref #5<br class="calibre7"/>
                     bos.write(ref); // The start field<br class="calibre7"/>
                     ref[4] = 4;     // Ref # 4<br class="calibre7"/>
                     bos.write(ref); // The end field<br class="calibre7"/>
         <br class="calibre7"/>
                     // Deserialize Period and "stolen" Date references<br class="calibre7"/>
                     ObjectInputStream in = new ObjectInputStream(<br class="calibre7"/>
                         new ByteArrayInputStream(bos.toByteArray()));<br class="calibre7"/>
                     period = (Period) in.readObject();<br class="calibre7"/>
                     start  = (Date)   in.readObject();<br class="calibre7"/>
                     end    = (Date)   in.readObject();<br class="calibre7"/>
                 } catch (IOException | ClassNotFoundException e) {<br class="calibre7"/>
                     throw new AssertionError(e);<br class="calibre7"/>
                 }<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">To see the attack in action, run the following program:</p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex12a" id="pch12ex12" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public static void main(String[] args) {<br class="calibre7"/>
             MutablePeriod mp = new MutablePeriod();<br class="calibre7"/>
             Period p = mp.period;<br class="calibre7"/>
             Date pEnd = mp.end;<br class="calibre7"/>
         <br class="calibre7"/>
             // Let's turn back the clock<br class="calibre7"/>
             pEnd.setYear(78);<br class="calibre7"/>
             System.out.println(p);<br class="calibre7"/>
         <br class="calibre7"/>
             // Bring back the 60s!<br class="calibre7"/>
             pEnd.setYear(69);<br class="calibre7"/>
             System.out.println(p);<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent"><span epub:type="pagebreak" id="page_357"></span>In my locale, running this program produces the following output:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex13a" id="pch12ex13" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978<br class="calibre7"/>
         Wed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969
      </p>
      
      <p class="noindent">While the <code class="calibre12">Period</code> instance is created with its invariants intact, it is possible to modify its internal
         components at will. Once in possession of a mutable <code class="calibre12">Period</code> instance, an attacker might cause great harm by passing the instance to a class that
         depends on <code class="calibre12">Period</code>’s immutability for its security. This is not so far-fetched: there are classes that
         depend on <code class="calibre12">String</code>’s immutability for their security.
      </p>
      
      <p class="indent">The source of the problem is that <code class="calibre12">Period</code>’s <code class="calibre12">readObject</code> method is not doing enough defensive copying. <strong class="calibre11">When an object is deserialized, it is critical to defensively copy any field containing
            an object reference that a client must not possess.</strong> Therefore, every serializable immutable class containing private mutable components
         must defensively copy these components in its <code class="calibre12">readObject</code> method. The following <code class="calibre12">readObject</code> method suffices to ensure <code class="calibre12">Period</code>’s invariants and to maintain its immutability:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex14a" id="pch12ex14" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readObject method with defensive copying and validity checking</strong><br class="calibre7"/>
         private void readObject(ObjectInputStream s)<br class="calibre7"/>
                 throws IOException, ClassNotFoundException {<br class="calibre7"/>
             s.defaultReadObject();<br class="calibre7"/>
         <br class="calibre7"/>
             // Defensively copy our mutable components<br class="calibre7"/>
             start = new Date(start.getTime());<br class="calibre7"/>
             end   = new Date(end.getTime());<br class="calibre7"/>
         <br class="calibre7"/>
             // Check that our invariants are satisfied<br class="calibre7"/>
             if (start.compareTo(end) &gt; 0)<br class="calibre7"/>
                 throw new InvalidObjectException(start +" after "+ end);<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Note that the defensive copy is performed prior to the validity check and that we
         did not use <code class="calibre12">Date</code>’s <code class="calibre12">clone</code> method to perform the defensive copy. Both of these details are required to protect
         <code class="calibre12">Period</code> against attack (<a href="ch8.xhtml#lev50" class="calibre8">Item 50</a>). Note also that defensive copying is not possible for final fields. To use the <code class="calibre12">readObject</code> method, we must make the <code class="calibre12">start</code> and <code class="calibre12">end</code> fields nonfinal. This is unfortunate, but it is the lesser of two evils. With the
         new <code class="calibre12">readObject</code> method in place and the <code class="calibre12">final</code> modifier removed from the <code class="calibre12">start</code> and <code class="calibre12">end</code> fields, the <code class="calibre12">MutablePeriod</code> class is rendered ineffective. The above attack program now generates this output:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex15a" id="pch12ex15" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017<br class="calibre7"/>
         Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_358"></span>Here is a simple litmus test for deciding whether the default <code class="calibre12">readObject</code> method is acceptable for a class: would you feel comfortable adding a public constructor
         that took as parameters the values for each nontransient field in the object and stored
         the values in the fields with no validation whatsoever? If not, you must provide a
         <code class="calibre12">readObject</code> method, and it must perform all the validity checking and defensive copying that
         would be required of a constructor. Alternatively, you can use the <em class="calibre9">serialization proxy pattern</em> (<a href="ch12.xhtml#lev90" class="calibre8">Item 90</a>). This pattern is highly recommended because it takes much of the effort out of safe
         deserialization.
      </p>
      
      <p class="indent">There is one other similarity between <code class="calibre12">readObject</code> methods and constructors that applies to nonfinal serializable classes. Like a constructor,
         a <code class="calibre12">readObject</code> method must not invoke an overridable method, either directly or indirectly (<a href="ch4.xhtml#lev19" class="calibre8">Item 19</a>). If this rule is violated and the method in question is overridden, the overriding
         method will run before the subclass’s state has been deserialized. A program failure
         is likely to result [Bloch05, Puzzle 91].
      </p>
      
      <p class="indentb">To summarize, anytime you write a <code class="calibre12">readObject</code> method, adopt the mind-set that you are writing a public constructor that must produce
         a valid instance regardless of what byte stream it is given. Do not assume that the
         byte stream represents an actual serialized instance. While the examples in this item
         concern a class that uses the default serialized form, all of the issues that were
         raised apply equally to classes with custom serialized forms. Here, in summary form,
         are the guidelines for writing a <code class="calibre12">readObject</code> method:
      </p>
      
      <p class="bullb">• For classes with object reference fields that must remain private, defensively copy
         each object in such a field. Mutable components of immutable classes fall into this
         category.
      </p>
      
      <p class="bullb">• Check any invariants and throw an <code class="calibre12">InvalidObjectException</code> if a check fails. The checks should follow any defensive copying.
      </p>
      
      <p class="bullb">• If an entire object graph must be validated after it is deserialized, use the <code class="calibre12">ObjectInputValidation</code> interface (not discussed in this book).
      </p>
      
      <p class="bullb">• Do not invoke any overridable methods in the class, directly or indirectly.</p>
      
      <h3 class="h2"><a id="lev89" class="calibre4"></a><span epub:type="pagebreak" id="page_359" class="calibre15"></span><strong class="calibre10">Item 89: For instance control, prefer enum types to</strong> <code class="calibre19"><strong class="calibre10">readResolve</strong></code></h3>
      
      <p class="noindent">Item 3 describes the <em class="calibre9">Singleton</em> pattern and gives the following example of a singleton class. This class restricts
         access to its constructor to ensure that only a single instance is ever created:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex16a" id="pch12ex16" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class Elvis {<br class="calibre7"/>
             <strong class="calibre11">public static final Elvis INSTANCE = new Elvis();</strong><br class="calibre7"/>
             <strong class="calibre11">private</strong> Elvis() {  ... }<br class="calibre7"/>
         <br class="calibre7"/>
             public void leaveTheBuilding() { ... }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">As noted in <a href="ch2.xhtml#lev3" class="calibre8">Item 3</a>, this class would no longer be a singleton if the words <code class="calibre12">implements Serializable</code> were added to its declaration. It doesn’t matter whether the class uses the default
         serialized form or a custom serialized form (<a href="ch12.xhtml#lev87" class="calibre8">Item 87</a>), nor does it matter whether the class provides an explicit <code class="calibre12">readObject</code> method (<a href="ch12.xhtml#lev88" class="calibre8">Item 88</a>). Any <code class="calibre12">readObject</code> method, whether explicit or default, returns a newly created instance, which will
         not be the same instance that was created at class initialization time.
      </p>
      
      <p class="indent">The <code class="calibre12">readResolve</code> feature allows you to substitute another instance for the one created by <code class="calibre12">readObject</code> [Serialization, 3.7]. If the class of an object being deserialized defines a <code class="calibre12">readResolve</code> method with the proper declaration, this method is invoked on the newly created object
         after it is deserialized. The object reference returned by this method is then returned
         in place of the newly created object. In most uses of this feature, no reference to
         the newly created object is retained, so it immediately becomes eligible for garbage
         collection.
      </p>
      
      <p class="indent">If the <code class="calibre12">Elvis</code> class is made to implement <code class="calibre12">Serializable</code>, the following <code class="calibre12">read-Resolve</code> method suffices to guarantee the singleton property:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex17a" id="pch12ex17" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readResolve for instance control - you can do better!</strong><br class="calibre7"/>
         private Object readResolve() {<br class="calibre7"/>
             // Return the one true Elvis and let the garbage collector<br class="calibre7"/>
             // take care of the Elvis impersonator.<br class="calibre7"/>
             return INSTANCE;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">This method ignores the deserialized object, returning the distinguished <code class="calibre12">Elvis</code> instance that was created when the class was initialized. Therefore, the serialized
         form of an <code class="calibre12">Elvis</code> instance need not contain any real data; all instance fields should be declared transient.
         In fact, <strong class="calibre11">if you depend on</strong> <code class="calibre12"><strong class="calibre11">readResolve</strong></code> <strong class="calibre11">for instance</strong> <span epub:type="pagebreak" id="page_360"></span><strong class="calibre11">control, all instance fields with object reference types</strong> <em class="calibre9"><strong class="calibre11">must</strong></em> <strong class="calibre11">be declared</strong> <code class="calibre12"><strong class="calibre11">transient</strong></code><strong class="calibre11">.</strong> Otherwise, it is possible for a determined attacker to secure a reference to the
         deserialized object before its <code class="calibre12">readResolve</code> method is run, using a technique that is somewhat similar to the <code class="calibre12">MutablePeriod</code> attack in <a href="ch12.xhtml#lev88" class="calibre8">Item 88</a>.
      </p>
      
      <p class="indent">The attack is a bit complicated, but the underlying idea is simple. If a singleton
         contains a nontransient object reference field, the contents of this field will be
         deserialized before the singleton’s <code class="calibre12">readResolve</code> method is run. This allows a carefully crafted stream to “steal” a reference to the
         originally deserialized singleton at the time the contents of the object reference
         field are deserialized.
      </p>
      
      <p class="indent">Here’s how it works in more detail. First, write a “stealer” class that has both a
         <code class="calibre12">readResolve</code> method and an instance field that refers to the serialized singleton in which the
         stealer “hides.” In the serialization stream, replace the singleton’s nontransient
         field with an instance of the stealer. You now have a circularity: the singleton contains
         the stealer, and the stealer refers to the singleton.
      </p>
      
      <p class="indent">Because the singleton contains the stealer, the stealer’s <code class="calibre12">readResolve</code> method runs first when the singleton is deserialized. As a result, when the stealer’s
         <code class="calibre12">readResolve</code> method runs, its instance field still refers to the partially deserialized (and as
         yet unresolved) singleton.
      </p>
      
      <p class="indent">The stealer’s <code class="calibre12">readResolve</code> method copies the reference from its instance field into a static field so that the
         reference can be accessed after the <code class="calibre12">readResolve</code> method runs. The method then returns a value of the correct type for the field in
         which it’s hiding. If it didn’t do this, the VM would throw a <code class="calibre12">ClassCastException</code> when the serialization system tried to store the stealer reference into this field.
      </p>
      
      <p class="indent">To make this concrete, consider the following broken singleton:</p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex18a" id="pch12ex18" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Broken singleton - has nontransient object reference field!</strong><br class="calibre7"/>
         public class Elvis implements Serializable {<br class="calibre7"/>
             public static final Elvis INSTANCE = new Elvis();<br class="calibre7"/>
             private Elvis() { }<br class="calibre7"/>
         <br class="calibre7"/>
             <strong class="calibre11">private String[] favoriteSongs =</strong><br class="calibre7"/>
                 <strong class="calibre11">{ "Hound Dog", "Heartbreak Hotel" };</strong><br class="calibre7"/>
             public void printFavorites() {<br class="calibre7"/>
                 System.out.println(Arrays.toString(favoriteSongs));<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private Object readResolve() {<br class="calibre7"/>
                 return INSTANCE;<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent"><span epub:type="pagebreak" id="page_361"></span>Here is a “stealer” class, constructed as per the description above:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex19a" id="pch12ex19" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class ElvisStealer implements Serializable {<br class="calibre7"/>
             static Elvis impersonator;<br class="calibre7"/>
             private Elvis payload;<br class="calibre7"/>
         <br class="calibre7"/>
             private Object readResolve() {<br class="calibre7"/>
                 <strong class="calibre11">// Save a reference to the "unresolved" Elvis instance</strong><br class="calibre7"/>
                 impersonator = payload;<br class="calibre7"/>
         <br class="calibre7"/>
                 <strong class="calibre11">// Return object of correct type for favoriteSongs field</strong><br class="calibre7"/>
                 return new String[] { "A Fool Such as I" };<br class="calibre7"/>
             }<br class="calibre7"/>
             private static final long serialVersionUID = 0;<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent">Finally, here is an ugly program that deserializes a handcrafted stream to produce
         two distinct instances of the flawed singleton. The deserialize method is omitted
         from this program because it’s identical to the one on page 354:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex20a" id="pch12ex20" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">public class ElvisImpersonator {<br class="calibre7"/>
           <strong class="calibre11">// Byte stream couldn't have come from a real Elvis instance!</strong><br class="calibre7"/>
           private static final byte[] serializedForm = {<br class="calibre7"/>
             (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x05,<br class="calibre7"/>
             0x45, 0x6c, 0x76, 0x69, 0x73, (byte)0x84, (byte)0xe6,<br class="calibre7"/>
             (byte)0x93, 0x33, (byte)0xc3, (byte)0xf4, (byte)0x8b,<br class="calibre7"/>
             0x32, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x0d, 0x66, 0x61, 0x76,<br class="calibre7"/>
             0x6f, 0x72, 0x69, 0x74, 0x65, 0x53, 0x6f, 0x6e, 0x67, 0x73,<br class="calibre7"/>
             0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,<br class="calibre7"/>
             0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,<br class="calibre7"/>
             0x3b, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0c, 0x45, 0x6c, 0x76,<br class="calibre7"/>
             0x69, 0x73, 0x53, 0x74, 0x65, 0x61, 0x6c, 0x65, 0x72, 0x00,<br class="calibre7"/>
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,<br class="calibre7"/>
             0x4c, 0x00, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,<br class="calibre7"/>
             0x74, 0x00, 0x07, 0x4c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x3b,<br class="calibre7"/>
             0x78, 0x70, 0x71, 0x00, 0x7e, 0x00, 0x02<br class="calibre7"/>
           };<br class="calibre7"/>
         <br class="calibre7"/>
           public static void main(String[] args) {<br class="calibre7"/>
             <strong class="calibre11">// Initializes ElvisStealer.impersonator and returns</strong><br class="calibre7"/>
             <strong class="calibre11">// the real Elvis (which is Elvis.INSTANCE)</strong><br class="calibre7"/>
             <strong class="calibre11">Elvis elvis = (Elvis) deserialize(serializedForm);</strong><br class="calibre7"/>
             Elvis impersonator = ElvisStealer.impersonator;<br class="calibre7"/>
         <br class="calibre7"/>
             elvis.printFavorites();<br class="calibre7"/>
             impersonator.printFavorites();<br class="calibre7"/>
           }<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent"><span epub:type="pagebreak" id="page_362"></span>Running this program produces the following output, conclusively proving that it’s
         possible to create two distinct <code class="calibre12">Elvis</code> instances (with different tastes in music):
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex21a" id="pch12ex21" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre">[Hound Dog, Heartbreak Hotel]<br class="calibre7"/>
         [A Fool Such as I]
      </p>
      
      <p class="indent">You could fix the problem by declaring the <code class="calibre12">favoriteSongs</code> field <code class="calibre12">transient</code>, but you’re better off fixing it by making <code class="calibre12">Elvis</code> a single-element enum type (<a href="ch2.xhtml#lev3" class="calibre8">Item 3</a>). As demonstrated by the <code class="calibre12">ElvisStealer</code> attack, using a <code class="calibre12">readResolve</code> method to prevent a “temporary” deserialized instance from being accessed by an attacker
         is fragile and demands great care.
      </p>
      
      <p class="indent">If you write your serializable instance-controlled class as an enum, Java guarantees
         you that there can be no instances besides the declared constants, unless an attacker
         abuses a privileged method such as <code class="calibre12">AccessibleObject.setAccessible</code>. Any attacker who can do that already has sufficient privileges to execute arbitrary
         native code, and all bets are off. Here’s how our <code class="calibre12">Elvis</code> example looks as an enum:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex22a" id="pch12ex22" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Enum singleton - the preferred approach</strong><br class="calibre7"/>
         public enum Elvis {<br class="calibre7"/>
             INSTANCE;<br class="calibre7"/>
             private String[] favoriteSongs =<br class="calibre7"/>
                 { "Hound Dog", "Heartbreak Hotel" };<br class="calibre7"/>
             public void printFavorites() {<br class="calibre7"/>
                 System.out.println(Arrays.toString(favoriteSongs));<br class="calibre7"/>
             }<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">The use of <code class="calibre12">readResolve</code> for instance control is not obsolete. If you have to write a serializable instance-controlled
         class whose instances are not known at compile time, you will not be able to represent
         the class as an enum type.
      </p>
      
      <p class="indent"><strong class="calibre11">The accessibility of</strong> <code class="calibre12"><strong class="calibre11">readResolve</strong></code> <strong class="calibre11">is significant.</strong> If you place a <code class="calibre12">readResolve</code> method on a final class, it should be private. If you place a <code class="calibre12">readResolve</code> method on a nonfinal class, you must carefully consider its accessibility. If it
         is private, it will not apply to any subclasses. If it is package-private, it will
         apply only to subclasses in the same package. If it is protected or public, it will
         apply to all subclasses that do not override it. If a <code class="calibre12">readResolve</code> method is protected or public and a subclass does not override it, deserializing
         a subclass instance will produce a superclass instance, which is likely to cause a
         <code class="calibre12">ClassCastException</code>.
      </p>
      
      <p class="indent">To summarize, use enum types to enforce instance control invariants wherever possible.
         If this is not possible and you need a class to be both serializable and instance-controlled,
         you must provide a <code class="calibre12">readResolve</code> method and ensure that all of the class’s instance fields are either primitive or
         transient.
      </p>
      
      <h3 class="h2"><a id="lev90" class="calibre4"></a><span epub:type="pagebreak" id="page_363" class="calibre15"></span><strong class="calibre10">Item 90: Consider serialization proxies instead of serialized instances</strong></h3>
      
      <p class="noindent">As mentioned in Items 85 and 86 and discussed throughout this chapter, the decision
         to implement <code class="calibre12">Serializable</code> increases the likelihood of bugs and security problems as it allows instances to
         be created using an extralinguistic mechanism in place of ordinary constructors. There
         is, however, a technique that greatly reduces these risks. This technique is known
         as the <em class="calibre9">serialization proxy pattern</em>.
      </p>
      
      <p class="indent">The serialization proxy pattern is reasonably straightforward. First, design a private
         static nested class that concisely represents the logical state of an instance of
         the enclosing class. This nested class is known as the <em class="calibre9">serialization proxy</em> of the enclosing class. It should have a single constructor, whose parameter type
         is the enclosing class. This constructor merely copies the data from its argument:
         it need not do any consistency checking or defensive copying. By design, the default
         serialized form of the serialization proxy is the perfect serialized form of the enclosing
         class. Both the enclosing class and its serialization proxy must be declared to implement
         <code class="calibre12">Serializable</code>.
      </p>
      
      <p class="indent">For example, consider the immutable <code class="calibre12">Period</code> class written in <a href="ch8.xhtml#lev50" class="calibre8">Item 50</a> and made serializable in <a href="ch12.xhtml#lev88" class="calibre8">Item 88</a>. Here is a serialization proxy for this class. <code class="calibre12">Period</code> is so simple that its serialization proxy has exactly the same fields as the class:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex23a" id="pch12ex23" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// Serialization proxy for Period class</strong><br class="calibre7"/>
         private static class SerializationProxy implements Serializable {<br class="calibre7"/>
             private final Date start;<br class="calibre7"/>
             private final Date end;<br class="calibre7"/>
         <br class="calibre7"/>
             SerializationProxy(Period p) {<br class="calibre7"/>
                 this.start = p.start;<br class="calibre7"/>
                 this.end = p.end;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private static final long serialVersionUID =<br class="calibre7"/>
                 234098243823485285L; // Any number will do (Item  87)<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Next, add the following <code class="calibre12">writeReplace</code> method to the enclosing class. This method can be copied verbatim into any class
         with a serialization proxy:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex24a" id="pch12ex24" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// writeReplace method for the serialization proxy pattern</strong><br class="calibre7"/>
         private Object writeReplace() {<br class="calibre7"/>
             return new SerializationProxy(this);<br class="calibre7"/>
         }
      </p>
      
      <p class="noindent"><span epub:type="pagebreak" id="page_364"></span>The presence of this method on the enclosing class causes the serialization system
         to emit a <code class="calibre12">SerializationProxy</code> instance instead of an instance of the enclosing class. In other words, the <code class="calibre12">writeReplace</code> method translates an instance of the enclosing class to its serialization proxy prior
         to serialization.
      </p>
      
      <p class="indent">With this <code class="calibre12">writeReplace</code> method in place, the serialization system will never generate a serialized instance
         of the enclosing class, but an attacker might fabricate one in an attempt to violate
         the class’s invariants. To guarantee that such an attack would fail, merely add this
         <code class="calibre12">readObject</code> method to the enclosing class:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex25a" id="pch12ex25" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readObject method for the serialization proxy pattern</strong><br class="calibre7"/>
         private void readObject(ObjectInputStream stream)<br class="calibre7"/>
                 throws InvalidObjectException {<br class="calibre7"/>
             throw new InvalidObjectException("Proxy required");<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Finally, provide a <code class="calibre12">readResolve</code> method on the <code class="calibre12">SerializationProxy</code> class that returns a logically equivalent instance of the enclosing class. The presence
         of this method causes the serialization system to translate the serialization proxy
         back into an instance of the enclosing class upon deserialization.
      </p>
      
      <p class="indent">This <code class="calibre12">readResolve</code> method creates an instance of the enclosing class using only its public API and therein
         lies the beauty of the pattern. It largely eliminates the extralinguistic character
         of serialization, because the deserialized instance is created using the same constructors,
         static factories, and methods as any other instance. This frees you from having to
         separately ensure that deserialized instances obey the class’s invariants. If the
         class’s static factories or constructors establish these invariants and its instance
         methods maintain them, you’ve ensured that the invariants will be maintained by serialization
         as well.
      </p>
      
      <p class="indent">Here is the <code class="calibre12">readResolve</code> method for <code class="calibre12">Period.SerializationProxy</code> above:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex26a" id="pch12ex26" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// readResolve method for Period.SerializationProxy</strong><br class="calibre7"/>
         private Object readResolve() {<br class="calibre7"/>
             return new Period(start, end);    // Uses public constructor<br class="calibre7"/>
         }
      </p>
      
      <p class="indent">Like the defensive copying approach (page 357), the serialization proxy approach stops
         the bogus byte-stream attack (page 354) and the internal field theft attack (page
         356) dead in their tracks. Unlike the two previous approaches, this one allows the
         fields of <code class="calibre12">Period</code> to be final, which is required in order for the <code class="calibre12">Period</code> class to be truly immutable (<a href="ch4.xhtml#lev17" class="calibre8">Item 17</a>). And unlike the two previous approaches, this one doesn’t involve a great deal of
         thought. You don’t have to <span epub:type="pagebreak" id="page_365"></span>figure out which fields might be compromised by devious serialization attacks, nor
         do you have to explicitly perform validity checking as part of deserialization.
      </p>
      
      <p class="indent">There is another way in which the serialization proxy pattern is more powerful than
         defensive copying in <code class="calibre12">readObject</code>. The serialization proxy pattern allows the deserialized instance to have a different
         class from the originally serialized instance. You might not think that this would
         be useful in practice, but it is.
      </p>
      
      <p class="indent">Consider the case of <code class="calibre12">EnumSet</code> (<a href="ch6.xhtml#lev36" class="calibre8">Item 36</a>). This class has no public constructors, only static factories. From the client’s
         perspective, they return <code class="calibre12">EnumSet</code> instances, but in the current OpenJDK implementation, they return one of two subclasses,
         depending on the size of the underlying enum type. If the underlying enum type has
         sixty-four or fewer elements, the static factories return a <code class="calibre12">RegularEnumSet</code>; otherwise, they return a <code class="calibre12">JumboEnumSet</code>.
      </p>
      
      <p class="indent">Now consider what happens if you serialize an enum set whose enum type has sixty elements,
         then add five more elements to the enum type, and then deserialize the enum set. It
         was a <code class="calibre12">RegularEnumSet</code> instance when it was serialized, but it had better be a <code class="calibre12">JumboEnumSet</code> instance once it is deserialized. In fact that’s exactly what happens, because <code class="calibre12">EnumSet</code> uses the serialization proxy pattern. In case you’re curious, here is <code class="calibre12">EnumSet</code>’s serialization proxy. It really is this simple:
      </p>
      
      <p class="codelink"><a href="ch12_images.xhtml#pch12ex27a" id="pch12ex27" class="calibre8">Click here to view code image</a></p>
      
      <p class="pre"><strong class="calibre11">// EnumSet's serialization proxy</strong><br class="calibre7"/>
         private static class SerializationProxy &lt;E extends Enum&lt;E&gt;&gt;<br class="calibre7"/>
                 implements Serializable {<br class="calibre7"/>
             // The element type of this enum set.<br class="calibre7"/>
             private final Class&lt;E&gt; elementType;<br class="calibre7"/>
         <br class="calibre7"/>
             // The elements contained in this enum set.<br class="calibre7"/>
             private final Enum&lt;?&gt;[] elements;<br class="calibre7"/>
         <br class="calibre7"/>
             SerializationProxy(EnumSet&lt;E&gt; set) {<br class="calibre7"/>
                 elementType = set.elementType;<br class="calibre7"/>
                 elements = set.toArray(new Enum&lt;?&gt;[0]);<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private Object readResolve() {<br class="calibre7"/>
                 EnumSet&lt;E&gt; result = EnumSet.noneOf(elementType);<br class="calibre7"/>
                 for (Enum&lt;?&gt; e : elements)<br class="calibre7"/>
                     result.add((E)e);<br class="calibre7"/>
                 return result;<br class="calibre7"/>
             }<br class="calibre7"/>
         <br class="calibre7"/>
             private static final long serialVersionUID =<br class="calibre7"/>
                 362491234563181265L;<br class="calibre7"/>
         }
      </p>
      
      <p class="indent"><span epub:type="pagebreak" id="page_366"></span>The serialization proxy pattern has two limitations. It is not compatible with classes
         that are extendable by their users (<a href="ch4.xhtml#lev19" class="calibre8">Item 19</a>). Also, it is not compatible with some classes whose object graphs contain circularities:
         if you attempt to invoke a method on such an object from within its serialization
         proxy’s <code class="calibre12">readResolve</code> method, you’ll get a <code class="calibre12">ClassCastException</code> because you don’t have the object yet, only its serialization proxy.
      </p>
      
      <p class="indent">Finally, the added power and safety of the serialization proxy pattern are not free.
         On my machine, it is 14 percent more expensive to serialize and deserialize <code class="calibre12">Period</code> instances with serialization proxies than it is with defensive copying.
      </p>
      
      <p class="indent">In summary, consider the serialization proxy pattern whenever you find yourself having
         to write a <code class="calibre12">readObject</code> or <code class="calibre12">writeObject</code> method on a class that is not extendable by its clients. This pattern is perhaps
         the easiest way to robustly serialize objects with nontrivial invariants.
      </p>
      
   
   


  </div>

  
  <div class="calibreToc">
    <h2><a href="../../../4bgup-l038f.html">Table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="cover.xhtml">Cover Page</a>
    </li>
    <li>
      <a href="pref00.xhtml">About This E-Book</a>
    </li>
    <li>
      <a href="title.xhtml">Title Page</a>
    </li>
    <li>
      <a href="copy.xhtml">Copyright Page</a>
    </li>
    <li>
      <a href="ded.xhtml">Dedication</a>
    </li>
    <li>
      <a href="contents.xhtml">Contents</a>
    </li>
    <li>
      <a href="foreword.xhtml#foreword">Foreword</a>
    </li>
    <li>
      <a href="preface.xhtml#preface">Preface</a>
    </li>
    <li>
      <a href="acknowledgments.xhtml#acknowledgments">Acknowledgments</a>
    </li>
    <li>
      <a href="ch1.xhtml#ch1">1 Introduction</a>
    </li>
    <li>
      <a href="ch2.xhtml#ch2">2 Creating and Destroying Objects</a>
      <ul>
        <li>
          <a href="ch2.xhtml#lev1">Item 1: Consider static factory methods instead of constructors</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev2">Item 2: Consider a builder when faced with many constructor parameters</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev3">Item 3: Enforce the singleton property with a private constructor or an enum type</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev4">Item 4: Enforce noninstantiability with a private constructor</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev5">Item 5: Prefer dependency injection to hardwiring resources</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev6">Item 6: Avoid creating unnecessary objects</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev7">Item 7: Eliminate obsolete object references</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev8">Item 8: Avoid finalizers and cleaners</a>
        </li>
        <li>
          <a href="ch2.xhtml#lev9">Item 9: Prefer try-with-resources to try-finally</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch3.xhtml#ch3">3 Methods Common to All Objects</a>
      <ul>
        <li>
          <a href="ch3.xhtml#lev10">Item 10: Obey the general contract when overriding equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev11">Item 11: Always override hashCode when you override equals</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev12">Item 12: Always override toString</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev13">Item 13: Override clone judiciously</a>
        </li>
        <li>
          <a href="ch3.xhtml#lev14">Item 14: Consider implementing Comparable</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch4.xhtml#ch4">4 Classes and Interfaces</a>
      <ul>
        <li>
          <a href="ch4.xhtml#lev15">Item 15: Minimize the accessibility of classes and members</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev16">Item 16: In public classes, use accessor methods, not public fields</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev17">Item 17: Minimize mutability</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev18">Item 18: Favor composition over inheritance</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev19">Item 19: Design and document for inheritance or else prohibit it</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev20">Item 20: Prefer interfaces to abstract classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev21">Item 21: Design interfaces for posterity</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev22">Item 22: Use interfaces only to define types</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev23">Item 23: Prefer class hierarchies to tagged classes</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev24">Item 24: Favor static member classes over nonstatic</a>
        </li>
        <li>
          <a href="ch4.xhtml#lev25">Item 25: Limit source files to a single top-level class</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch5.xhtml#ch5">5 Generics</a>
      <ul>
        <li>
          <a href="ch5.xhtml#lev26">Item 26: Don’t use raw types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev27">Item 27: Eliminate unchecked warnings</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev28">Item 28: Prefer lists to arrays</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev29">Item 29: Favor generic types</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev30">Item 30: Favor generic methods</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev31">Item 31: Use bounded wildcards to increase API flexibility</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev32">Item 32: Combine generics and varargs judiciously</a>
        </li>
        <li>
          <a href="ch5.xhtml#lev33">Item 33: Consider typesafe heterogeneous containers</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch6.xhtml#ch6">6 Enums and Annotations</a>
      <ul>
        <li>
          <a href="ch6.xhtml#lev34">Item 34: Use enums instead of int constants</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev35">Item 35: Use instance fields instead of ordinals</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev36">Item 36: Use EnumSet instead of bit fields</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev37">Item 37: Use EnumMap instead of ordinal indexing</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev38">Item 38: Emulate extensible enums with interfaces</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev39">Item 39: Prefer annotations to naming patterns</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev40">Item 40: Consistently use the Override annotation</a>
        </li>
        <li>
          <a href="ch6.xhtml#lev41">Item 41: Use marker interfaces to define types</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch7.xhtml#ch7">7 Lambdas and Streams</a>
      <ul>
        <li>
          <a href="ch7.xhtml#lev42">Item 42: Prefer lambdas to anonymous classes</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev43">Item 43: Prefer method references to lambdas</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev44">Item 44: Favor the use of standard functional interfaces</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev45">Item 45: Use streams judiciously</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev46">Item 46: Prefer side-effect-free functions in streams</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev47">Item 47: Prefer Collection to Stream as a return type</a>
        </li>
        <li>
          <a href="ch7.xhtml#lev48">Item 48: Use caution when making streams parallel</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch8.xhtml#ch8">8 Methods</a>
      <ul>
        <li>
          <a href="ch8.xhtml#lev49">Item 49: Check parameters for validity</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev50">Item 50: Make defensive copies when needed</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev51">Item 51: Design method signatures carefully</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev52">Item 52: Use overloading judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev53">Item 53: Use varargs judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev54">Item 54: Return empty collections or arrays, not nulls</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev55">Item 55: Return optionals judiciously</a>
        </li>
        <li>
          <a href="ch8.xhtml#lev56">Item 56: Write doc comments for all exposed API elements</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch9.xhtml#ch9">9 General Programming</a>
      <ul>
        <li>
          <a href="ch9.xhtml#lev57">Item 57: Minimize the scope of local variables</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev58">Item 58: Prefer for-each loops to traditional for loops</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev59">Item 59: Know and use the libraries</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev60">Item 60: Avoid float and double if exact answers are required</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev61">Item 61: Prefer primitive types to boxed primitives</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev62">Item 62: Avoid strings where other types are more appropriate</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev63">Item 63: Beware the performance of string concatenation</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev64">Item 64: Refer to objects by their interfaces</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev65">Item 65: Prefer interfaces to reflection</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev66">Item 66: Use native methods judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev67">Item 67: Optimize judiciously</a>
        </li>
        <li>
          <a href="ch9.xhtml#lev68">Item 68: Adhere to generally accepted naming conventions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch10.xhtml#ch10">10 Exceptions</a>
      <ul>
        <li>
          <a href="ch10.xhtml#lev69">Item 69: Use exceptions only for exceptional conditions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev70">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev71">Item 71: Avoid unnecessary use of checked exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev72">Item 72: Favor the use of standard exceptions</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev73">Item 73: Throw exceptions appropriate to the abstraction</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev74">Item 74: Document all exceptions thrown by each method</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev75">Item 75: Include failure-capture information in detail messages</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev76">Item 76: Strive for failure atomicity</a>
        </li>
        <li>
          <a href="ch10.xhtml#lev77">Item 77: Don’t ignore exceptions</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch11.xhtml#ch11">11 Concurrency</a>
      <ul>
        <li>
          <a href="ch11.xhtml#lev78">Item 78: Synchronize access to shared mutable data</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev79">Item 79: Avoid excessive synchronization</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev80">Item 80: Prefer executors, tasks, and streams to threads</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev81">Item 81: Prefer concurrency utilities to wait and notify</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev82">Item 82: Document thread safety</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev83">Item 83: Use lazy initialization judiciously</a>
        </li>
        <li>
          <a href="ch11.xhtml#lev84">Item 84: Don’t depend on the thread scheduler</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="ch12.xhtml#ch12">12 Serialization</a>
      <ul>
        <li>
          <a href="ch12.xhtml#lev85">Item 85: Prefer alternatives to Java serialization</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev86">Item 86: Implement Serializable with great caution</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev87">Item 87: Consider using a custom serialized form</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev88">Item 88: Write readObject methods defensively</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev89">Item 89: For instance control, prefer enum types to readResolve</a>
        </li>
        <li>
          <a href="ch12.xhtml#lev90">Item 90: Consider serialization proxies instead of serialized instances</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="app.xhtml#app">Items Corresponding to Second Edition</a>
    </li>
    <li>
      <a href="ref.xhtml#ref">References</a>
    </li>
    <li>
      <a href="index.xhtml#index">Index</a>
    </li>
    <li>
      <a href="ch2_images.xhtml#ch2_images">Code Snippets</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="ch11.xhtml" class="calibreAPrev">previous page
</a>
    

    <a href="../../../4bgup-l038f.html" class="calibreAHome">start
</a>

    
      <a href="app.xhtml" class="calibreANext">next page
</a>
    
  </div>

</div>

</body>
</html>
