<div id="pf1b2" class="pf w4 h1f" data-page-no="1b2"><div class="pc pc1b2 w4 h1f"><img class="bi x0 y0 w3 h4" alt="" src="bg1b2.png"/><div class="t m0 x31 h2 y8e ff1 fs0 fc0 sc0 ls0 ws0"><span class="fc1 sc0">ptg10805159</span></div><div class="t m0 x35 h24 ya4 ff18 fs0 fc0 sc0 ls0 ws0">400<span class="_ _1b"> </span><span class="ff19">Threads <span class="_ _24b"> </span>Chapter<span class="_ _78"> </span><span class="ls7ed">11</span></span></div><div class="t m0 x32 h2a y12f ff19 fsf fc0 sc0 ls0 ws0">see that <span class="_ _2"></span>the mutex <span class="_ _2"></span>is <span class="_ _2"></span>still locked <span class="_ _2"></span>and go <span class="_ _2"></span>back <span class="_ _2"></span>to waiting <span class="_ _2"></span>for it <span class="_ _2"></span>to <span class="_ _2"></span>become available <span class="_ _2"></span>again.</div><div class="t m0 x32 h2a y130 ff19 fsf fc0 sc0 ls0 ws0">In this way<span class="_ _4"></span><span class="ls44">,o<span class="_ _5"></span><span class="ls0">nly one thread will pr<span class="_ _1"></span>oceed at a time.</span></span></div><div class="t m0 x3f h2a y131 ff19 fsf fc0 sc0 ls0 ws0">This <span class="_ _42"> </span>mutual-exclusion <span class="_ _23"> </span>mechanism <span class="_ _42"> </span>works <span class="_ _42"> </span>only <span class="_ _23"> </span>if <span class="_ _42"> </span>we <span class="_ _42"> </span>design <span class="_ _42"> </span>our <span class="_ _23"> </span>threads <span class="_ _42"> </span>to <span class="_ _23"> </span>follow</div><div class="t m0 x32 h2a y132 ff19 fsf fc0 sc0 ls0 ws0">the <span class="_ _2"></span>same <span class="_ _2"></span>data-access <span class="_ _2"></span>rules. <span class="_ _66"> </span>The<span class="_ _47"> </span>operating <span class="_ _2"></span>system <span class="_ _2"></span>doesn’t <span class="_ _2"></span>serialize <span class="_ _2"></span>access <span class="_ _2"></span>to <span class="_ _2"></span>data <span class="_ _3"></span>for <span class="_ _2"></span>us.</div><div class="t m0 x32 h2a y133 ff19 fsf fc0 sc0 ls0 ws0">If <span class="_ _9"></span>we <span class="_ _23"></span>allow <span class="_ _9"></span>one <span class="_ _23"></span>thread <span class="_ _3"></span>to <span class="_ _23"></span>access <span class="_ _9"></span>a <span class="_ _23"></span>shared <span class="_ _9"></span>resour<span class="_ _1"></span>ce <span class="_ _23"></span>without <span class="_ _9"></span>ﬁrst <span class="_ _23"></span>acquiring <span class="_ _9"></span>a <span class="_ _23"></span>lock, <span class="_ _9"></span>then</div><div class="t m0 x32 h2a y134 ff19 fsf fc0 sc0 ls0 ws0">inconsistencies <span class="_ _2"></span>can <span class="_ _2"></span>occur <span class="_ _3"></span>even <span class="_ _2"></span>though <span class="_ _3"></span>the <span class="_ _2"></span>rest <span class="_ _2"></span>of <span class="_ _2"></span>our <span class="_ _2"></span>threads <span class="_ _2"></span>do <span class="_ _3"></span>acquir<span class="ls189">et<span class="_ _8"></span><span class="ls0">he <span class="_ _2"></span>lock <span class="_ _3"></span>before</span></span></div><div class="t m0 x32 h2a y135 ff19 fsf fc0 sc0 ls0 ws0">attempting to access the shared r<span class="_ _0"></span>esour<span class="_ _0"></span>ce.</div><div class="t m0 x3f h26 y136 ff19 fsf fc0 sc0 ls5c8 ws0">Am<span class="_ _43"></span><span class="ls0">utex <span class="_ _23"> </span>variable <span class="_ _23"> </span>is <span class="_ _23"> </span>represented <span class="_ _9"></span>by <span class="_ _23"> </span>the<span class="_ _35"> </span><span class="ff1a">pthread_mutex_t<span class="_ _35"> </span></span>data <span class="_ _23"> </span>type.<span class="_ _51"> </span>Befor<span class="lsd49">ew<span class="_ _43"></span><span class="ls0">e</span></span></span></div><div class="t m0 x32 h2a y137 ff19 fsf fc0 sc0 ls0 ws0">can <span class="_ _23"></span>use <span class="_ _9"></span>a <span class="_ _23"> </span>mutex <span class="_ _23"> </span>variable, <span class="_ _23"> </span>we <span class="_ _23"></span>must <span class="_ _23"></span>ﬁrst <span class="_ _23"></span>initialize <span class="_ _9"></span>it <span class="_ _23"> </span>by <span class="_ _23"> </span>either <span class="_ _23"></span>setting <span class="_ _23"></span>it <span class="_ _23"></span>to <span class="_ _9"></span>the <span class="_ _23"> </span>constant</div><div class="t m0 x32 h26 y138 ff1a fsf fc0 sc0 ls0 ws0">PTHREAD_MUTEX_INITIALIZER<span class="_ _51"> </span><span class="ff19">(for <span class="_ _44"> </span>statically <span class="_ _35"> </span>allocated <span class="_ _44"> </span>mutexes <span class="_ _44"> </span>only) <span class="_ _35"> </span>or <span class="_ _44"> </span>calling</span></div><div class="t m0 x32 h26 y139 ff1a fsf fc0 sc0 ls0 ws0">pthread_mutex_init<span class="ff19 lsddd">.I<span class="_ _62"></span><span class="ls0">f<span class="_ _45"> </span>we<span class="_ _47"> </span>allocate <span class="_ _3"></span>the <span class="_ _3"></span>mutex <span class="_ _9"></span>dynamically <span class="_ _3"></span>(by <span class="_ _3"></span>calling<span class="_ _45"> </span><span class="ff1a">malloc</span><span class="ls4e8">,f<span class="_ _b"></span><span class="ls0">or</span></span></span></span></div><div class="t m0 x32 h26 y13a ff19 fsf fc0 sc0 ls0 ws0">example), then we need to call<span class="_"> </span><span class="ff1a">pthread_mutex_destroy<span class="_ _80"> </span></span>befor<span class="ls44">ef<span class="_ _d"></span><span class="ls45">re<span class="_ _2"></span><span class="ls0">eing the memory<span class="_ _4"></span>.</span></span></span></div><div class="t m0 x3f h57 y3303 ff1a fs2d fc0 sc0 ls0 ws0">#include &lt;pthread.h&gt;</div><div class="t m0 x3f h57 y3304 ff1a fs2d fc0 sc0 ls0 ws0">int pthread_mutex_init(pthread_mutex_t *restrict<span class="_"> </span><span class="ff1b">mutex</span>,</div><div class="t m0 x17c h57 y3305 ff1a fs2d fc0 sc0 ls0 ws0">const pthread_mutexattr_t *restrict<span class="_"> </span><span class="ff1b">attr</span>);</div><div class="t m0 x3f h57 y3306 ff1a fs2d fc0 sc0 ls0 ws0">int pthread_mutex_destroy(pthread_mutex_t *<span class="ff1b">mutex</span>);</div><div class="t m0 xca h5f y3307 ff19 fs2d fc0 sc0 ls0 ws0">Both return: 0 if OK, err<span class="_ _0"></span>or number on failure</div><div class="t m0 x32 h4d y3308 ff19 fs26 fc0 sc0 ls164 ws0">To <span class="_ _47"> </span>i<span class="_ _9"></span><span class="ls0">nitialize <span class="_ _23"> </span>a <span class="_ _42"> </span>mutex <span class="_ _23"></span>with <span class="_ _23"></span>the <span class="_ _23"> </span>default <span class="_ _23"> </span>attributes, <span class="_ _23"> </span>we <span class="_ _42"> </span>set<span class="_ _45"> </span><span class="ff1b">attr<span class="_ _35"> </span></span>to<span class="_ _35"> </span><span class="ff1a">NULL</span><span class="lsdde">.W<span class="_ _64"></span><span class="lsddf">ew<span class="_ _43"></span><span class="ls0">ill <span class="_ _42"> </span>discuss</span></span></span></span></div><div class="t m0 x32 h49 y3309 ff19 fs26 fc0 sc0 ls0 ws0">mutex attributes in Section 12.4.</div><div class="t m0 x3f h4d y330a ff19 fs26 fc0 sc0 ls164 ws0">To <span class="_ _47"> </span>l<span class="_ _9"></span><span class="ls0">ock <span class="_ _42"> </span>a <span class="_ _23"></span>mutex, <span class="_ _23"> </span>we <span class="_ _23"> </span>call<span class="_ _35"> </span><span class="ff1a">pthread_mutex_lock</span><span class="lsde0">.I<span class="_ _26"></span><span class="lsde1">ft<span class="_ _43"></span><span class="ls0">he <span class="_ _23"> </span>mutex <span class="_ _23"> </span>is <span class="_ _42"> </span>already <span class="_ _9"></span>locked,</span></span></span></span></div><div class="t m0 x32 h49 y330b ff19 fs26 fc0 sc0 ls0 ws0">the <span class="_ _23"></span>calling <span class="_ _23"></span>thread <span class="_ _9"></span>will <span class="_ _42"> </span>block <span class="_ _23"></span>until <span class="_ _23"></span>the <span class="_ _23"></span>mutex <span class="_ _23"></span>is <span class="_ _23"></span>unlocked.<span class="_ _51"> </span><span class="ls164">To <span class="_ _47"> </span>u<span class="_ _9"></span></span>nlock <span class="_ _23"> </span>a <span class="_ _23"> </span>mutex, <span class="_ _42"> </span>we <span class="_ _23"></span>call</div><div class="t m0 x32 h4d y330c ff1a fs26 fc0 sc0 ls0 ws0">pthread_mutex_unlock<span class="ff19">.</span></div><div class="t m0 x3f h4e y330d ff1a fs28 fc0 sc0 ls0 ws0">#include &lt;pthread.h&gt;</div><div class="t m0 x3f h4e y330e ff1a fs28 fc0 sc0 ls0 ws0">int pthread_mutex_lock(pthread_mutex_t *<span class="ff1b">mutex</span>);</div><div class="t m0 x3f h4e y330f ff1a fs28 fc0 sc0 ls0 ws0">int pthread_mutex_trylock(pthread_mutex_t *<span class="ff1b">mutex</span>);</div><div class="t m0 x3f h4e y3310 ff1a fs28 fc0 sc0 ls0 ws0">int pthread_mutex_unlock(pthread_mutex_t *<span class="ff1b">mutex</span>);</div><div class="t m0 x7f h7c y3311 ff19 fs28 fc0 sc0 ls0 ws0">All return: 0 if OK, err<span class="_ _0"></span>or number on failure</div><div class="t m0 x3f h54 y3312 ff19 fs2c fc0 sc0 ls0 ws0">If <span class="_ _9"></span>a <span class="_ _9"></span>thread <span class="_ _9"></span>can’t <span class="_ _23"></span>af<span class="_ _0"></span>ford<span class="_ _45"> </span>to<span class="_ _45"> </span>block, <span class="_ _9"></span>it <span class="_ _9"></span>can <span class="_ _23"></span>use<span class="_ _45"> </span><span class="ff1a">pthread_mutex_trylock<span class="_ _45"> </span></span>to <span class="_ _9"></span>lock <span class="_ _23"></span>the</div><div class="t m0 x32 h54 y3313 ff19 fs2c fc0 sc0 ls0 ws0">mutex <span class="_ _9"></span>conditionally<span class="_ _6"></span><span class="lsde2">.I<span class="_ _26"></span><span class="lsde3">ft<span class="_ _b"></span><span class="ls0">he <span class="_ _9"></span>mutex <span class="_ _23"></span>is <span class="_ _9"></span>unlocked <span class="_ _9"></span>at <span class="_ _23"></span>the <span class="_ _9"></span>time<span class="_ _45"> </span><span class="ff1a">pthread_mutex_trylock</span></span></span></span></div><div class="t m0 x32 h54 y3314 ff19 fs2c fc0 sc0 ls0 ws0">is <span class="_ _42"> </span>called, <span class="_ _42"> </span>then<span class="_ _44"> </span><span class="ff1a">pthread_mutex_trylock<span class="_ _44"> </span></span>will <span class="_ _42"> </span>lock <span class="_ _42"> </span>the <span class="_ _42"> </span>mutex <span class="_ _42"> </span>without <span class="_ _42"> </span>blocking <span class="_ _53"> </span>and</div><div class="t m0 x32 h54 y3315 ff19 fs2c fc0 sc0 ls150 ws0">re<span class="ls0">turn <span class="_"> </span>0.<span class="_ _65"> </span>Otherwise,<span class="_ _59"> </span><span class="ff1a">pthread_mutex_trylock<span class="_ _4b"> </span></span>will <span class="_"> </span>fail, <span class="_ _53"> </span>returning<span class="_ _4b"> </span><span class="ff1a">EBUSY<span class="_ _59"> </span></span>without</span></div><div class="t m0 x32 h55 y3316 ff19 fs2c fc0 sc0 ls0 ws0">locking the mutex.</div><div class="t m0 x35 h61 y3317 ff16 fs2c fc0 sc0 ls0 ws0">Example</div><div class="t m0 x32 h55 y3318 ff19 fs2c fc0 sc0 ls0 ws0">Figur<span class="lsde4">e1<span class="_ _c"></span><span class="ls0">1.10 <span class="_ _23"></span>illustrates <span class="_ _9"></span>a <span class="_ _9"></span>mutex <span class="_ _9"></span>used <span class="_ _9"></span>to <span class="_ _9"></span>protect <span class="_ _9"></span>a <span class="_ _9"></span>data <span class="_ _9"></span>structure. <span class="_ _45"> </span>When<span class="_ _45"> </span>mor<span class="lsde4">et<span class="_ _b"></span><span class="ls0">han <span class="_ _3"></span>one</span></span></span></span></div><div class="t m0 x32 h55 y3319 ff19 fs2c fc0 sc0 ls0 ws0">thread <span class="_ _3"></span>needs <span class="_ _9"></span>to <span class="_ _9"></span>access <span class="_ _3"></span>a <span class="_ _9"></span>dynamically <span class="_ _9"></span>allocated <span class="_ _9"></span>object, <span class="_ _9"></span>we <span class="_ _3"></span>can <span class="_ _9"></span>embed <span class="_ _9"></span>a <span class="_ _9"></span>refer<span class="_ _0"></span>ence <span class="_ _3"></span>count</div><div class="t m0 x32 h55 y331a ff19 fs2c fc0 sc0 ls0 ws0">in the object <span class="_ _2"></span>to ensur<span class="lsde5">et<span class="_ _d"></span><span class="ls0">hat we <span class="_ _2"></span>don’t free its memory <span class="_ _2"></span>befor<span class="lsde5">ea<span class="_ _4f"></span><span class="ls0">ll threads ar<span class="lsde6">ed<span class="_ _4f"></span><span class="ls0">one <span class="_ _2"></span>using it.</span></span></span></span></span></span></div></div><div class="pi" data-data='{"ctm":[2.100000,0.000000,0.000000,2.100000,-115.668004,-156.491993]}'></div></div>
