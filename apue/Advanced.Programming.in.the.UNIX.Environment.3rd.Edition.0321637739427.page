<div id="pf1ab" class="pf w4 h1f" data-page-no="1ab"><div class="pc pc1ab w4 h1f"><img class="bi x0 y0 w3 h4" alt="" src="apue/bg1ab.png"/><div class="t m0 x31 h2 y8e ff1 fs0 fc0 sc0 ls0 ws0"><span class="fc1 sc0">ptg10805159</span></div><div class="t m0 x35 h24 ya4 ff19 fs0 fc0 sc0 ls0 ws0">Section <span class="_"> </span>1<span class="_ _1"></span>1.5 <span class="_ _1c9"> </span>Thr<span class="_ _1"></span>ead <span class="_"> </span>T<span class="_ _1"></span>ermination<span class="_ _1b"> </span><span class="ff18">393</span></div><div class="t m0 x3f h2a y12f ff19 fsf fc0 sc0 ls0 ws0">On Mac OS X, we get differ<span class="_ _0"></span>ent r<span class="_ _0"></span>esults:</div><div class="t m0 x3f h57 ya9b ff1a fs2d fc0 sc0 ls0 ws0">$<span class="_"> </span><span class="ff1f">./a.out</span></div><div class="t m0 x3f h57 yac1 ff1a fs2d fc0 sc0 ls0 ws0">thread 1:</div><div class="t m0 xf4 h57 yac2 ff1a fs2d fc0 sc0 ls0 ws0">structure at 0x1000b6f00</div><div class="t m0 xf4 h57 yac3 ff1a fs2d fc0 sc0 ls0 ws0">foo.a = 1</div><div class="t m0 xf4 h57 yac4 ff1a fs2d fc0 sc0 ls0 ws0">foo.b = 2</div><div class="t m0 xf4 h57 yac5 ff1a fs2d fc0 sc0 ls0 ws0">foo.c = 3</div><div class="t m0 xf4 h57 y321e ff1a fs2d fc0 sc0 ls0 ws0">foo.d = 4</div><div class="t m0 x3f h57 y321f ff1a fs2d fc0 sc0 ls0 ws0">parent starting second thread</div><div class="t m0 x3f h57 y3220 ff1a fs2d fc0 sc0 ls0 ws0">thread 2: ID is 4295716864</div><div class="t m0 x3f h57 y3221 ff1a fs2d fc0 sc0 ls0 ws0">parent:</div><div class="t m0 xf4 h57 y3222 ff1a fs2d fc0 sc0 ls0 ws0">structure at 0x1000b6f00</div><div class="t m0 x3f h57 y3223 ff1a fs2d fc0 sc0 ls0 ws0">Segmentation fault (core dumped)</div><div class="t m0 x32 h2a y3224 ff19 fsf fc0 sc0 ls0 ws0">In <span class="_ _2"></span>this <span class="_ _3"></span>case, <span class="_ _2"></span>the <span class="_ _3"></span>memory <span class="_ _3"></span>is <span class="_ _2"></span>no <span class="_ _3"></span>longer <span class="_ _3"></span>valid <span class="_ _2"></span>when <span class="_ _3"></span>the <span class="_ _2"></span>parent <span class="_ _3"></span>tries <span class="_ _2"></span>to <span class="_ _3"></span>access <span class="_ _2"></span>the <span class="_ _3"></span>structure</div><div class="t m0 x32 h26 y3225 ff19 fsf fc0 sc0 ls0 ws0">passed to it by the ﬁrst thread that exited, and the par<span class="_ _0"></span>ent is sent the<span class="_"> </span><span class="ff1a">SIGSEGV<span class="_ _80"> </span></span>signal.</div><div class="t m0 x3f h2a y3226 ff19 fsf fc0 sc0 ls0 ws0">On FreeBSD, the memory <span class="_ _2"></span>hasn’t <span class="_ _2"></span>been overwritten <span class="_ _2"></span>by the <span class="_ _2"></span>time the <span class="_ _2"></span>parent accesses it,</div><div class="t m0 x32 h2a y3227 ff19 fsf fc0 sc0 ls0 ws0">and we get</div><div class="t m0 x3f h57 y3228 ff1a fs2d fc0 sc0 ls0 ws0">thread 1:</div><div class="t m0 xf4 h57 y3229 ff1a fs2d fc0 sc0 ls0 ws0">structure at 0xbf9fef88</div><div class="t m0 xf4 h57 y322a ff1a fs2d fc0 sc0 ls0 ws0">foo.a = 1</div><div class="t m0 xf4 h57 y322b ff1a fs2d fc0 sc0 ls0 ws0">foo.b = 2</div><div class="t m0 xf4 h57 y322c ff1a fs2d fc0 sc0 ls0 ws0">foo.c = 3</div><div class="t m0 xf4 h57 y322d ff1a fs2d fc0 sc0 ls0 ws0">foo.d = 4</div><div class="t m0 x3f h57 y322e ff1a fs2d fc0 sc0 ls0 ws0">parent starting second thread</div><div class="t m0 x3f h57 y322f ff1a fs2d fc0 sc0 ls0 ws0">thread 2: ID is 673279680</div><div class="t m0 x3f h57 y3230 ff1a fs2d fc0 sc0 ls0 ws0">parent:</div><div class="t m0 xf4 h57 y3231 ff1a fs2d fc0 sc0 ls0 ws0">structure at 0xbf9fef88</div><div class="t m0 xf4 h57 y3232 ff1a fs2d fc0 sc0 ls0 ws0">foo.a = 1</div><div class="t m0 xf4 h57 y3233 ff1a fs2d fc0 sc0 ls0 ws0">foo.b = 2</div><div class="t m0 xf4 h57 y3234 ff1a fs2d fc0 sc0 ls0 ws0">foo.c = 3</div><div class="t m0 xf4 h57 y3235 ff1a fs2d fc0 sc0 ls0 ws0">foo.d = 4</div><div class="t m0 x32 h2a y3236 ff19 fsf fc0 sc0 ls0 ws0">Even <span class="_ _23"></span>though <span class="_ _23"></span>the <span class="_ _9"></span>memory <span class="_ _23"> </span>is <span class="_ _23"> </span>still <span class="_ _23"> </span>intact <span class="_ _23"> </span>after <span class="_ _23"></span>the <span class="_ _23"></span>thread <span class="_ _9"></span>exits, <span class="_ _23"> </span>we <span class="_ _23"> </span>can’t <span class="_ _23"> </span>depend <span class="_ _23"></span>on <span class="_ _23"></span>this</div><div class="t m0 x32 h2a y3237 ff19 fsf fc0 sc0 ls0 ws0">always being the case.<span class="_ _59"> </span>It certainly isn’t what we observe on the other platforms.</div><div class="t m0 x3f h49 y3238 ff19 fs26 fc0 sc0 ls0 ws0">One <span class="_ _3"></span>thread <span class="_ _3"></span>can <span class="_ _3"></span>request <span class="_ _3"></span>that <span class="_ _3"></span>another <span class="_ _9"></span>in <span class="_ _3"></span>the <span class="_ _9"></span>same <span class="_ _3"></span>process <span class="_ _3"></span>be <span class="_ _3"></span>canceled <span class="_ _9"></span>by <span class="_ _3"></span>calling <span class="_ _3"></span>the</div><div class="t m0 x32 h4d y3239 ff1a fs26 fc0 sc0 ls0 ws0">pthread_cancel<span class="_ _80"> </span><span class="ff19">function.</span></div><div class="t m0 x3f h4e y323a ff1a fs28 fc0 sc0 ls0 ws0">#include &lt;pthread.h&gt;</div><div class="t m0 x3f h4e y323b ff1a fs28 fc0 sc0 ls0 ws0">int pthread_cancel(pthread_t<span class="_"> </span><span class="ff1b">tid</span>);</div><div class="t m0 x78 h7c y323c ff19 fs28 fc0 sc0 ls0 ws0">Returns: 0 if OK, error number on failur<span class="_ _0"></span>e</div><div class="t m0 x32 h54 y323d ff19 fs2c fc0 sc0 ls0 ws0">In the <span class="_ _2"></span>default <span class="_ _2"></span>circumstances,<span class="_"> </span><span class="ff1a">pthread_cancel<span class="_ _66"> </span></span>will <span class="_ _2"></span>cause <span class="_ _2"></span>the thread speciﬁed <span class="_ _2"></span>by<span class="_ _66"> </span><span class="ff1b">tid<span class="_ _66"> </span></span>to</div><div class="t m0 x32 h54 y323e ff19 fs2c fc0 sc0 ls0 ws0">behave <span class="_ _23"></span>as <span class="_ _23"></span>if <span class="_ _9"></span>it <span class="_ _23"> </span>had <span class="_ _23"> </span>called<span class="_ _35"> </span><span class="ff1a">pthread_exit<span class="_ _45"> </span></span>with <span class="_ _23"> </span>an <span class="_ _23"> </span>argument <span class="_ _23"></span>of<span class="_ _45"> </span><span class="ff1a">PTHREAD_CANCELED</span>.</div><div class="t m0 x32 h55 y323f ff19 fs2c fc0 sc0 ls0 ws0">However<span class="_ _6"></span><span class="lsdb0">,at<span class="_ _8"></span><span class="ls0">hread <span class="_ _3"></span>can <span class="_ _9"></span>elect <span class="_ _9"></span>to <span class="_ _9"></span>ignore<span class="_ _47"> </span>or<span class="_ _45"> </span>otherwise <span class="_ _9"></span>control <span class="_ _3"></span>how <span class="_ _9"></span>it <span class="_ _9"></span>is <span class="_ _3"></span>canceled.<span class="_ _5a"> </span><span class="ls155">We <span class="_ _66"> </span>w<span class="_ _9"></span></span>ill</span></span></div><div class="t m0 x32 h54 y3240 ff19 fs2c fc0 sc0 ls0 ws0">discuss <span class="_ _9"></span>this <span class="_ _3"></span>in <span class="_ _9"></span>detail <span class="_ _9"></span>in <span class="_ _9"></span>Section <span class="_ _9"></span>12.7.<span class="_ _5a"> </span>Note <span class="_ _9"></span>that<span class="_ _45"> </span><span class="ff1a">pthread_cancel<span class="_ _47"> </span></span>doesn’t <span class="_ _9"></span>wait <span class="_ _9"></span>for <span class="_ _9"></span>the</div><div class="t m0 x32 h55 y3241 ff19 fs2c fc0 sc0 ls0 ws0">thread to terminate; it mer<span class="_ _0"></span>ely makes the r<span class="_ _0"></span>equest.</div></div><div class="pi" data-data='{"ctm":[2.100000,0.000000,0.000000,2.100000,-115.668004,-156.491993]}'></div></div>
