<div id="pf1d8" class="pf w4 h1f" data-page-no="1d8"><div class="pc pc1d8 w4 h1f"><img class="bi x0 y0 w3 h4" alt="" src="apue/bg1d8.png"/><div class="t m0 x31 h2 y8e ff1 fs0 fc0 sc0 ls0 ws0"><span class="fc1 sc0">ptg10805159</span></div><div class="t m0 x35 h24 ya4 ff18 fs0 fc0 sc0 ls0 ws0">438<span class="_ _1b"> </span><span class="ff19">Thread <span class="_"> </span>Contr<span class="_ _0"></span>ol <span class="_ _177"> </span>Chapter<span class="_ _44"> </span>12</span></div><div class="t m0 x1ca h57 y425 ff1a fs2d fc0 sc0 ls0 ws0">tip-&gt;to_wait.tv_sec--;</div><div class="t m0 x1ca h57 y426 ff1a fs2d fc0 sc0 ls0 ws0">tip-&gt;to_wait.tv_nsec = SECTONSEC - now.tv_nsec +</div><div class="t m0 x10d h57 y800 ff1a fs2d fc0 sc0 ls0 ws0">when-&gt;tv_nsec;</div><div class="t m0 x1f h57 y801 ff1a fs2d fc0 sc0 ls0 ws0">}</div><div class="t m0 x1f h57 y802 ff1a fs2d fc0 sc0 ls0 ws0">err = makethread(timeout_helper, (void *)tip);</div><div class="t m0 x1f h57 y803 ff1a fs2d fc0 sc0 ls0 ws0">if (err == 0)</div><div class="t m0 x1ca h57 y804 ff1a fs2d fc0 sc0 ls0 ws0">return;</div><div class="t m0 x1f h57 y805 ff1a fs2d fc0 sc0 ls0 ws0">else</div><div class="t m0 x1ca h57 y806 ff1a fs2d fc0 sc0 ls0 ws0">free(tip);</div><div class="t m0 x9d h57 y807 ff1a fs2d fc0 sc0 ls0 ws0">}</div><div class="t m0 x8a h57 y808 ff1a fs2d fc0 sc0 ls0 ws0">}</div><div class="t m0 x8a h57 y871 ff1a fs2d fc0 sc0 ls0 ws0">/*</div><div class="t m0 x214 h57 y36a3 ff1a fs2d fc0 sc0 ls0 ws0">*<span class="_"> </span>We<span class="_"> </span>get here if (a) when &lt;= now, or (b) malloc fails, or</div><div class="t m0 x214 h57 y36a4 ff1a fs2d fc0 sc0 ls15c ws0">*(<span class="_ _1d"></span><span class="ls0">c) we can’t make a thread, so we just call the function now.</span></div><div class="t m0 x214 h57 y36a5 ff1a fs2d fc0 sc0 ls0 ws0">*/</div><div class="t m0 x8a h57 y36a6 ff1a fs2d fc0 sc0 ls0 ws0">(*func)(arg);</div><div class="t m0 x32 h57 y36a7 ff1a fs2d fc0 sc0 ls0 ws0">}</div><div class="t m0 x32 h57 y877 ff1a fs2d fc0 sc0 ls0 ws0">pthread_mutexattr_t attr;</div><div class="t m0 x32 h57 y878 ff1a fs2d fc0 sc0 ls0 ws0">pthread_mutex_t mutex;</div><div class="t m0 x32 h57 y23d1 ff1a fs2d fc0 sc0 ls0 ws0">void</div><div class="t m0 x32 h57 y23d2 ff1a fs2d fc0 sc0 ls0 ws0">retry(void *arg)</div><div class="t m0 x32 h57 y23d3 ff1a fs2d fc0 sc0 ls0 ws0">{</div><div class="t m0 x8a h57 y3358 ff1a fs2d fc0 sc0 ls0 ws0">pthread_mutex_lock(&amp;mutex);</div><div class="t m0 x8a h57 y23d5 ff1a fs2d fc0 sc0 ls0 ws0">/* perform retry steps ... */</div><div class="t m0 x8a h57 y36a8 ff1a fs2d fc0 sc0 ls0 ws0">pthread_mutex_unlock(&amp;mutex);</div><div class="t m0 x32 h57 y36a9 ff1a fs2d fc0 sc0 ls0 ws0">}</div><div class="t m0 x32 h57 y368e ff1a fs2d fc0 sc0 ls0 ws0">int</div><div class="t m0 x32 h57 y368f ff1a fs2d fc0 sc0 ls0 ws0">main(void)</div><div class="t m0 x32 h57 y3690 ff1a fs2d fc0 sc0 ls0 ws0">{</div><div class="t m0 x8a h57 y3691 ff1a fs2d fc0 sc0 ls0 ws0">int <span class="_ _82"> </span>err,<span class="_"> </span>condition, arg;</div><div class="t m0 x8a h57 y36aa ff1a fs2d fc0 sc0 ls0 ws0">struct timespec when;</div><div class="t m0 x8a h57 y3693 ff1a fs2d fc0 sc0 ls0 ws0">if ((err = pthread_mutexattr_init(&amp;attr)) != 0)</div><div class="t m0 x9d h57 y3694 ff1a fs2d fc0 sc0 ls0 ws0">err_exit(err, &quot;pthread_mutexattr_init failed&quot;);</div><div class="t m0 x8a h57 y3695 ff1a fs2d fc0 sc0 ls0 ws0">if ((err = pthread_mutexattr_settype(&amp;attr,</div><div class="t m0 x194 h57 y3696 ff1a fs2d fc0 sc0 ls0 ws0">PTHREAD_MUTEX_RECURSIVE)) != 0)</div><div class="t m0 x9d h57 y3697 ff1a fs2d fc0 sc0 ls0 ws0">err_exit(err, &quot;can’t set recursive type&quot;);</div><div class="t m0 x8a h57 y36ab ff1a fs2d fc0 sc0 ls0 ws0">if ((err = pthread_mutex_init(&amp;mutex, &amp;attr)) != 0)</div><div class="t m0 x9d h57 y36ac ff1a fs2d fc0 sc0 ls0 ws0">err_exit(err, &quot;can’t create recursive mutex&quot;);</div><div class="t m0 x8a h57 y369a ff1a fs2d fc0 sc0 ls0 ws0">/* continue processing ... */</div><div class="t m0 x8a h57 y36ad ff1a fs2d fc0 sc0 ls0 ws0">pthread_mutex_lock(&amp;mutex);</div><div class="t m0 x8a h57 y36ae ff1a fs2d fc0 sc0 ls0 ws0">/*</div><div class="t m0 x214 h57 y36af ff1a fs2d fc0 sc0 ls15c ws0">*C<span class="_ _1d"></span><span class="ls0">heck the condition under the protection of a lock to</span></div><div class="t m0 x214 h57 y36b0 ff1a fs2d fc0 sc0 ls15c ws0">*m<span class="_ _1d"></span><span class="ls0">ake the check and the call to timeout atomic.</span></div><div class="t m0 x214 h57 y36b1 ff1a fs2d fc0 sc0 ls0 ws0">*/</div><div class="t m0 x8a h57 y36b2 ff1a fs2d fc0 sc0 ls0 ws0">if (condition) {</div><div class="t m0 x9d h57 y36b3 ff1a fs2d fc0 sc0 ls0 ws0">/*</div></div><div class="pi" data-data='{"ctm":[2.100000,0.000000,0.000000,2.100000,-115.668004,-156.491993]}'></div></div>
