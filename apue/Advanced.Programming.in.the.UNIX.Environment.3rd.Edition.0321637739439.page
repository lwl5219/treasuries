<div id="pf1b7" class="pf w4 h1f" data-page-no="1b7"><div class="pc pc1b7 w4 h1f"><img class="bi x0 y0 w3 h4" alt="" src="bg1b7.png"/><div class="t m0 x31 h2 y8e ff1 fs0 fc0 sc0 ls0 ws0"><span class="fc1 sc0">ptg10805159</span></div><div class="t m0 x35 h24 ya4 ff19 fs0 fc0 sc0 ls0 ws0">Section <span class="_"> </span>1<span class="_ _1"></span>1.6 <span class="_ _284"> </span>Thread <span class="_"> </span>Synchr<span class="_ _0"></span>onization<span class="_ _1b"> </span><span class="ff18">405</span></div><div class="t m0 x3f h2a y12f ff19 fsf fc0 sc0 ls0 ws0">Comparing <span class="_ _3"></span>Figur<span class="lsdfc">e1<span class="_ _43"></span><span class="ls0">1.1<span class="_ _1"></span><span class="lsdfc">1w<span class="_ _8"></span><span class="ls0">ith <span class="_ _9"></span>Figur<span class="lsdfd">e1<span class="_ _43"></span><span class="ls0">1.10, <span class="_ _3"></span>we <span class="_ _9"></span>see <span class="_ _3"></span>that <span class="_ _9"></span>our <span class="_ _3"></span>allocation <span class="_ _9"></span>function <span class="_ _9"></span>now</span></span></span></span></span></span></div><div class="t m0 x32 h2a y130 ff19 fsf fc0 sc0 ls0 ws0">locks <span class="_ _3"></span>the <span class="_ _9"></span>hash <span class="_ _9"></span>list <span class="_ _3"></span>lock, <span class="_ _9"></span>adds <span class="_ _9"></span>the <span class="_ _3"></span>new <span class="_ _9"></span>structure<span class="_ _47"> </span>to<span class="_ _45"> </span>a<span class="_ _45"> </span>hash <span class="_ _3"></span>bucket, <span class="_ _9"></span>and <span class="_ _3"></span>befor<span class="lsdfe">eu<span class="_ _b"></span><span class="ls0">nlocking</span></span></div><div class="t m0 x32 h2a y131 ff19 fsf fc0 sc0 ls0 ws0">the <span class="_ _53"> </span>hash <span class="_ _e"> </span>list <span class="_ _e"> </span>lock, <span class="_ _53"> </span>locks <span class="_ _e"> </span>the <span class="_ _e"> </span>mutex <span class="_ _e"> </span>in <span class="_ _53"> </span>the <span class="_ _e"> </span>new <span class="_ _e"> </span>structure. <span class="_ _44"> </span>Since<span class="_ _4b"> </span>the <span class="_ _e"> </span>new <span class="_ _e"> </span>structur<span class="ls8ea">ei<span class="_ _55"></span><span class="ls0">s</span></span></div><div class="t m0 x32 h2a y132 ff19 fsf fc0 sc0 ls0 ws0">placed <span class="_ _2"></span>on <span class="_ _3"></span>a <span class="_ _3"></span>global <span class="_ _3"></span>list, <span class="_ _2"></span>other <span class="_ _3"></span>threads <span class="_ _2"></span>can <span class="_ _3"></span>ﬁnd <span class="_ _3"></span>it, <span class="_ _2"></span>so <span class="_ _3"></span>we <span class="_ _3"></span>need <span class="_ _3"></span>to <span class="_ _2"></span>block <span class="_ _3"></span>them <span class="_ _3"></span>if <span class="_ _3"></span>they <span class="_ _2"></span>try <span class="_ _3"></span>to</div><div class="t m0 x32 h2a y133 ff19 fsf fc0 sc0 ls0 ws0">access the new structur<span class="_ _0"></span>e, until we ar<span class="ls44">ed<span class="_ _4f"></span><span class="ls0">one initializing it.</span></span></div><div class="t m0 x3f h26 y134 ff19 fsf fc0 sc0 ls0 ws0">The<span class="_ _59"> </span><span class="ff1a">foo_find<span class="_ _59"> </span></span>function <span class="_ _e"> </span>locks <span class="_"> </span>the <span class="_ _e"> </span>hash <span class="_"> </span>list <span class="_ _e"> </span>lock <span class="_"> </span>and <span class="_ _e"> </span>searches <span class="_ _e"> </span>for <span class="_"> </span>the <span class="_ _e"> </span>requested</div><div class="t m0 x32 h2a y135 ff19 fsf fc0 sc0 ls0 ws0">structur<span class="_ _0"></span>e. <span class="_ _44"> </span>If<span class="_ _44"> </span>it <span class="_ _53"> </span>is <span class="_ _53"> </span>found, <span class="_ _53"> </span>we <span class="_ _42"> </span>increase <span class="_ _42"> </span>the <span class="_ _53"> </span>reference <span class="_ _42"> </span>count <span class="_ _42"> </span>and <span class="_ _53"> </span>return <span class="_ _42"> </span>a <span class="_ _53"> </span>pointer <span class="_ _53"> </span>to <span class="_ _53"> </span>the</div><div class="t m0 x32 h2a y136 ff19 fsf fc0 sc0 ls0 ws0">structur<span class="_ _0"></span>e. <span class="_ _61"> </span>Note<span class="_ _16"> </span>that <span class="_ _47"> </span>we <span class="_ _47"> </span>honor <span class="_ _47"> </span>the <span class="_ _47"> </span>lock <span class="_ _47"> </span>ordering <span class="_ _47"> </span>by <span class="_ _47"> </span>locking <span class="_ _47"> </span>the <span class="_ _47"> </span>hash <span class="_ _47"> </span>list <span class="_ _47"> </span>lock <span class="_ _47"> </span>in</div><div class="t m0 x32 h26 y137 ff1a fsf fc0 sc0 ls0 ws0">foo_find<span class="_ _80"> </span><span class="ff19">before<span class="_"> </span></span>foo_hold<span class="_ _80"> </span><span class="ff19">locks the<span class="_"> </span></span>foo<span class="_ _66"> </span><span class="ff19">structur<span class="_ _0"></span>e’s<span class="_"> </span><span class="ff1a">f_lock<span class="_ _80"> </span></span>mutex.</span></div><div class="t m0 x3f h26 y138 ff19 fsf fc0 sc0 ls0 ws0">Now <span class="_ _2"></span>with <span class="_ _2"></span>two <span class="_ _3"></span>locks, <span class="_ _2"></span>the<span class="_ _47"> </span><span class="ff1a">foo_rele<span class="_ _66"> </span></span>function <span class="_ _2"></span>is <span class="_ _3"></span>mor<span class="ls9f1">ec<span class="_ _8"></span><span class="ls0">omplicated. <span class="_ _47"> </span>If<span class="_ _66"> </span>this <span class="_ _3"></span>is <span class="_ _2"></span>the <span class="_ _2"></span>last</span></span></div><div class="t m0 x32 h2a y139 ff19 fsf fc0 sc0 ls45 ws0">re<span class="ls0">ference, <span class="_ _23"></span>we <span class="_ _23"></span>need <span class="_ _23"> </span>to <span class="_ _23"> </span>unlock <span class="_ _23"> </span>the <span class="_ _23"> </span>structur<span class="lsdff">em<span class="_ _43"></span><span class="ls0">utex <span class="_ _23"> </span>so <span class="_ _23"> </span>that <span class="_ _23"> </span>we <span class="_ _23"> </span>can <span class="_ _42"> </span>acquir<span class="lsdff">et<span class="_ _43"></span><span class="ls0">he <span class="_ _23"></span>hash <span class="_ _23"></span>list</span></span></span></span></span></div><div class="t m0 x32 h2a y13a ff19 fsf fc0 sc0 ls0 ws0">lock, <span class="_ _2"></span>since <span class="_ _2"></span>we’ll <span class="_ _3"></span>need <span class="_ _2"></span>to <span class="_ _3"></span>remove the <span class="_ _3"></span>structur<span class="ls210">ef<span class="_ _8"></span><span class="ls45">ro<span class="ls210">mt<span class="_ _4f"></span><span class="ls0">he <span class="_ _3"></span>hash <span class="_ _2"></span>list.<span class="_ _61"> </span>Then <span class="_ _3"></span>we <span class="_ _2"></span>reacquir<span class="ls146">et<span class="_ _8"></span><span class="ls0">he</span></span></span></span></span></span></div><div class="t m0 x32 h2a y254 ff19 fsf fc0 sc0 ls0 ws0">structur<span class="_ _0"></span><span class="lse00">em<span class="_ _1d"></span><span class="ls0">utex. <span class="_ _16"> </span>Because<span class="_ _61"> </span>we <span class="_ _47"> </span>could <span class="_ _66"> </span>have <span class="_ _47"> </span>blocked <span class="_ _47"> </span>since <span class="_ _66"> </span>the <span class="_ _47"> </span>last <span class="_ _47"> </span>time <span class="_ _66"> </span>we <span class="_ _47"> </span>held <span class="_ _66"> </span>the</span></span></div><div class="t m0 x32 h2a y255 ff19 fsf fc0 sc0 ls0 ws0">structur<span class="_ _0"></span><span class="lse01">em<span class="_ _b"></span><span class="ls0">utex, <span class="_ _9"></span>we <span class="_ _9"></span>need <span class="_ _9"></span>to <span class="_ _23"></span>recheck <span class="_ _3"></span>the <span class="_ _9"></span>condition <span class="_ _23"></span>to <span class="_ _9"></span>see <span class="_ _9"></span>whether <span class="_ _9"></span>we <span class="_ _9"></span>still <span class="_ _23"></span>need <span class="_ _9"></span>to <span class="_ _9"></span>free</span></span></div><div class="t m0 x32 h2a y13b ff19 fsf fc0 sc0 ls0 ws0">the structure. <span class="_"> </span>If<span class="_"> </span>another thread found the structur<span class="_ _0"></span><span class="ls746">ea<span class="_ _d"></span><span class="ls0">nd added a <span class="_ _2"></span>refer<span class="_ _0"></span>ence to it while we</span></span></div><div class="t m0 x32 h2a y13c ff19 fsf fc0 sc0 ls0 ws0">blocked <span class="_ _9"></span>to <span class="_ _9"></span>honor <span class="_ _23"></span>the <span class="_ _9"></span>lock <span class="_ _9"></span>ordering, <span class="_ _9"></span>we <span class="_ _9"></span>simply <span class="_ _23"></span>need <span class="_ _9"></span>to <span class="_ _9"></span>decrement <span class="_ _9"></span>the <span class="_ _9"></span>reference <span class="_ _9"></span>count,</div><div class="t m0 x32 h2a y256 ff19 fsf fc0 sc0 ls0 ws0">unlock everything, and return.</div><div class="t m0 x3f h2a y257 ff19 fsf fc0 sc0 ls0 ws0">This locking approach is complex, so we need to revisit our design.<span class="_ _59"> </span><span class="ls5f">We <span class="_ _53"> </span>c<span class="_ _9"></span></span>an simplify</div><div class="t m0 x32 h2a y258 ff19 fsf fc0 sc0 ls0 ws0">things <span class="_ _3"></span>considerably <span class="_ _9"></span>by <span class="_ _9"></span>using <span class="_ _9"></span>the <span class="_ _9"></span>hash <span class="_ _3"></span>list <span class="_ _9"></span>lock <span class="_ _9"></span>to <span class="_ _9"></span>protect <span class="_ _3"></span>the <span class="_ _9"></span>structur<span class="lse02">er<span class="_ _43"></span><span class="ls0">eference <span class="_ _9"></span>count,</span></span></div><div class="t m0 x32 h26 y161 ff19 fsf fc0 sc0 ls0 ws0">too. <span class="_ _35"> </span>The<span class="_ _35"> </span>structur<span class="_ _1"></span><span class="lse03">em<span class="_ _b"></span><span class="ls0">utex <span class="_ _23"></span>can <span class="_ _23"></span>be <span class="_ _23"></span>used <span class="_ _23"></span>to <span class="_ _23"></span>protect <span class="_ _23"></span>everything <span class="_ _23"></span>else <span class="_ _23"></span>in <span class="_ _23"></span>the<span class="_ _35"> </span><span class="ff1a">foo<span class="_ _35"> </span></span>structur<span class="_ _1"></span>e.</span></span></div><div class="t m0 x32 h2a y162 ff19 fsf fc0 sc0 ls0 ws0">Figur<span class="ls44">e1<span class="_ _b"></span><span class="ls0">1.12 reﬂects this change.</span></span></div><div class="t m0 x32 h4e y3368 ff1a fs28 fc0 sc0 ls0 ws0">#include &lt;stdlib.h&gt;</div><div class="t m0 x32 h4e y3369 ff1a fs28 fc0 sc0 ls0 ws0">#include &lt;pthread.h&gt;</div><div class="t m0 x32 h4e y336a ff1a fs28 fc0 sc0 ls0 ws0">#define NHASH 29</div><div class="t m0 x32 h4e y336b ff1a fs28 fc0 sc0 ls0 ws0">#define HASH(id) (((unsigned long)id)%NHASH)</div><div class="t m0 x32 h4e y336c ff1a fs28 fc0 sc0 ls0 ws0">struct foo *fh[NHASH];</div><div class="t m0 x32 h4e y336d ff1a fs28 fc0 sc0 ls0 ws0">pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;</div><div class="t m0 x32 h4e y336e ff1a fs28 fc0 sc0 ls0 ws0">struct foo {</div><div class="t m0 x8a h4e y336f ff1a fs28 fc0 sc0 ls0 ws0">int <span class="_ _82"> </span>f_count;<span class="_"> </span>/* protected by hashlock */</div><div class="t m0 x8a h4e y3370 ff1a fs28 fc0 sc0 ls0 ws0">pthread_mutex_t f_lock;</div><div class="t m0 x8a h4e y3371 ff1a fs28 fc0 sc0 ls0 ws0">int <span class="_ _82"> </span>f_id;</div><div class="t m0 x8a h4e y3372 ff1a fs28 fc0 sc0 ls0 ws0">struct foo<span class="_ _8a"> </span>*f_next; /* protected by hashlock */</div><div class="t m0 x8a h4e y3373 ff1a fs28 fc0 sc0 ls0 ws0">/* ... more stuff here ... */</div><div class="t m0 x32 h4e y3374 ff1a fs28 fc0 sc0 ls0 ws0">};</div><div class="t m0 x32 h4e y3375 ff1a fs28 fc0 sc0 ls0 ws0">struct foo *</div><div class="t m0 x32 h4e y3376 ff1a fs28 fc0 sc0 ls0 ws0">foo_alloc(int id) /* allocate the object */</div><div class="t m0 x32 h4e y3377 ff1a fs28 fc0 sc0 ls0 ws0">{</div><div class="t m0 x8a h4e y3378 ff1a fs28 fc0 sc0 ls0 ws0">struct foo<span class="_ _d9"> </span>*fp;</div><div class="t m0 x8a h4e y3379 ff1a fs28 fc0 sc0 ls0 ws0">int <span class="_ _186"> </span>idx;</div><div class="t m0 x8a h4e y337a ff1a fs28 fc0 sc0 ls0 ws0">if ((fp = malloc(sizeof(struct foo))) != NULL) {</div><div class="t m0 x9d h4e y337b ff1a fs28 fc0 sc0 ls0 ws0">fp-&gt;f_count = 1;</div><div class="t m0 x9d h4e y337c ff1a fs28 fc0 sc0 ls0 ws0">fp-&gt;f_id = id;</div><div class="t m0 x9d h4e y337d ff1a fs28 fc0 sc0 ls0 ws0">if (pthread_mutex_init(&amp;fp-&gt;f_lock, NULL) != 0) {</div><div class="t m0 x1f h4e y337e ff1a fs28 fc0 sc0 ls0 ws0">free(fp);</div></div><div class="pi" data-data='{"ctm":[2.100000,0.000000,0.000000,2.100000,-115.668004,-156.491993]}'></div></div>
