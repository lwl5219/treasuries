<div id="pf1d4" class="pf w4 h1f" data-page-no="1d4"><div class="pc pc1d4 w4 h1f"><img class="bi x0 y0 w3 h4" alt="" src="bg1d4.png"/><div class="t m0 x31 h2 y8e ff1 fs0 fc0 sc0 ls0 ws0"><span class="fc1 sc0">ptg10805159</span></div><div class="t m0 x35 h24 ya4 ff18 fs0 fc0 sc0 ls0 ws0">434<span class="_ _1b"> </span><span class="ff19">Thread <span class="_"> </span>Contr<span class="_ _0"></span>ol <span class="_ _177"> </span>Chapter<span class="_ _44"> </span>12</span></div><div class="t m0 x3f h26 y12f ff19 fsf fc0 sc0 ls5f ws0">We <span class="_ _35"> </span>c<span class="_ _9"></span><span class="ls0">an <span class="_ _e"> </span>use <span class="_ _e"> </span>the<span class="_ _4b"> </span><span class="ff1a">pthread_mutexattr_gettype<span class="_ _59"> </span></span>function <span class="_ _53"> </span>to <span class="_ _e"> </span>get <span class="_ _e"> </span>the <span class="_ _e"> </span>mutex<span class="_ _4b"> </span><span class="ff1b">type</span></span></div><div class="t m0 x32 h26 y130 ff19 fsf fc0 sc0 ls0 ws0">attribute. <span class="_ _59"> </span>T<span class="_ _6"></span><span class="lse9a">oc<span class="_ _4a"></span><span class="ls0">hange <span class="_"> </span>the <span class="_"> </span>attribute, <span class="_ _e"> </span>we <span class="_"> </span>can <span class="_ _e"> </span>use <span class="_"> </span>the<span class="_ _4b"> </span><span class="ff1a">pthread_mutexattr_settype</span></span></span></div><div class="t m0 x32 h2a y131 ff19 fsf fc0 sc0 ls0 ws0">function.</div><div class="t m0 x3f h57 y1e69 ff1a fs2d fc0 sc0 ls0 ws0">#include &lt;pthread.h&gt;</div><div class="t m0 x3f h57 y3632 ff1a fs2d fc0 sc0 ls0 ws0">int pthread_mutexattr_gettype(const pthread_mutexattr_t *</div><div class="t m0 x154 h57 y3633 ff1a fs2d fc0 sc0 ls0 ws0">restrict<span class="_"> </span><span class="ff1b">attr</span><span class="ls15c">,i<span class="_ _1d"></span><span class="ls0">nt *restrict<span class="_"> </span><span class="ff1b">type</span>);</span></span></div><div class="t m0 x3f h57 y3634 ff1a fs2d fc0 sc0 ls0 ws0">int pthread_mutexattr_settype(pthread_mutexattr_t *<span class="ff1b">attr</span><span class="ls15c">,i<span class="_ _1d"></span><span class="ls0">nt<span class="_"> </span><span class="ff1b">type</span>);</span></span></div><div class="t m0 xca h5f y3635 ff19 fs2d fc0 sc0 ls0 ws0">Both return: 0 if OK, err<span class="_ _0"></span>or number on failure</div><div class="t m0 x3f h49 y3636 ff19 fs26 fc0 sc0 ls0 ws0">Recall <span class="_"> </span>fr<span class="_ _0"></span>om <span class="_"> </span>Section <span class="_"> </span>1<span class="_ _6"></span>1.6.6 <span class="_"> </span>that <span class="_"> </span>a <span class="_"> </span>mutex <span class="_ _e"> </span>is <span class="_"> </span>used <span class="_"> </span>to <span class="_"> </span>pr<span class="_ _0"></span>otect <span class="_"> </span>the <span class="_"> </span>condition <span class="_ _e"> </span>that <span class="_"> </span>is</div><div class="t m0 x32 h49 y3637 ff19 fs26 fc0 sc0 ls0 ws0">associated <span class="_ _7f"> </span>with <span class="_ _5e"> </span>a <span class="_ _7f"> </span>condition <span class="_ _7f"> </span>variable.<span class="_ _179"> </span>Befor<span class="lse9b">eb<span class="_ _1be"></span><span class="ls0">locking <span class="_ _7f"> </span>the <span class="_ _5e"> </span>thr<span class="_ _1"></span>ead, <span class="_ _5e"> </span>the</span></span></div><div class="t m0 x32 h4d y3638 ff1a fs26 fc0 sc0 ls0 ws0">pthread_cond_wait<span class="_ _54"> </span><span class="ff19">and <span class="_ _44"> </span>the<span class="_ _54"> </span></span>pthread_cond_timedwait<span class="_ _54"> </span><span class="ff19">functions <span class="_ _44"> </span>release <span class="_ _35"> </span>the</span></div><div class="t m0 x32 h49 y3639 ff19 fs26 fc0 sc0 ls0 ws0">mutex <span class="_ _23"></span>associated <span class="_ _23"> </span>with <span class="_ _23"> </span>the <span class="_ _23"> </span>condition.<span class="_ _51"> </span>This <span class="_ _42"> </span>allows <span class="_ _23"></span>other <span class="_ _23"> </span>threads <span class="_ _23"></span>to <span class="_ _23"></span>acquir<span class="lse9c">et<span class="_ _43"></span><span class="ls0">he <span class="_ _23"> </span>mutex,</span></span></div><div class="t m0 x32 h49 y363a ff19 fs26 fc0 sc0 ls0 ws0">change <span class="_ _42"> </span>the <span class="_ _42"> </span>condition, <span class="_ _23"> </span>release <span class="_ _42"> </span>the <span class="_ _42"> </span>mutex, <span class="_ _42"> </span>and <span class="_ _23"> </span>signal <span class="_ _42"> </span>the <span class="_ _42"> </span>condition <span class="_ _42"> </span>variable.<span class="_ _54"> </span>Since <span class="_ _42"> </span>the</div><div class="t m0 x32 h49 y363b ff19 fs26 fc0 sc0 ls0 ws0">mutex <span class="_ _42"> </span>must <span class="_ _23"> </span>be <span class="_ _42"> </span>held <span class="_ _42"> </span>to <span class="_ _42"> </span>change <span class="_ _23"> </span>the <span class="_ _42"> </span>condition, <span class="_ _42"> </span>it <span class="_ _42"> </span>is <span class="_ _23"> </span>not <span class="_ _42"> </span>a <span class="_ _42"> </span>good <span class="_ _42"> </span>idea <span class="_ _42"> </span>to <span class="_ _23"> </span>use <span class="_ _42"> </span>a <span class="_ _42"> </span>recursive</div><div class="t m0 x32 h49 y363c ff19 fs26 fc0 sc0 ls0 ws0">mutex. <span class="_ _48"> </span>If<span class="_ _60"> </span><span class="lse9d">ar<span class="_ _5d"></span><span class="ls0">ecursive <span class="_ _59"> </span>mutex <span class="_ _59"> </span>is <span class="_ _59"> </span>locked <span class="_ _59"> </span>multiple <span class="_ _59"> </span>times <span class="_ _46"> </span>and <span class="_ _59"> </span>used <span class="_ _59"> </span>in <span class="_ _59"> </span>a <span class="_ _59"> </span>call <span class="_ _46"> </span>to</span></span></div><div class="t m0 x32 h4d y363d ff1a fs26 fc0 sc0 ls0 ws0">pthread_cond_wait<span class="ff19 lse9e">,t<span class="_ _d"></span><span class="ls0">he condition can never be satisﬁed, because the unlock done by</span></span></div><div class="t m0 x32 h4d y363e ff1a fs26 fc0 sc0 ls0 ws0">pthread_cond_wait<span class="_ _80"> </span><span class="ff19">doesn’t release the mutex.</span></div><div class="t m0 x3f h49 y363f ff19 fs26 fc0 sc0 ls0 ws0">Recursive <span class="_"> </span>mutexes <span class="_"> </span>ar<span class="_ _0"></span><span class="ls2b5">eu<span class="_ _4a"></span><span class="ls0">seful <span class="_"> </span>when <span class="_"> </span>you <span class="_ _e"> </span>need <span class="_"> </span>to <span class="_"> </span>adapt <span class="_"> </span>existing <span class="_"> </span>single-thr<span class="_ _0"></span>eaded</span></span></div><div class="t m0 x32 h49 y3640 ff19 fs26 fc0 sc0 ls0 ws0">interfaces <span class="_"> </span>to <span class="_ _66"> </span>a <span class="_ _47"> </span>multithr<span class="_ _0"></span>eaded <span class="_"> </span>environment, <span class="_"> </span>but <span class="_ _47"> </span>can’t <span class="_"> </span>change <span class="_ _66"> </span>the <span class="_ _66"> </span>interfaces <span class="_ _66"> </span>to <span class="_ _47"> </span>your</div><div class="t m0 x32 h49 y3641 ff19 fs26 fc0 sc0 ls0 ws0">functions <span class="_ _23"></span>because <span class="_ _9"></span>of <span class="_ _23"> </span>compatibility <span class="_ _23"> </span>constraints.<span class="_ _51"> </span>However<span class="_ _6"></span><span class="lse9f">,u<span class="_ _b"></span><span class="ls0">sing <span class="_ _9"></span>recursive <span class="_ _23"></span>locks <span class="_ _23"></span>can <span class="_ _9"></span>be</span></span></div><div class="t m0 x32 h49 y3642 ff19 fs26 fc0 sc0 ls0 ws0">tricky<span class="_ _4"></span><span class="lsd3">,a<span class="_ _5"></span><span class="ls0">nd they should be used only when no other solution is possible.</span></span></div><div class="t m0 x35 h4c y3643 ff16 fs26 fc0 sc0 ls0 ws0">Example</div><div class="t m0 x32 h49 y3644 ff19 fs26 fc0 sc0 ls0 ws0">Figur<span class="lsea0">e1<span class="_ _55"></span><span class="ls0">2.6 <span class="_ _53"> </span>illustrates <span class="_ _53"> </span>a <span class="_ _e"> </span>situation <span class="_ _53"> </span>in <span class="_ _53"> </span>which <span class="_ _53"> </span>a <span class="_ _53"> </span>recursive <span class="_ _53"> </span>mutex <span class="_ _53"> </span>might <span class="_ _53"> </span>seem <span class="_ _53"> </span>to <span class="_ _e"> </span>solve <span class="_ _53"> </span>a</span></span></div><div class="t m0 x32 h4d y3645 ff19 fs26 fc0 sc0 ls0 ws0">concurrency <span class="_"> </span>problem. <span class="_ _61"> </span>Assume<span class="_ _16"> </span>that<span class="_ _61"> </span><span class="ff1a">func1<span class="_ _16"> </span></span>and<span class="_ _61"> </span><span class="ff1a">func2<span class="_ _16"> </span></span>ar<span class="lsea1">ee<span class="_ _1d"></span><span class="ls0">xisting <span class="_ _47"> </span>functions <span class="_ _66"> </span>in <span class="_ _47"> </span>a</span></span></div><div class="t m0 x32 h49 y3646 ff19 fs26 fc0 sc0 ls0 ws0">library <span class="_ _2"></span>whose <span class="_ _3"></span>interfaces <span class="_ _3"></span>can’t <span class="_ _3"></span>be <span class="_ _3"></span>changed, <span class="_ _3"></span>because <span class="_ _3"></span>applications <span class="_ _3"></span>exist <span class="_ _3"></span>that <span class="_ _2"></span>call <span class="_ _3"></span>them <span class="_ _3"></span>and</div><div class="t m0 x32 h49 y3647 ff19 fs26 fc0 sc0 ls0 ws0">those applications can’t be changed.</div><div class="t m0 x3f h49 y3648 ff19 fs26 fc0 sc0 ls164 ws0">To <span class="_ _45"> </span>k<span class="_ _9"></span><span class="ls0">eep <span class="_ _53"> </span>the <span class="_ _42"> </span>interfaces <span class="_ _42"> </span>the <span class="_ _53"> </span>same, <span class="_ _42"> </span>we <span class="_ _42"> </span>embed <span class="_ _53"> </span>a <span class="_ _42"> </span>mutex <span class="_ _53"> </span>in <span class="_ _42"> </span>the <span class="_ _42"> </span>data <span class="_ _53"> </span>structur<span class="lsea2">ew<span class="_ _c"></span><span class="ls0">hose</span></span></span></div><div class="t m0 x32 h4d y3649 ff19 fs26 fc0 sc0 ls0 ws0">address <span class="_ _3"></span>(<span class="ff1a">x</span>)<span class="_ _45"> </span>is<span class="_ _45"> </span>passed <span class="_ _9"></span>in <span class="_ _23"></span>as <span class="_ _9"></span>an <span class="_ _9"></span>argument. <span class="_ _45"> </span>This<span class="_ _45"> </span>is <span class="_ _3"></span>possible <span class="_ _23"></span>only <span class="_ _9"></span>if <span class="_ _9"></span>we <span class="_ _9"></span>have <span class="_ _9"></span>provided <span class="_ _9"></span>an</div><div class="t m0 x32 h49 y364a ff19 fs26 fc0 sc0 ls0 ws0">allocator <span class="_"> </span>function <span class="_ _66"> </span>for <span class="_ _66"> </span>the <span class="_ _47"> </span>structur<span class="_ _0"></span>e, <span class="_"> </span>so <span class="_ _66"> </span>the <span class="_ _66"> </span>application <span class="_ _66"> </span>doesn’t <span class="_ _47"> </span>know <span class="_"> </span>about <span class="_ _66"> </span>its <span class="_ _66"> </span>size</div><div class="t m0 x32 h49 y364b ff19 fs26 fc0 sc0 ls0 ws0">(assuming we must increase its size when we add a mutex to it).</div><div class="t m0 x76 h2d y364c ff19 fs10 fc0 sc0 ls0 ws0">This <span class="_ _9"></span>is <span class="_ _9"> </span>also <span class="_ _23"> </span>possible <span class="_ _9"></span>if <span class="_ _23"> </span>we <span class="_ _9"></span>originally <span class="_ _9"></span>deﬁned <span class="_ _23"> </span>the <span class="_ _9"></span>structur<span class="lsea3">ew<span class="_ _8"></span><span class="ls0">ith <span class="_ _9"></span>enough <span class="_ _9"> </span>padding <span class="_ _23"> </span>to <span class="_ _9"></span>allow <span class="_ _23"> </span>us</span></span></div><div class="t m0 x76 h2d y364d ff19 fs10 fc0 sc0 ls0 ws0">now to <span class="_ _2"></span>replace some <span class="_ _2"></span>pad <span class="_ _2"></span>ﬁelds with <span class="_ _2"></span>a <span class="_ _2"></span>mutex.<span class="_ _44"> </span>Unfortunately<span class="_ _6"></span><span class="lsea4">,m<span class="_ _5"></span><span class="ls0">ost <span class="_ _2"></span>programmers ar<span class="lsea4">eu<span class="_ _5"></span><span class="ls0">nskilled</span></span></span></span></div><div class="t m0 x76 h2d y364e ff19 fs10 fc0 sc0 ls0 ws0">at predicting the futur<span class="_ _0"></span>e, so this is not a common practice.</div><div class="t m0 x3f h4d y364f ff19 fs26 fc0 sc0 ls0 ws0">If <span class="_ _2"></span>both<span class="_ _66"> </span><span class="ff1a">func1<span class="_ _47"> </span></span>and<span class="_ _47"> </span><span class="ff1a">func2<span class="_ _66"> </span></span>must <span class="_ _2"></span>manipulate <span class="_ _2"></span>the <span class="_ _3"></span>structur<span class="lsea5">ea<span class="_ _8"></span><span class="ls0">nd <span class="_ _2"></span>it <span class="_ _2"></span>is <span class="_ _3"></span>possible <span class="_ _2"></span>to <span class="_ _2"></span>access</span></span></div><div class="t m0 x32 h4d y3650 ff19 fs26 fc0 sc0 ls0 ws0">it <span class="_ _23"></span>from <span class="_ _23"></span>mor<span class="_ _0"></span><span class="lsea6">et<span class="_ _43"></span><span class="ls0">han <span class="_ _23"> </span>one <span class="_ _42"> </span>thread <span class="_ _9"></span>at <span class="_ _23"> </span>a <span class="_ _42"> </span>time, <span class="_ _23"></span>then<span class="_ _35"> </span><span class="ff1a">func1<span class="_ _35"> </span></span>and<span class="_ _45"> </span><span class="ff1a">func2<span class="_ _35"> </span></span>must <span class="_ _42"> </span>lock <span class="_ _23"></span>the <span class="_ _23"></span>mutex</span></span></div><div class="t m0 x32 h4d y3651 ff19 fs26 fc0 sc0 ls0 ws0">befor<span class="lsea7">em<span class="_ _43"></span><span class="ls0">anipulating <span class="_ _23"></span>the <span class="_ _9"></span>structure. <span class="_ _45"> </span>If<span class="_ _35"> </span><span class="ff1a">func1<span class="_ _45"> </span></span>must <span class="_ _9"></span>call<span class="_ _35"> </span><span class="ff1a">func2</span>,<span class="_ _45"> </span>we<span class="_ _35"> </span>will <span class="_ _9"></span>deadlock <span class="_ _23"></span>if <span class="_ _9"></span>the</span></span></div><div class="t m0 x32 h49 y3652 ff19 fs26 fc0 sc0 ls0 ws0">mutex type is not recursive. <span class="_"> </span>W<span class="_ _6"></span><span class="ls943">ec<span class="_ _d"></span><span class="ls0">ould avoid using <span class="_ _2"></span>a recursive mutex if we could release</span></span></div></div><div class="pi" data-data='{"ctm":[2.100000,0.000000,0.000000,2.100000,-115.668004,-156.491993]}'></div></div>
