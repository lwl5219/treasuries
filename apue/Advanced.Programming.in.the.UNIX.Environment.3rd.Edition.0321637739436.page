<div id="pf1b4" class="pf w4 h1f" data-page-no="1b4"><div class="pc pc1b4 w4 h1f"><img class="bi x0 y0 w3 h4" alt="" src="bg1b4.png"/><div class="t m0 x31 h2 y8e ff1 fs0 fc0 sc0 ls0 ws0"><span class="fc1 sc0">ptg10805159</span></div><div class="t m0 x35 h24 ya4 ff18 fs0 fc0 sc0 ls0 ws0">402<span class="_ _1b"> </span><span class="ff19">Threads <span class="_ _24b"> </span>Chapter<span class="_ _78"> </span><span class="ls7ed">11</span></span></div><div class="t m0 x32 h26 y12f ff19 fsf fc0 sc0 ls0 ws0">necessary <span class="_"> </span>when <span class="_ _66"> </span>we <span class="_ _66"> </span>initialize <span class="_ _66"> </span>the <span class="_ _66"> </span>reference <span class="_"> </span>count <span class="_"> </span>to <span class="_"> </span>1 <span class="_ _66"> </span>in <span class="_ _66"> </span>the<span class="_ _61"> </span><span class="ff1a">foo_alloc<span class="_ _46"> </span></span>function,</div><div class="t m0 x32 h2a y130 ff19 fsf fc0 sc0 ls0 ws0">because <span class="_ _9"></span>the <span class="_ _23"></span>allocating <span class="_ _9"></span>thread <span class="_ _9"></span>is <span class="_ _23"></span>the <span class="_ _9"></span>only <span class="_ _23"></span>refer<span class="_ _0"></span>ence <span class="_ _9"></span>to <span class="_ _23"></span>it <span class="_ _9"></span>so <span class="_ _23"></span>far<span class="_ _6"></span><span class="lsde8">.I<span class="_ _26"></span><span class="ls0">f<span class="_ _35"> </span>we<span class="_ _45"> </span>were<span class="_ _45"> </span>to<span class="_ _45"> </span>place <span class="_ _23"></span>the</span></span></div><div class="t m0 x32 h2a y131 ff19 fsf fc0 sc0 ls0 ws0">structur<span class="_ _0"></span>e<span class="_ _66"> </span>on<span class="_ _47"> </span>a<span class="_ _66"> </span>list <span class="_ _2"></span>at <span class="_ _2"></span>this <span class="_ _2"></span>point, <span class="_ _2"></span>it <span class="_ _2"></span>could <span class="_ _3"></span>be <span class="_ _2"></span>found <span class="_ _2"></span>by <span class="_ _2"></span>other <span class="_ _2"></span>threads, <span class="_ _2"></span>so <span class="_ _2"></span>we <span class="_ _2"></span>would <span class="_ _2"></span>need <span class="_ _2"></span>to</div><div class="t m0 x32 h2a y132 ff19 fsf fc0 sc0 ls0 ws0">lock it ﬁrst.</div><div class="t m0 x3f h2a y133 ff19 fsf fc0 sc0 ls0 ws0">Befor<span class="lsde9">eu<span class="_ _4a"></span><span class="ls0">sing <span class="_"> </span>the <span class="_ _53"> </span>object, <span class="_ _e"> </span>threads <span class="_ _53"> </span>ar<span class="lsde9">ee<span class="_ _55"></span><span class="ls0">xpected <span class="_ _e"> </span>to <span class="_ _e"> </span>add <span class="_"> </span>a <span class="_ _53"> </span>refer<span class="_ _0"></span>ence <span class="_ _e"> </span>to <span class="_ _e"> </span>it <span class="_ _e"> </span>by <span class="_ _e"> </span>calling</span></span></span></span></div><div class="t m0 x32 h26 y134 ff1a fsf fc0 sc0 ls0 ws0">foo_hold<span class="ff19 ls586">.W<span class="_ _52"></span><span class="ls0">hen <span class="_ _42"> </span>they <span class="_ _53"> </span>ar<span class="lsdea">ed<span class="_ _c"></span><span class="ls0">one, <span class="_ _53"> </span>they <span class="_ _53"> </span>must <span class="_ _53"> </span>call<span class="_ _4b"> </span><span class="ff1a">foo_rele<span class="_ _44"> </span></span>to <span class="_ _e"> </span>release <span class="_ _42"> </span>the <span class="_ _53"> </span>reference.</span></span></span></span></div><div class="t m0 x32 h2a y135 ff19 fsf fc0 sc0 ls0 ws0">When the last refer<span class="_ _0"></span>ence is r<span class="_ _0"></span>eleased, the object’s memory is freed.</div><div class="t m0 x3f h2a y136 ff19 fsf fc0 sc0 ls0 ws0">In <span class="_ _45"> </span>this <span class="_ _35"> </span>example, <span class="_ _45"> </span>we <span class="_ _35"> </span>have <span class="_ _45"> </span>ignored <span class="_ _35"> </span>how <span class="_ _45"> </span>threads <span class="_ _45"> </span>ﬁnd <span class="_ _35"> </span>an <span class="_ _45"> </span>object <span class="_ _35"> </span>befor<span class="lsdeb">ec<span class="_ _7"></span><span class="ls0">alling</span></span></div><div class="t m0 x32 h26 y137 ff1a fsf fc0 sc0 ls0 ws0">foo_hold<span class="ff19 lsdec">.E<span class="_ _95"></span><span class="ls0">ven <span class="_ _45"> </span>though <span class="_ _45"> </span>the <span class="_ _45"> </span>reference <span class="_ _47"> </span>count <span class="_ _35"> </span>is <span class="_ _45"> </span>zer<span class="_ _0"></span>o, <span class="_ _45"> </span>it <span class="_ _45"> </span>would <span class="_ _45"> </span>be <span class="_ _45"> </span>a <span class="_ _45"> </span>mistake <span class="_ _35"> </span>for</span></span></div><div class="t m0 x32 h26 y138 ff1a fsf fc0 sc0 ls0 ws0">foo_rele<span class="_ _45"> </span><span class="ff19">to <span class="_ _23"> </span>free <span class="_ _23"></span>the <span class="_ _9"></span>object’s <span class="_ _23"> </span>memory <span class="_ _23"> </span>if <span class="_ _23"></span>another <span class="_ _23"></span>thread <span class="_ _9"></span>is <span class="_ _23"></span>blocked <span class="_ _23"></span>on <span class="_ _9"></span>the <span class="_ _23"> </span>mutex <span class="_ _23"> </span>in <span class="_ _23"></span>a</span></div><div class="t m0 x32 h26 y139 ff19 fsf fc0 sc0 ls0 ws0">call to<span class="_ _66"> </span><span class="ff1a">foo_hold</span><span class="lsded">.W<span class="_ _26"></span><span class="lsdee">ec<span class="_ _d"></span><span class="ls0">an <span class="_ _2"></span>avoid this <span class="_ _2"></span>problem by ensuring <span class="_ _2"></span>that the <span class="_ _2"></span>object can’t <span class="_ _2"></span>be found</span></span></span></div><div class="t m0 x32 h2a y13a ff19 fsf fc0 sc0 ls0 ws0">befor<span class="ls44">ef<span class="_ _4f"></span><span class="ls45">re<span class="_ _2"></span><span class="ls0">eing its memory<span class="_ _6"></span><span class="ls86">.W<span class="_ _26"></span><span class="ls0">e’ll see how to do this in the examples that follow<span class="_ _6"></span>.</span></span></span></span></span></div><div class="t m0 x32 h4b y332e ff16 fs27 fc0 sc0 ls0 ws0">11.6.2 <span class="_ _54"> </span>Deadloc<span class="ls5d5">kA<span class="_ _5d"></span><span class="lsdef">vo<span class="_ _2"></span><span class="ls0">idance</span></span></span></div><div class="t m0 x32 h49 y332f ff19 fs26 fc0 sc0 lsdf0 ws0">At<span class="_ _b"></span><span class="ls0">hread <span class="_ _3"></span>will <span class="_ _23"></span>deadlock <span class="_ _9"></span>itself <span class="_ _9"></span>if <span class="_ _9"></span>it <span class="_ _9"></span>tries <span class="_ _23"></span>to <span class="_ _9"></span>lock <span class="_ _9"></span>the <span class="_ _9"></span>same <span class="_ _9"></span>mutex <span class="_ _23"></span>twice, <span class="_ _9"></span>but <span class="_ _9"></span>ther<span class="lsdf1">ea<span class="_ _b"></span><span class="lscc">re <span class="_ _23"></span>l<span class="ls0">ess</span></span></span></span></div><div class="t m0 x32 h49 y3330 ff19 fs26 fc0 sc0 ls0 ws0">obvious <span class="_ _2"></span>ways <span class="_ _3"></span>to <span class="_ _3"></span>create <span class="_ _3"></span>deadlocks <span class="_ _3"></span>with <span class="_ _2"></span>mutexes.<span class="_ _16"> </span>For <span class="_ _3"></span>example, <span class="_ _3"></span>when <span class="_ _3"></span>we <span class="_ _3"></span>use <span class="_ _3"></span>mor<span class="lsdf2">et<span class="_ _8"></span><span class="ls0">han</span></span></div><div class="t m0 x32 h49 y3331 ff19 fs26 fc0 sc0 ls0 ws0">one <span class="_ _53"> </span>mutex <span class="_ _42"> </span>in <span class="_ _53"> </span>our <span class="_ _53"> </span>programs, <span class="_ _53"> </span>a <span class="_ _53"> </span>deadlock <span class="_ _42"> </span>can <span class="_ _53"> </span>occur <span class="_ _53"> </span>if <span class="_ _53"> </span>we <span class="_ _53"> </span>allow <span class="_ _53"> </span>one <span class="_ _53"> </span>thread <span class="_ _42"> </span>to <span class="_ _53"> </span>hold <span class="_ _53"> </span>a</div><div class="t m0 x32 h49 y3332 ff19 fs26 fc0 sc0 ls0 ws0">mutex <span class="_ _42"> </span>and <span class="_ _42"> </span>block <span class="_ _53"> </span>while <span class="_ _42"> </span>trying <span class="_ _42"> </span>to <span class="_ _53"> </span>lock <span class="_ _42"> </span>a <span class="_ _42"> </span>second <span class="_ _53"> </span>mutex <span class="_ _42"> </span>at <span class="_ _42"> </span>the <span class="_ _53"> </span>same <span class="_ _42"> </span>time <span class="_ _42"> </span>that <span class="_ _53"> </span>another</div><div class="t m0 x32 h49 y3333 ff19 fs26 fc0 sc0 ls0 ws0">thread <span class="_"> </span>holding <span class="_"> </span>the <span class="_"> </span>second <span class="_"> </span>mutex <span class="_"> </span>tries <span class="_"> </span>to <span class="_"> </span>lock <span class="_"> </span>the <span class="_"> </span>ﬁrst <span class="_"> </span>mutex.<span class="_ _60"> </span>Neither <span class="_"> </span>thread <span class="_"> </span>can</div><div class="t m0 x32 h49 y3334 ff19 fs26 fc0 sc0 ls0 ws0">proceed, because each <span class="_ _2"></span>needs <span class="_ _2"></span>a <span class="_ _2"></span>resour<span class="_ _0"></span>ce that <span class="_ _2"></span>is <span class="_ _2"></span>held by <span class="_ _2"></span>the <span class="_ _2"></span>other<span class="_ _6"></span>,<span class="_ _47"> </span>so<span class="_"> </span>we<span class="_ _66"> </span>have <span class="_ _2"></span>a <span class="_ _2"></span>deadlock.</div><div class="t m0 x3f h49 y3335 ff19 fs26 fc0 sc0 ls0 ws0">Deadlocks <span class="_ _9"></span>can <span class="_ _9"></span>be <span class="_ _23"></span>avoided <span class="_ _9"></span>by <span class="_ _9"></span>carefully <span class="_ _9"></span>controlling <span class="_ _9"></span>the <span class="_ _9"></span>order <span class="_ _9"></span>in <span class="_ _9"></span>which <span class="_ _23"></span>mutexes <span class="_ _9"></span>are</div><div class="t m0 x32 h49 y3336 ff19 fs26 fc0 sc0 ls0 ws0">locked. <span class="_ _35"> </span>For<span class="_ _35"> </span>example, <span class="_ _23"> </span>assume <span class="_ _42"> </span>that <span class="_ _23"> </span>you <span class="_ _23"> </span>have <span class="_ _42"> </span>two <span class="_ _23"> </span>mutexes, <span class="_ _42"> </span>A <span class="_ _23"> </span>and <span class="_ _23"> </span>B, <span class="_ _42"> </span>that <span class="_ _23"> </span>you <span class="_ _42"> </span>need <span class="_ _23"></span>to</div><div class="t m0 x32 h49 y3337 ff19 fs26 fc0 sc0 ls0 ws0">lock <span class="_ _3"></span>at <span class="_ _3"></span>the <span class="_ _9"></span>same <span class="_ _3"></span>time.<span class="_ _16"> </span>If <span class="_ _9"></span>all <span class="_ _3"></span>threads <span class="_ _2"></span>always <span class="_ _9"></span>lock <span class="_ _3"></span>mutex <span class="_ _3"></span>A <span class="_ _9"></span>befor<span class="ls6b2">em<span class="_ _b"></span><span class="ls0">utex <span class="_ _3"></span>B, <span class="_ _9"></span>no <span class="_ _3"></span>deadlock</span></span></div><div class="t m0 x32 h49 y3338 ff19 fs26 fc0 sc0 ls0 ws0">can <span class="_ _47"> </span>occur <span class="_ _66"> </span>from <span class="_ _47"> </span>the <span class="_ _47"> </span>use <span class="_ _47"> </span>of <span class="_ _66"> </span>the <span class="_ _47"> </span>two <span class="_ _47"> </span>mutexes <span class="_ _47"> </span>(but <span class="_ _47"> </span>you <span class="_ _47"> </span>can <span class="_ _66"> </span>still <span class="_ _47"> </span>deadlock <span class="_ _47"> </span>on <span class="_ _47"> </span>other</div><div class="t m0 x32 h49 y1ec1 ff19 fs26 fc0 sc0 lscc ws0">re<span class="ls0">sources). <span class="_ _45"> </span>Similarly<span class="_ _6"></span>,<span class="_ _35"> </span>if<span class="_ _45"> </span>all <span class="_ _23"></span>threads <span class="_ _9"></span>always <span class="_ _23"> </span>lock <span class="_ _23"></span>mutex <span class="_ _23"></span>B <span class="_ _9"></span>befor<span class="ls789">em<span class="_ _b"></span><span class="ls0">utex <span class="_ _9"></span>A, <span class="_ _23"></span>no <span class="_ _23"></span>deadlock</span></span></span></div><div class="t m0 x32 h49 y3339 ff19 fs26 fc0 sc0 ls0 ws0">will <span class="_ _9"></span>occur<span class="_ _1"></span><span class="lsdf3">.Y<span class="_ _64"></span><span class="ls0">ou’ll <span class="_ _23"></span>have <span class="_ _9"></span>the <span class="_ _23"></span>potential <span class="_ _9"></span>for <span class="_ _23"></span>a <span class="_ _9"></span>deadlock <span class="_ _23"></span>only <span class="_ _9"></span>when <span class="_ _23"></span>one <span class="_ _9"></span>thread <span class="_ _9"></span>attempts <span class="_ _23"></span>to</span></span></div><div class="t m0 x32 h49 y1ec2 ff19 fs26 fc0 sc0 ls0 ws0">lock the mutexes in the opposite order fr<span class="_ _0"></span>om another thr<span class="_ _0"></span>ead.</div><div class="t m0 x3f h49 y1ec3 ff19 fs26 fc0 sc0 ls0 ws0">Sometimes, <span class="_ _3"></span>an <span class="_ _3"></span>application’s <span class="_ _3"></span>architectur<span class="_ _0"></span><span class="lsdf4">em<span class="_ _8"></span><span class="ls0">akes <span class="_ _3"></span>it <span class="_ _3"></span>difﬁcult <span class="_ _2"></span>to <span class="_ _3"></span>apply <span class="_ _3"></span>a <span class="_ _3"></span>lock <span class="_ _3"></span>ordering.</span></span></div><div class="t m0 x32 h49 y1ec4 ff19 fs26 fc0 sc0 ls0 ws0">If <span class="_ _9"></span>enough <span class="_ _9"></span>locks <span class="_ _9"></span>and <span class="_ _9"></span>data <span class="_ _9"></span>structures <span class="_ _3"></span>ar<span class="lsdf5">ei<span class="_ _b"></span><span class="ls0">nvolved <span class="_ _9"></span>that <span class="_ _9"></span>the <span class="_ _9"></span>functions <span class="_ _9"></span>you <span class="_ _9"></span>have <span class="_ _9"></span>available</span></span></div><div class="t m0 x32 h49 y1ec5 ff19 fs26 fc0 sc0 ls0 ws0">can’t <span class="_ _9"></span>be <span class="_ _3"></span>molded <span class="_ _9"></span>to <span class="_ _9"></span>ﬁt <span class="_ _9"></span>a <span class="_ _9"></span>simple <span class="_ _9"></span>hierarchy<span class="_ _4"></span><span class="lsdf6">,t<span class="_ _b"></span><span class="ls0">hen <span class="_ _9"></span>you’ll <span class="_ _9"></span>have <span class="_ _3"></span>to <span class="_ _9"></span>try <span class="_ _9"></span>some <span class="_ _9"></span>other <span class="_ _9"></span>approach.</span></span></div><div class="t m0 x32 h49 y1ec6 ff19 fs26 fc0 sc0 ls0 ws0">In <span class="_ _9"></span>this <span class="_ _9"></span>case, <span class="_ _9"></span>you <span class="_ _3"></span>might <span class="_ _9"></span>be <span class="_ _9"></span>able <span class="_ _9"></span>to <span class="_ _9"></span>release <span class="_ _9"></span>your <span class="_ _9"></span>locks <span class="_ _9"></span>and <span class="_ _9"></span>try <span class="_ _9"></span>again <span class="_ _3"></span>at <span class="_ _9"></span>a <span class="_ _9"></span>later <span class="_ _9"></span>time.<span class="_ _5a"> </span><span class="ls164">Yo<span class="_ _9"></span></span>u</div><div class="t m0 x32 h4d y1ec7 ff19 fs26 fc0 sc0 ls0 ws0">can <span class="_ _9"></span>use <span class="_ _9"></span>the<span class="_ _35"> </span><span class="ff1a">pthread_mutex_trylock<span class="_ _45"> </span></span>interface <span class="_ _9"></span>to <span class="_ _9"></span>avoid <span class="_ _9"></span>deadlocking <span class="_ _23"></span>in <span class="_ _9"></span>this <span class="_ _9"></span>case.<span class="_ _5a"> </span>If</div><div class="t m0 x32 h4d y1ec8 ff19 fs26 fc0 sc0 ls0 ws0">you <span class="_ _9"></span>ar<span class="lsdf7">ea<span class="_ _b"></span><span class="ls0">lr<span class="_ _0"></span>eady <span class="_ _9"></span>holding <span class="_ _23"></span>locks <span class="_ _9"></span>and<span class="_ _45"> </span><span class="ff1a">pthread_mutex_trylock<span class="_ _35"> </span></span>is <span class="_ _9"></span>successful, <span class="_ _23"></span>then <span class="_ _9"></span>you</span></span></div><div class="t m0 x32 h49 y1ec9 ff19 fs26 fc0 sc0 ls0 ws0">can <span class="_ _2"></span>proceed. <span class="_ _66"> </span>If<span class="_ _47"> </span>it <span class="_ _2"></span>can’t <span class="_ _2"></span>acquir<span class="lsdf8">et<span class="_ _4f"></span><span class="ls0">he <span class="_ _2"></span>lock, <span class="_ _3"></span>however<span class="_ _6"></span><span class="lsdf8">,y<span class="_ _4f"></span><span class="ls0">ou <span class="_ _3"></span>can <span class="_ _2"></span>release <span class="_ _2"></span>the <span class="_ _2"></span>locks <span class="_ _3"></span>you <span class="_ _2"></span>already</span></span></span></span></div><div class="t m0 x32 h49 y1eca ff19 fs26 fc0 sc0 ls0 ws0">hold, clean up, and try again later<span class="_ _6"></span>.</div><div class="t m0 x35 h4c y333a ff16 fs26 fc0 sc0 ls0 ws0">Example</div><div class="t m0 x32 h49 y333b ff19 fs26 fc0 sc0 ls0 ws0">In <span class="_ _42"> </span>this <span class="_ _42"> </span>example, <span class="_ _42"> </span>we <span class="_ _42"> </span>update <span class="_ _42"> </span>Figur<span class="lsdf9">e1<span class="_ _55"></span><span class="ls0">1.10 <span class="_ _42"> </span>to <span class="_ _42"> </span>show <span class="_ _42"> </span>the <span class="_ _42"> </span>use <span class="_ _42"> </span>of <span class="_ _53"> </span>two <span class="_ _42"> </span>mutexes.<span class="_ _54"> </span><span class="ls164">We <span class="_ _45"> </span>a<span class="_ _9"></span></span>void</span></span></div><div class="t m0 x32 h49 y333c ff19 fs26 fc0 sc0 ls0 ws0">deadlocks <span class="_ _2"></span>by <span class="_ _2"></span>ensuring <span class="_ _2"></span>that <span class="_ _3"></span>when <span class="_ _2"></span>we <span class="_ _2"></span>need <span class="_ _3"></span>to <span class="_ _2"></span>acquir<span class="lsdfa">et<span class="_ _8"></span><span class="ls0">wo <span class="_ _3"></span>mutexes <span class="_ _2"></span>at <span class="_ _2"></span>the <span class="_ _2"></span>same <span class="_ _3"></span>time, <span class="_ _2"></span>we</span></span></div><div class="t m0 x32 h49 y333d ff19 fs26 fc0 sc0 ls0 ws0">always <span class="_ _3"></span>lock <span class="_ _3"></span>them <span class="_ _3"></span>in <span class="_ _3"></span>the <span class="_ _3"></span>same <span class="_ _3"></span>order<span class="_ _6"></span><span class="lsdfb">.T<span class="_ _1d"></span><span class="ls0">he <span class="_ _3"></span>second <span class="_ _3"></span>mutex <span class="_ _3"></span>protects <span class="_ _2"></span>a <span class="_ _3"></span>hash <span class="_ _3"></span>list <span class="_ _3"></span>that <span class="_ _3"></span>we <span class="_ _3"></span>use</span></span></div><div class="t m0 x32 h4d y333e ff19 fs26 fc0 sc0 ls0 ws0">to <span class="_ _9"></span>keep <span class="_ _9"></span>track <span class="_ _9"></span>of <span class="_ _23"></span>the<span class="_ _45"> </span><span class="ff1a">foo<span class="_ _45"> </span></span>data <span class="_ _9"></span>structur<span class="_ _0"></span>es. <span class="_ _45"> </span>Thus<span class="_ _45"> </span>the<span class="_ _45"> </span><span class="ff1a">hashlock<span class="_ _45"> </span></span>mutex <span class="_ _9"></span>protects <span class="_ _9"></span>both <span class="_ _9"></span>the</div><div class="t m0 x32 h4d y333f ff1a fs26 fc0 sc0 ls0 ws0">fh<span class="_ _47"> </span><span class="ff19">hash <span class="_ _2"></span>table <span class="_ _3"></span>and <span class="_ _3"></span>the<span class="_ _47"> </span></span>f_next<span class="_ _47"> </span><span class="ff19">hash <span class="_ _3"></span>link <span class="_ _3"></span>ﬁeld <span class="_ _3"></span>in <span class="_ _2"></span>the<span class="_ _47"> </span></span>foo<span class="_ _47"> </span><span class="ff19">structure. <span class="_ _47"> </span>The<span class="_ _47"> </span></span>f_lock<span class="_ _47"> </span><span class="ff19">mutex</span></div><div class="t m0 x32 h4d y3340 ff19 fs26 fc0 sc0 ls0 ws0">in the<span class="_"> </span><span class="ff1a">foo<span class="_ _80"> </span></span>structur<span class="lsd3">ep<span class="_ _4f"></span><span class="lscc">ro<span class="_ _2"></span><span class="ls0">tects access to the remainder of the<span class="_"> </span><span class="ff1a">foo<span class="_ _80"> </span></span>structure’s ﬁelds.</span></span></span></div><a class="l" href="#pf10" data-dest-detail='[16,"XYZ",50,757,1]'><div class="d m1" style="border-style:none;position:absolute;left:156.492009px;bottom:891.050980px;width:162.996979px;height:19.680023px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[2.100000,0.000000,0.000000,2.100000,-115.668004,-156.491993]}'></div></div>
